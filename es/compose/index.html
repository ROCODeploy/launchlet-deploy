<!DOCTYPE html>
<html lang="es">
<head>
	<title>Componer</title>
	<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0">
	<link rel="canonical" href="/compose" />
	<link rel="alternate" hreflang="en" href="/en/compose" />
	<link rel="alternate" hreflang="fr" href="/fr/compose" />
	<link rel="alternate" hreflang="es" href="/es/compose" />
	<link rel="alternate" hreflang="pt" href="/pt/compose" />
	<script type="text/javascript">
		window.OLSKPublicConstants = function (inputData) {
			return {"OLSKSharedActiveRouteConstant":"LCHComposeRoute","OLSKSharedPageLanguagesAvailable":["en","fr","es","pt"],"OLSKSharedPageCurrentLanguage":"es"}[inputData];
		};
	</script>
	<link rel="apple-touch-icon" href="https://static.rosano.ca/launchlet/touch.png">
	<script src="/_shared/__external/OLSKRouting/main.js"></script>
	<script type="text/javascript">
		window.OLSKCanonical = function(routeConstant, optionalParams) {
			return OLSKRouting.OLSKRoutingCanonicalPath(({"LCHComposeRoute":"/compose","LCHGuideRoute":"/guide","LCHServiceWorkerRoute":"/sw.js"})[routeConstant], optionalParams);
		};
	</script>
	<link rel="stylesheet" type="text/css" href="/_shared/__external/normalize.css/normalize.css">
	<link rel="stylesheet" type="text/css" href="/_shared/__external/OLSKDecor/ui-style.css">
	<link rel="stylesheet" type="text/css" href="/_shared/__external/codemirror/lib/codemirror.css">
	<script src="/_shared/__external/codemirror/lib/codemirror.js"></script>
	<script src="/_shared/__external/codemirror/mode/javascript/javascript.js"></script>
	<script src="/_shared/__external/codemirror/mode/css/css.js"></script>
	<script src="/_shared/__external/codemirror/addon/display/placeholder.js"></script>
	<script src="/_shared/__external/codemirror/addon/search/search.js"></script>
	<script src="/_shared/__external/codemirror/addon/search/searchcursor.js"></script>
	<script src="/_shared/__external/codemirror/addon/search/jump-to-line.js"></script>
	<link rel="stylesheet" type="text/css" href="/_shared/__external/codemirror/addon/dialog/dialog.css">
	<script src="/_shared/__external/codemirror/addon/dialog/dialog.js"></script>
	<script src="/_shared/__external/codemirror/keymap/sublime.js"></script>
	<script src="/_shared/__external/simplecrypto/src/simplecrypto.js"></script>
	<script src="/_shared/__external/webnative/dist/index.umd.min.js"></script>
	<link rel="stylesheet" type="text/css" href="/_shared/common/ui-style.css">
	<script src="/open-compose/../dev-package/__compiled/launchlet.js"></script>
	<link rel="stylesheet" type="text/css" href="/open-compose/../dev-package/__compiled/launchlet.css">
	<link rel="stylesheet" type="text/css" href="/open-compose/__compiled/ui-style.css">
	<script defer data-domain="launchlet.dev" src="https://stats.rosano.ca/js/script.js"></script>
</head>

<body>



<textarea id="LCHComposeBuildPackageStyle" style="display: none;">.OLSKResultsListItem.svelte-617v38{cursor:pointer}
.Container.svelte-1rxh210{line-height:1.15;-webkit-text-size-adjust:100%}.Container.svelte-1rxh210{margin:0}.Container.svelte-1rxh210 main {display:block}.Container.svelte-1rxh210 h1 {font-size:2em;margin:0.67em 0}.Container.svelte-1rxh210 hr {box-sizing:content-box;height:0;overflow:visible}.Container.svelte-1rxh210 pre {font-family:monospace, monospace;font-size:1em}.Container.svelte-1rxh210 a {background-color:transparent}.Container.svelte-1rxh210 abbr[title] {border-bottom:none;text-decoration:underline;text-decoration:underline dotted}.Container.svelte-1rxh210 strong {font-weight:bolder}.Container.svelte-1rxh210 samp {font-family:monospace, monospace;font-size:1em}.Container.svelte-1rxh210 small {font-size:80%}.Container.svelte-1rxh210 sup {font-size:75%;line-height:0;position:relative;vertical-align:baseline}.Container.svelte-1rxh210 sub {bottom:-0.25em}.Container.svelte-1rxh210 sup {top:-0.5em}.Container.svelte-1rxh210 img {border-style:none}button.svelte-1rxh210,input.svelte-1rxh210,.Container.svelte-1rxh210 textarea {font-family:inherit;font-size:100%;line-height:1.15;margin:0}button.svelte-1rxh210,.Container.svelte-1rxh210 input {overflow:visible}button.svelte-1rxh210,.Container.svelte-1rxh210 select {text-transform:none}button.svelte-1rxh210,.Container.svelte-1rxh210 [type=&#34;submit&#34;] {-webkit-appearance:button}button.svelte-1rxh210::-moz-focus-inner,.Container.svelte-1rxh210 [type=&#34;submit&#34;]::-moz-focus-inner {border-style:none;padding:0}button.svelte-1rxh210:-moz-focusring,.Container.svelte-1rxh210 [type=&#34;submit&#34;]:-moz-focusring {outline:1px dotted ButtonText}.Container.svelte-1rxh210 fieldset {padding:0.35em 0.75em 0.625em}.Container.svelte-1rxh210 legend {box-sizing:border-box;color:inherit;display:table;max-width:100%;padding:0;white-space:normal}.Container.svelte-1rxh210 progress {vertical-align:baseline}.Container.svelte-1rxh210 textarea {overflow:auto}.Container.svelte-1rxh210 [type=&#34;radio&#34;] {box-sizing:border-box;padding:0}.Container.svelte-1rxh210 [type=&#34;number&#34;]::-webkit-outer-spin-button {height:auto}.Container.svelte-1rxh210 [type=&#34;search&#34;] {-webkit-appearance:textfield;outline-offset:-2px}.Container.svelte-1rxh210 [type=&#34;search&#34;]::-webkit-search-decoration {-webkit-appearance:none}.Container.svelte-1rxh210 ::-webkit-file-upload-button {-webkit-appearance:button;font:inherit}.Container.svelte-1rxh210 details {display:block}.Container.svelte-1rxh210 summary {display:list-item}.Container.svelte-1rxh210 template {display:none}.Container.svelte-1rxh210 [hidden] {display:none}.Container.svelte-1rxh210{--__LaunchletWidth:400px;--__LaunchletSharedPadding:5px;width:var(--__LaunchletWidth);padding:var(--__LaunchletSharedPadding);border:1px solid #cccccc;border-radius:5px;box-shadow:0 0 10px 0px #e6e6e6;position:fixed;top:0;left:50%;margin:0 0 0 calc(var(--__LaunchletWidth) / -2);z-index:999999999;color:black;background:#e6e6e6;font-family:&#39;Lucida Grande&#39;, &#39;Helvetica&#39;, sans-serif;text-align:initial;display:flex;flex-direction:column}input.svelte-1rxh210{border:none;background:none;color:#3f3f3f;outline:none}.LCHLauncherPromptHeading.svelte-1rxh210{padding:3px;font-family:&#39;Helvetica Neue&#39;, &#39;Helvetica&#39;, sans-serif;font-size:8pt;color:hsl(0, 0%, 60%);display:block}.LCHLauncherPromptHeadingMatchStop.svelte-1rxh210{color:#fd6666}.Container.svelte-1rxh210 .OLSKResultsList{width:95%;padding-left:5px;border-left:1px solid hsl(0, 0%, 80%);margin:5px;margin-right:none;color:black;max-height:165px;overflow-y:scroll}.Container.svelte-1rxh210 .OLSKResultsListItem{overflow:hidden;white-space:nowrap;text-overflow:ellipsis}.LCHLauncherPromptSelected.svelte-1rxh210 .LCHLauncherZoneInputBezel,.LCHLauncherPromptSelected.svelte-1rxh210 .OLSKResultsListItemSelected{background:hsl(0, 0%, 85%)}.LCHLauncherSubjectPromptPlaceholder.svelte-1rxh210{display:inline-block;font-size:8pt;color:hsl(0, 0%, 20%);align-self:center}@media screen and (max-width: 760px){.Container.svelte-1rxh210{width:100%;padding:0;border:none;border-radius:0;border-bottom:1px solid #cccccc;left:0;margin:0}input.svelte-1rxh210{width:100%;padding:10px;border:none;border-radius:0;border-bottom:1px solid #cccccc;background:#f3f3f3;font-family:&#39;Helvetica Neue&#39;, &#39;Helvetica&#39;, sans-serif;font-size:16pt}.Container.svelte-1rxh210 .OLSKResultsList{width:100%;padding-left:0;border-left:none;margin:0;max-height:220px;-webkit-overflow-scrolling:touch}.LCHLauncherPromptSelected.svelte-1rxh210 .LCHLauncherZoneInputBezel,.LCHLauncherPromptSelected.svelte-1rxh210 .OLSKResultsListItemSelected{background:hsl(0, 0%, 80%)}}
.LCHLauncherPipeItem.svelte-1u2sunx{padding:4px;font-size:8pt;color:hsl(0, 0%, 0%)}.LCHLauncherPipeItemSubtitle.svelte-1u2sunx,.LCHLauncherPipeItemSource.svelte-1u2sunx{font-size:7.5pt;opacity:0.4}@media screen and (max-width: 760px){.LCHLauncherPipeItem.svelte-1u2sunx{padding:10px;font-family:&#39;Helvetica Neue&#39;, &#39;Helvetica&#39;, sans-serif;font-weight:bold;font-size:13.5pt;color:hsl(0, 0%, 0%)}}
@media screen and (min-width: 760px){.LCHLauncherZoneInput.svelte-m73tr1{padding:3px;border:solid 1px hsl(0, 0%, 90%);border-radius:6px;background:hsl(0, 0%, 95%);display:flex;justify-content:center}.LCHLauncherZoneInputBezel.svelte-m73tr1{height:20px;padding:4px;border-radius:4px;flex-grow:1;display:flex;flex-direction:column;justify-content:center}}

/*# sourceMappingURL=launchlet.css.map */
/*# sourceMappingURL=launchlet.css.map */</textarea>
<textarea id="LCHComposeBuildPackageScript" style="display: none;">var Launchlet = (function () {
	&#39;use strict&#39;;

	var commonjsGlobal = typeof globalThis !== &#39;undefined&#39; ? globalThis : typeof window !== &#39;undefined&#39; ? window : typeof global !== &#39;undefined&#39; ? global : typeof self !== &#39;undefined&#39; ? self : {};

	function commonjsRequire () {
		throw new Error(&#39;Dynamic requires are not currently supported by rollup-plugin-commonjs&#39;);
	}

	function unwrapExports (x) {
		return x &amp;&amp; x.__esModule &amp;&amp; Object.prototype.hasOwnProperty.call(x, &#39;default&#39;) ? x[&#39;default&#39;] : x;
	}

	function createCommonjsModule(fn, module) {
		return module = { exports: {} }, fn(module, module.exports), module.exports;
	}

	var main = createCommonjsModule(function (module, exports) {
	const _require = commonjsRequire;

	const mod = {

		OLSKSpecUIArguments (inputData) {
			if (!Array.isArray(inputData)) {
				throw new Error(&#39;OLSKErrorInputNotValid&#39;);
			}

			return inputData.map(function (e) {
				if (e.match(/^match=/)) {
					return e.replace(/^match=/, &#39;-os-match=&#39;);
				}

				if (e.match(/^skip=/)) {
					return e.replace(/^skip=/, &#39;-os-skip=&#39;);
				}

				return e;
			});
		},

		OLSKSpecUITestPaths (inputData) {
			if (typeof inputData !== &#39;string&#39;) {
				throw new Error(&#39;OLSKErrorInputNotValid&#39;);
			}

			if (!_require().OLSKDiskIsRealFolderPath(inputData)) {
				throw new Error(&#39;OLSKErrorInputNotValid&#39;);
			}

			return _require().sync(&#39;**/ui-test-*.js&#39;, {
				cwd: inputData,
				realpath: true,
			}).filter(function (e) {
				return !e.match(_require().OLSKDiskStandardIgnorePattern());
			});
		},

		OLSKSpecUISourcePaths (inputData) {
			if (typeof inputData !== &#39;string&#39;) {
				throw new Error(&#39;OLSKErrorInputNotValid&#39;);
			}

			if (!_require().OLSKDiskIsRealFolderPath(inputData)) {
				throw new Error(&#39;OLSKErrorInputNotValid&#39;);
			}

			return _require().sync(&#39;**/+(ui-behaviour.js|*.ejs|*.md|*.html)&#39;, {
				cwd: inputData,
				realpath: true,
			}).filter(function (e) {
				if (e.match(&#39;__compiled&#39;)) {
					return true;
				}
				
				return !e.match(_require().OLSKDiskStandardIgnorePattern());
			});
		},

		OLSKSpecMochaPaths (inputData) {
			if (typeof inputData !== &#39;object&#39; || inputData === null) {
				throw new Error(&#39;OLSKErrorInputNotValid&#39;);
			}

			if (typeof inputData.ParamPackageDirectory !== &#39;string&#39;) {
				throw new Error(&#39;OLSKErrorInputNotValid&#39;);
			}

			if (typeof inputData.ParamWorkingDirectory !== &#39;string&#39;) {
				throw new Error(&#39;OLSKErrorInputNotValid&#39;);
			}

			return [
				_require().join(inputData.ParamPackageDirectory, &#39;./node_modules/.bin/mocha&#39;),
				_require().join(inputData.ParamPackageDirectory, &#39;../.bin/mocha&#39;),
				_require().join(inputData.ParamWorkingDirectory, &#39;./node_modules/.bin/mocha&#39;),
				];
		},

		_OLSKSpecMochaReplaceES6Import (inputData) {
			const exportable = [];
			
			inputData = inputData
				.replace(/^import \* as (\w+) from [&#39;&#34;]([^&#39;&#34;]+)[&#39;&#34;];?/gm, &#39;var $1 = require(&#34;$2&#34;);&#39;)
				// .replace(/^import (\w+) from [&#39;&#34;]([^&#39;&#34;]+)[&#39;&#34;];?/gm, &#39;var {default: $1} = require(&#34;$2&#34;);&#39;)
				.replace(/^import (\w+) from [&#39;&#34;]([^&#39;&#34;]+)[&#39;&#34;];?/gm, &#39;var _$1 = require(&#34;$2&#34;); const $1 = _$1.default || _$1&#39;)
				.replace(/^import {([^}]+)} from [&#39;&#34;](.+)[&#39;&#34;];?/gm, &#39;var {$1} = require(&#34;$2&#34;);&#39;)
				.replace(/^export default /gm, &#39;exports.default = &#39;)
				.replace(/^export (const|let|var|class|function) (\w+)/gm, (match, type, name) =&gt; {
					exportable.push(name);
					return `${type} ${name}`;
				})
				.replace(/^export \{([^}]+)\}(?: from [&#39;&#34;]([^&#39;&#34;]+)[&#39;&#34;];?)?/gm, (match, names, source) =&gt; {
					names.split(&#39;,&#39;).filter(Boolean).forEach(name =&gt; {
						exportable.push(name);
					});

					return source ? `const { ${names} } = require(&#34;${source}&#34;);` : &#39;&#39;;
				})
				.replace(/^export function (\w+)/gm, &#39;exports.$1 = function $1&#39;);

			exportable.forEach(name =&gt; {
				inputData += `\nexports.${name} = ${name};`;
			});

			return inputData;
		},
		
	};

	Object.assign(exports, mod);

	{
		exports.OLSK_SPEC_UI = function () {
			if (typeof navigator === &#39;undefined&#39;) {
				return false;
			}

			if (typeof window !== &#39;undefined&#39; &amp;&amp; window.location.hostname === &#39;loc.tests&#39;) {
				return true;
			}

			return navigator.appName === &#39;Zombie&#39;;
		};
	}
	});
	var main_1 = main.OLSK_SPEC_UI;

	const mod = {

		LCHFormulaSafeStringFields: [
			&#39;LCHFormulaID&#39;,
			&#39;LCHFormulaName&#39;,
			&#39;LCHFormulaSignature&#39;,
			&#39;LCHFormulaInputTypes&#39;,
			&#39;LCHFormulaOutputType&#39;,
			&#39;LCHFormulaStyle&#39;,
			&#39;LCHFormulaURLFilter&#39;,
			&#39;LCHFormulaCreationDate&#39;,
			&#39;LCHFormulaModificationDate&#39;,
			&#39;LCHFormulaSyntaxErrorMessage&#39;,
			&#39;@context&#39;,
		],

		LCHFormulaErrors (inputData, options = {}) {
			if (typeof inputData !== &#39;object&#39; || inputData === null) {
				throw new Error(&#39;LCHErrorInputNotValid&#39;);
			}

			const errors = {};

			if (inputData.LCHFormulaName !== undefined || options.LCHOptionValidateIfNotPresent) {
				if (typeof inputData.LCHFormulaName !== &#39;string&#39;) {
					errors.LCHFormulaName = [
						&#39;LCHErrorNotString&#39;,
					];
				}
			}

			if (inputData.LCHFormulaSignature !== undefined || options.LCHOptionValidateIfNotPresent) {
				if (typeof inputData.LCHFormulaSignature !== &#39;string&#39;) {
					errors.LCHFormulaSignature = [
						&#39;LCHErrorNotString&#39;,
					];
				}
			}

			if (inputData.LCHFormulaInputTypes !== undefined || options.LCHOptionValidateIfNotPresent) {
				if (typeof inputData.LCHFormulaInputTypes !== &#39;string&#39;) {
					errors.LCHFormulaInputTypes = [
						&#39;LCHErrorNotString&#39;,
					];
				}
			}

			if (inputData.LCHFormulaOutputType !== undefined || options.LCHOptionValidateIfNotPresent) {
				if (typeof inputData.LCHFormulaOutputType !== &#39;string&#39;) {
					errors.LCHFormulaOutputType = [
						&#39;LCHErrorNotString&#39;,
					];
				}
			}

			if (inputData.LCHFormulaIsHidden !== undefined) {
				if (typeof inputData.LCHFormulaIsHidden !== &#39;function&#39;) {
					errors.LCHFormulaIsHidden = [
						&#39;LCHErrorNotFunction&#39;,
					];
				}
			}

			if (inputData.LCHFormulaURLFilter !== undefined || options.LCHOptionValidateIfNotPresent) {
				if (typeof inputData.LCHFormulaURLFilter !== &#39;string&#39;) {
					errors.LCHFormulaURLFilter = [
						&#39;LCHErrorNotString&#39;,
					];
				}
			}

			if (inputData.LCHFormulaIsAutomatic !== undefined || options.LCHOptionValidateIfNotPresent) {
				if (typeof inputData.LCHFormulaIsAutomatic !== &#39;boolean&#39;) {
					errors.LCHFormulaIsAutomatic = [
						&#39;LCHErrorNotBoolean&#39;,
					];
				}
			}

			if (inputData.LCHFormulaStyle !== undefined || options.LCHOptionValidateIfNotPresent) {
				if (typeof inputData.LCHFormulaStyle !== &#39;string&#39;) {
					errors.LCHFormulaStyle = [
						&#39;LCHErrorNotString&#39;,
					];
				}
			}

			if (inputData.LCHFormulaIsFlagged !== undefined || options.LCHOptionValidateIfNotPresent) {
				if (typeof inputData.LCHFormulaIsFlagged !== &#39;boolean&#39;) {
					errors.LCHFormulaIsFlagged = [
						&#39;LCHErrorNotBoolean&#39;,
					];
				}
			}

			return Object.entries(errors).length ? errors : null;
		},

		LCHFormulaFrom (inputData) {
			if (typeof inputData !== &#39;object&#39; || inputData === null) {
				throw new Error(&#39;LCHErrorInputNotValid&#39;);
			}

			return Object.entries(inputData).reduce(function (coll, item) {
				coll[item[0].replace(/LCH[A-Z][a-z]+/, &#39;LCHFormula&#39;)] = item[1];

				return coll;
			}, {});
		},

		LCHFormulaTo (param1, param2) {
			if (typeof param1 !== &#39;object&#39; || param1 === null) {
				throw new Error(&#39;LCHErrorInputNotValid&#39;);
			}

			if (typeof param2 !== &#39;string&#39;) {
				throw new Error(&#39;LCHErrorInputNotValid&#39;);
			}

			return Object.entries(param1).reduce(function (coll, item) {
				coll[item[0].replace(&#39;LCHFormula&#39;, param2)] = item[1];

				return coll;
			}, {});
		},

		LCHFormulaToEvaluate (inputData) {
			if (mod.LCHFormulaErrors(inputData)) {
				throw new Error(&#39;LCHErrorInputNotValid&#39;);
			}

			let outputData = Object.fromEntries(Object.entries(inputData).filter(function (e) {
				return !mod.LCHFormulaSafeStringFields.includes(e[0]);
			}));

			if (outputData.LCHFormulaCallbackArgs || outputData.LCHFormulaCallbackBody) {
				outputData.LCHFormulaCallbackRaw = `(function (${ outputData.LCHFormulaCallbackArgs || &#39;&#39; }) { ${ outputData.LCHFormulaCallbackBody || &#39;&#39; } })`;
				delete outputData.LCHFormulaCallbackArgs;
				delete outputData.LCHFormulaCallbackBody;
			}

			if (outputData.LCHFormulaCanonicalExampleCallbackBody) {
				outputData.LCHFormulaCanonicalExampleCallbackRaw = `(function () { ${ outputData.LCHFormulaCanonicalExampleCallbackBody || &#39;&#39; } })`;
				delete outputData.LCHFormulaCanonicalExampleCallbackBody;
			}

			return outputData;
		},

	};

	const mod$1 = {

		LCHRuntimeURLFilter (param1, param2) {
			if (typeof param1 !== &#39;string&#39;) {
				throw new Error(&#39;LCHErrorInputNotValid&#39;);
			}

			if (typeof param2 !== &#39;string&#39;) {
				throw new Error(&#39;LCHErrorInputNotValid&#39;);
			}

			if (!param2) {
				throw new Error(&#39;LCHErrorInputNotValid&#39;);
			}

			if (param1 === &#39;*&#39;) {
				return true;
			}

			let match = param1.match(/^\/(.*)\/(\w*)/i);

			if (!match || !match.shift()) {
				return param2.includes(param1);
			}

			return !!param2.match(new RegExp(match[0], match[1]));
		},

		LCHRuntimeInputTypes(inputData) {
			if (typeof inputData !== &#39;string&#39;) {
				throw new Error(&#39;LCHErrorInputNotValid&#39;);
			}

			return inputData.split(&#39;,&#39;).map(function (e) {
				return e.trim();
			}).filter(function (e) {
				return !!e;
			});
		},

		LCHRuntimeAPI(inputData) {
			if (!Array.isArray(inputData)) {
				throw new Error(&#39;LCHErrorInputNotValid&#39;);
			}

			const outputData = {
				fn (signature) {
					if (typeof signature !== &#39;string&#39;) {
						throw new Error(&#39;LCHErrorIdentifierNotString&#39;);
					}

					if (signature === &#39;&#39;) {
						throw new Error(&#39;LCHErrorIdentifierBlank&#39;);
					}

					if (signature.trim() !== signature) {
						throw new Error(&#39;LCHErrorIdentifierContainsUntrimmedWhitespace&#39;);
					}

					let functionObject = inputData.filter(function (e) {
						return e.LCHRecipeSignature === signature;
					}).shift();

					if (!functionObject) {
						throw new Error(&#39;LCHErrorIdentifierNotDefined&#39;);
					}

					return functionObject.LCHRecipeCallback.bind({
						api: outputData,
					});
				},
			};

			Object.assign(outputData, inputData.reduce(function (coll, item) {
				if (!coll[item.LCHRecipeSignature]) {
					coll[item.LCHRecipeSignature] = function () {
						const args = arguments;

						(item.LCHRecipeInputTypes ? mod$1.LCHRuntimeInputTypes(item.LCHRecipeInputTypes) : []).forEach(function (e, i) {
							if (!coll[e](args[i])) {
								throw new Error(&#39;LCHErrorTypeMismatch&#39;);
							}
						});

						return item.LCHRecipeCallback.apply({
							api: outputData,
						}, args);
					};
				}

				return coll;
			}, {}));

			Object.freeze(outputData);

			return outputData;
		},

	};

	const LCHTypeServiceSearchCallback = function(inputData) {
		if (!inputData.LCHRecipeName) {
			return false;
		}
		
		if (inputData.LCHRecipeCallback.length) {
			return false;
		}
		
		if (inputData.LCHRecipeOutputType !== &#39;ServiceSearchURLTemplate&#39;) {
			return false;
		}

		return true;
	};

	const LCHTypeServiceSearchCanonicalExampleCallback = function() {
		return {
			LCHRecipeName: &#39;alfa&#39;,
			LCHRecipeCallback () {
				return &#39;https://example.com?q=LCHSEARCHTOKEN&#39;;
			},
			LCHRecipeOutputType: &#39;ServiceSearchURLTemplate&#39;,
		};
	};

	const LCHTypeServiceSearchRecipe = function() {
		return {
			LCHRecipeSignature: &#39;ServiceSearch&#39;,
			LCHRecipeCallback: LCHTypeServiceSearchCallback,
			LCHRecipeOutputType: &#39;Bool&#39;,
			LCHRecipeCanonicalExampleCallback: LCHTypeServiceSearchCanonicalExampleCallback,
		};
	};

	var ServiceSearch = /*#__PURE__*/Object.freeze({
		LCHTypeServiceSearchCallback: LCHTypeServiceSearchCallback,
		LCHTypeServiceSearchCanonicalExampleCallback: LCHTypeServiceSearchCanonicalExampleCallback,
		LCHTypeServiceSearchRecipe: LCHTypeServiceSearchRecipe
	});

	const LCHPrimitiveBoolCallback = function(inputData) {
		return !!inputData;
	};

	const LCHPrimitiveBoolRecipe = function() {
		return {
			LCHRecipeSignature: &#39;Bool&#39;,
			LCHRecipeCallback: LCHPrimitiveBoolCallback,
		};
	};

	var Bool = /*#__PURE__*/Object.freeze({
		LCHPrimitiveBoolCallback: LCHPrimitiveBoolCallback,
		LCHPrimitiveBoolRecipe: LCHPrimitiveBoolRecipe
	});

	const LCHPrimitiveDateCallback = function(inputData) {
		if (!(inputData instanceof Date)) {
			return false;
		}

		if (Number.isNaN(inputData.getTime())) {
			return false;
		}

		return true;
	};

	const LCHPrimitiveDateCanonicalExampleCallback = function() {
		return new Date(0);
	};

	const LCHPrimitiveDateRecipe = function() {
		return {
			LCHRecipeSignature: &#39;Date&#39;,
			LCHRecipeCallback: LCHPrimitiveDateCallback,
			LCHRecipeOutputType: &#39;Bool&#39;,
			LCHRecipeCanonicalExampleCallback: LCHPrimitiveDateCanonicalExampleCallback,
		};
	};

	var Date$1 = /*#__PURE__*/Object.freeze({
		LCHPrimitiveDateCallback: LCHPrimitiveDateCallback,
		LCHPrimitiveDateCanonicalExampleCallback: LCHPrimitiveDateCanonicalExampleCallback,
		LCHPrimitiveDateRecipe: LCHPrimitiveDateRecipe
	});

	const LCHPrimitiveDOMElementCallback = function(inputData) {
		if (typeof inputData !== &#39;object&#39; || inputData === null) {
			return false;
		}

		if (typeof inputData.focus !== &#39;function&#39;) {
			return false;
		}

		return true;
	};

	const LCHPrimitiveDOMElementCanonicalExampleCallback = function() {
		return {
			focus () {},
		};
	};

	const LCHPrimitiveDOMElementRecipe = function() {
		return {
			LCHRecipeCallback: LCHPrimitiveDOMElementCallback,
			LCHRecipeOutputType: &#39;Bool&#39;,
			LCHRecipeCanonicalExampleCallback: LCHPrimitiveDOMElementCanonicalExampleCallback,
			LCHRecipeSignature: &#39;DOMElement&#39;,
			_LCHRecipeTypeIsExclusive: true,
		};
	};

	var DOMElement = /*#__PURE__*/Object.freeze({
		LCHPrimitiveDOMElementCallback: LCHPrimitiveDOMElementCallback,
		LCHPrimitiveDOMElementCanonicalExampleCallback: LCHPrimitiveDOMElementCanonicalExampleCallback,
		LCHPrimitiveDOMElementRecipe: LCHPrimitiveDOMElementRecipe
	});

	/**
	 * Check if we&#39;re required to add a port number.
	 *
	 * @see https://url.spec.whatwg.org/#default-port
	 * @param {Number|String} port Port number we need to check
	 * @param {String} protocol Protocol we need to check against.
	 * @returns {Boolean} Is it a default port for the given protocol
	 * @api private
	 */
	var requiresPort = function required(port, protocol) {
	  protocol = protocol.split(&#39;:&#39;)[0];
	  port = +port;

	  if (!port) return false;

	  switch (protocol) {
	    case &#39;http&#39;:
	    case &#39;ws&#39;:
	    return port !== 80;

	    case &#39;https&#39;:
	    case &#39;wss&#39;:
	    return port !== 443;

	    case &#39;ftp&#39;:
	    return port !== 21;

	    case &#39;gopher&#39;:
	    return port !== 70;

	    case &#39;file&#39;:
	    return false;
	  }

	  return port !== 0;
	};

	var has = Object.prototype.hasOwnProperty
	  , undef;

	/**
	 * Decode a URI encoded string.
	 *
	 * @param {String} input The URI encoded string.
	 * @returns {String|Null} The decoded string.
	 * @api private
	 */
	function decode(input) {
	  try {
	    return decodeURIComponent(input.replace(/\+/g, &#39; &#39;));
	  } catch (e) {
	    return null;
	  }
	}

	/**
	 * Attempts to encode a given input.
	 *
	 * @param {String} input The string that needs to be encoded.
	 * @returns {String|Null} The encoded string.
	 * @api private
	 */
	function encode(input) {
	  try {
	    return encodeURIComponent(input);
	  } catch (e) {
	    return null;
	  }
	}

	/**
	 * Simple query string parser.
	 *
	 * @param {String} query The query string that needs to be parsed.
	 * @returns {Object}
	 * @api public
	 */
	function querystring(query) {
	  var parser = /([^=?#&amp;]+)=?([^&amp;]*)/g
	    , result = {}
	    , part;

	  while (part = parser.exec(query)) {
	    var key = decode(part[1])
	      , value = decode(part[2]);

	    //
	    // Prevent overriding of existing properties. This ensures that build-in
	    // methods like `toString` or __proto__ are not overriden by malicious
	    // querystrings.
	    //
	    // In the case if failed decoding, we want to omit the key/value pairs
	    // from the result.
	    //
	    if (key === null || value === null || key in result) continue;
	    result[key] = value;
	  }

	  return result;
	}

	/**
	 * Transform a query string to an object.
	 *
	 * @param {Object} obj Object that should be transformed.
	 * @param {String} prefix Optional prefix.
	 * @returns {String}
	 * @api public
	 */
	function querystringify(obj, prefix) {
	  prefix = prefix || &#39;&#39;;

	  var pairs = []
	    , value
	    , key;

	  //
	  // Optionally prefix with a &#39;?&#39; if needed
	  //
	  if (&#39;string&#39; !== typeof prefix) prefix = &#39;?&#39;;

	  for (key in obj) {
	    if (has.call(obj, key)) {
	      value = obj[key];

	      //
	      // Edge cases where we actually want to encode the value to an empty
	      // string instead of the stringified value.
	      //
	      if (!value &amp;&amp; (value === null || value === undef || isNaN(value))) {
	        value = &#39;&#39;;
	      }

	      key = encode(key);
	      value = encode(value);

	      //
	      // If we failed to encode the strings, we should bail out as we don&#39;t
	      // want to add invalid strings to the query.
	      //
	      if (key === null || value === null) continue;
	      pairs.push(key +&#39;=&#39;+ value);
	    }
	  }

	  return pairs.length ? prefix + pairs.join(&#39;&amp;&#39;) : &#39;&#39;;
	}

	//
	// Expose the module.
	//
	var stringify = querystringify;
	var parse = querystring;

	var querystringify_1 = {
		stringify: stringify,
		parse: parse
	};

	var slashes = /^[A-Za-z][A-Za-z0-9+-.]*:[\\/]+/
	  , protocolre = /^([a-z][a-z0-9.+-]*:)?([\\/]{1,})?([\S\s]*)/i
	  , whitespace = &#39;[\\x09\\x0A\\x0B\\x0C\\x0D\\x20\\xA0\\u1680\\u180E\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200A\\u202F\\u205F\\u3000\\u2028\\u2029\\uFEFF]&#39;
	  , left = new RegExp(&#39;^&#39;+ whitespace +&#39;+&#39;);

	/**
	 * Trim a given string.
	 *
	 * @param {String} str String to trim.
	 * @public
	 */
	function trimLeft(str) {
	  return (str ? str : &#39;&#39;).toString().replace(left, &#39;&#39;);
	}

	/**
	 * These are the parse rules for the URL parser, it informs the parser
	 * about:
	 *
	 * 0. The char it Needs to parse, if it&#39;s a string it should be done using
	 *    indexOf, RegExp using exec and NaN means set as current value.
	 * 1. The property we should set when parsing this value.
	 * 2. Indication if it&#39;s backwards or forward parsing, when set as number it&#39;s
	 *    the value of extra chars that should be split off.
	 * 3. Inherit from location if non existing in the parser.
	 * 4. `toLowerCase` the resulting value.
	 */
	var rules = [
	  [&#39;#&#39;, &#39;hash&#39;],                        // Extract from the back.
	  [&#39;?&#39;, &#39;query&#39;],                       // Extract from the back.
	  function sanitize(address) {          // Sanitize what is left of the address
	    return address.replace(&#39;\\&#39;, &#39;/&#39;);
	  },
	  [&#39;/&#39;, &#39;pathname&#39;],                    // Extract from the back.
	  [&#39;@&#39;, &#39;auth&#39;, 1],                     // Extract from the front.
	  [NaN, &#39;host&#39;, undefined, 1, 1],       // Set left over value.
	  [/:(\d+)$/, &#39;port&#39;, undefined, 1],    // RegExp the back.
	  [NaN, &#39;hostname&#39;, undefined, 1, 1]    // Set left over.
	];

	/**
	 * These properties should not be copied or inherited from. This is only needed
	 * for all non blob URL&#39;s as a blob URL does not include a hash, only the
	 * origin.
	 *
	 * @type {Object}
	 * @private
	 */
	var ignore = { hash: 1, query: 1 };

	/**
	 * The location object differs when your code is loaded through a normal page,
	 * Worker or through a worker using a blob. And with the blobble begins the
	 * trouble as the location object will contain the URL of the blob, not the
	 * location of the page where our code is loaded in. The actual origin is
	 * encoded in the `pathname` so we can thankfully generate a good &#34;default&#34;
	 * location from it so we can generate proper relative URL&#39;s again.
	 *
	 * @param {Object|String} loc Optional default location object.
	 * @returns {Object} lolcation object.
	 * @public
	 */
	function lolcation(loc) {
	  var globalVar;

	  if (typeof window !== &#39;undefined&#39;) globalVar = window;
	  else if (typeof commonjsGlobal !== &#39;undefined&#39;) globalVar = commonjsGlobal;
	  else if (typeof self !== &#39;undefined&#39;) globalVar = self;
	  else globalVar = {};

	  var location = globalVar.location || {};
	  loc = loc || location;

	  var finaldestination = {}
	    , type = typeof loc
	    , key;

	  if (&#39;blob:&#39; === loc.protocol) {
	    finaldestination = new Url(unescape(loc.pathname), {});
	  } else if (&#39;string&#39; === type) {
	    finaldestination = new Url(loc, {});
	    for (key in ignore) delete finaldestination[key];
	  } else if (&#39;object&#39; === type) {
	    for (key in loc) {
	      if (key in ignore) continue;
	      finaldestination[key] = loc[key];
	    }

	    if (finaldestination.slashes === undefined) {
	      finaldestination.slashes = slashes.test(loc.href);
	    }
	  }

	  return finaldestination;
	}

	/**
	 * @typedef ProtocolExtract
	 * @type Object
	 * @property {String} protocol Protocol matched in the URL, in lowercase.
	 * @property {Boolean} slashes `true` if protocol is followed by &#34;//&#34;, else `false`.
	 * @property {String} rest Rest of the URL that is not part of the protocol.
	 */

	/**
	 * Extract protocol information from a URL with/without double slash (&#34;//&#34;).
	 *
	 * @param {String} address URL we want to extract from.
	 * @return {ProtocolExtract} Extracted information.
	 * @private
	 */
	function extractProtocol(address) {
	  address = trimLeft(address);

	  var match = protocolre.exec(address)
	    , protocol = match[1] ? match[1].toLowerCase() : &#39;&#39;
	    , slashes = !!(match[2] &amp;&amp; match[2].length &gt;= 2)
	    , rest =  match[2] &amp;&amp; match[2].length === 1 ? &#39;/&#39; + match[3] : match[3];

	  return {
	    protocol: protocol,
	    slashes: slashes,
	    rest: rest
	  };
	}

	/**
	 * Resolve a relative URL pathname against a base URL pathname.
	 *
	 * @param {String} relative Pathname of the relative URL.
	 * @param {String} base Pathname of the base URL.
	 * @return {String} Resolved pathname.
	 * @private
	 */
	function resolve(relative, base) {
	  if (relative === &#39;&#39;) return base;

	  var path = (base || &#39;/&#39;).split(&#39;/&#39;).slice(0, -1).concat(relative.split(&#39;/&#39;))
	    , i = path.length
	    , last = path[i - 1]
	    , unshift = false
	    , up = 0;

	  while (i--) {
	    if (path[i] === &#39;.&#39;) {
	      path.splice(i, 1);
	    } else if (path[i] === &#39;..&#39;) {
	      path.splice(i, 1);
	      up++;
	    } else if (up) {
	      if (i === 0) unshift = true;
	      path.splice(i, 1);
	      up--;
	    }
	  }

	  if (unshift) path.unshift(&#39;&#39;);
	  if (last === &#39;.&#39; || last === &#39;..&#39;) path.push(&#39;&#39;);

	  return path.join(&#39;/&#39;);
	}

	/**
	 * The actual URL instance. Instead of returning an object we&#39;ve opted-in to
	 * create an actual constructor as it&#39;s much more memory efficient and
	 * faster and it pleases my OCD.
	 *
	 * It is worth noting that we should not use `URL` as class name to prevent
	 * clashes with the global URL instance that got introduced in browsers.
	 *
	 * @constructor
	 * @param {String} address URL we want to parse.
	 * @param {Object|String} [location] Location defaults for relative paths.
	 * @param {Boolean|Function} [parser] Parser for the query string.
	 * @private
	 */
	function Url(address, location, parser) {
	  address = trimLeft(address);

	  if (!(this instanceof Url)) {
	    return new Url(address, location, parser);
	  }

	  var relative, extracted, parse, instruction, index, key
	    , instructions = rules.slice()
	    , type = typeof location
	    , url = this
	    , i = 0;

	  //
	  // The following if statements allows this module two have compatibility with
	  // 2 different API:
	  //
	  // 1. Node.js&#39;s `url.parse` api which accepts a URL, boolean as arguments
	  //    where the boolean indicates that the query string should also be parsed.
	  //
	  // 2. The `URL` interface of the browser which accepts a URL, object as
	  //    arguments. The supplied object will be used as default values / fall-back
	  //    for relative paths.
	  //
	  if (&#39;object&#39; !== type &amp;&amp; &#39;string&#39; !== type) {
	    parser = location;
	    location = null;
	  }

	  if (parser &amp;&amp; &#39;function&#39; !== typeof parser) parser = querystringify_1.parse;

	  location = lolcation(location);

	  //
	  // Extract protocol information before running the instructions.
	  //
	  extracted = extractProtocol(address || &#39;&#39;);
	  relative = !extracted.protocol &amp;&amp; !extracted.slashes;
	  url.slashes = extracted.slashes || relative &amp;&amp; location.slashes;
	  url.protocol = extracted.protocol || location.protocol || &#39;&#39;;
	  address = extracted.rest;

	  //
	  // When the authority component is absent the URL starts with a path
	  // component.
	  //
	  if (!extracted.slashes) instructions[3] = [/(.*)/, &#39;pathname&#39;];

	  for (; i &lt; instructions.length; i++) {
	    instruction = instructions[i];

	    if (typeof instruction === &#39;function&#39;) {
	      address = instruction(address);
	      continue;
	    }

	    parse = instruction[0];
	    key = instruction[1];

	    if (parse !== parse) {
	      url[key] = address;
	    } else if (&#39;string&#39; === typeof parse) {
	      if (~(index = address.indexOf(parse))) {
	        if (&#39;number&#39; === typeof instruction[2]) {
	          url[key] = address.slice(0, index);
	          address = address.slice(index + instruction[2]);
	        } else {
	          url[key] = address.slice(index);
	          address = address.slice(0, index);
	        }
	      }
	    } else if ((index = parse.exec(address))) {
	      url[key] = index[1];
	      address = address.slice(0, index.index);
	    }

	    url[key] = url[key] || (
	      relative &amp;&amp; instruction[3] ? location[key] || &#39;&#39; : &#39;&#39;
	    );

	    //
	    // Hostname, host and protocol should be lowercased so they can be used to
	    // create a proper `origin`.
	    //
	    if (instruction[4]) url[key] = url[key].toLowerCase();
	  }

	  //
	  // Also parse the supplied query string in to an object. If we&#39;re supplied
	  // with a custom parser as function use that instead of the default build-in
	  // parser.
	  //
	  if (parser) url.query = parser(url.query);

	  //
	  // If the URL is relative, resolve the pathname against the base URL.
	  //
	  if (
	      relative
	    &amp;&amp; location.slashes
	    &amp;&amp; url.pathname.charAt(0) !== &#39;/&#39;
	    &amp;&amp; (url.pathname !== &#39;&#39; || location.pathname !== &#39;&#39;)
	  ) {
	    url.pathname = resolve(url.pathname, location.pathname);
	  }

	  //
	  // Default to a / for pathname if none exists. This normalizes the URL
	  // to always have a /
	  //
	  if (url.pathname.charAt(0) !== &#39;/&#39; &amp;&amp; url.hostname) {
	    url.pathname = &#39;/&#39; + url.pathname;
	  }

	  //
	  // We should not add port numbers if they are already the default port number
	  // for a given protocol. As the host also contains the port number we&#39;re going
	  // override it with the hostname which contains no port number.
	  //
	  if (!requiresPort(url.port, url.protocol)) {
	    url.host = url.hostname;
	    url.port = &#39;&#39;;
	  }

	  //
	  // Parse down the `auth` for the username and password.
	  //
	  url.username = url.password = &#39;&#39;;
	  if (url.auth) {
	    instruction = url.auth.split(&#39;:&#39;);
	    url.username = instruction[0] || &#39;&#39;;
	    url.password = instruction[1] || &#39;&#39;;
	  }

	  url.origin = url.protocol &amp;&amp; url.host &amp;&amp; url.protocol !== &#39;file:&#39;
	    ? url.protocol +&#39;//&#39;+ url.host
	    : &#39;null&#39;;

	  //
	  // The href is just the compiled result.
	  //
	  url.href = url.toString();
	}

	/**
	 * This is convenience method for changing properties in the URL instance to
	 * insure that they all propagate correctly.
	 *
	 * @param {String} part          Property we need to adjust.
	 * @param {Mixed} value          The newly assigned value.
	 * @param {Boolean|Function} fn  When setting the query, it will be the function
	 *                               used to parse the query.
	 *                               When setting the protocol, double slash will be
	 *                               removed from the final url if it is true.
	 * @returns {URL} URL instance for chaining.
	 * @public
	 */
	function set(part, value, fn) {
	  var url = this;

	  switch (part) {
	    case &#39;query&#39;:
	      if (&#39;string&#39; === typeof value &amp;&amp; value.length) {
	        value = (fn || querystringify_1.parse)(value);
	      }

	      url[part] = value;
	      break;

	    case &#39;port&#39;:
	      url[part] = value;

	      if (!requiresPort(value, url.protocol)) {
	        url.host = url.hostname;
	        url[part] = &#39;&#39;;
	      } else if (value) {
	        url.host = url.hostname +&#39;:&#39;+ value;
	      }

	      break;

	    case &#39;hostname&#39;:
	      url[part] = value;

	      if (url.port) value += &#39;:&#39;+ url.port;
	      url.host = value;
	      break;

	    case &#39;host&#39;:
	      url[part] = value;

	      if (/:\d+$/.test(value)) {
	        value = value.split(&#39;:&#39;);
	        url.port = value.pop();
	        url.hostname = value.join(&#39;:&#39;);
	      } else {
	        url.hostname = value;
	        url.port = &#39;&#39;;
	      }

	      break;

	    case &#39;protocol&#39;:
	      url.protocol = value.toLowerCase();
	      url.slashes = !fn;
	      break;

	    case &#39;pathname&#39;:
	    case &#39;hash&#39;:
	      if (value) {
	        var char = part === &#39;pathname&#39; ? &#39;/&#39; : &#39;#&#39;;
	        url[part] = value.charAt(0) !== char ? char + value : value;
	      } else {
	        url[part] = value;
	      }
	      break;

	    default:
	      url[part] = value;
	  }

	  for (var i = 0; i &lt; rules.length; i++) {
	    var ins = rules[i];

	    if (ins[4]) url[ins[1]] = url[ins[1]].toLowerCase();
	  }

	  url.origin = url.protocol &amp;&amp; url.host &amp;&amp; url.protocol !== &#39;file:&#39;
	    ? url.protocol +&#39;//&#39;+ url.host
	    : &#39;null&#39;;

	  url.href = url.toString();

	  return url;
	}

	/**
	 * Transform the properties back in to a valid and full URL string.
	 *
	 * @param {Function} stringify Optional query stringify function.
	 * @returns {String} Compiled version of the URL.
	 * @public
	 */
	function toString(stringify) {
	  if (!stringify || &#39;function&#39; !== typeof stringify) stringify = querystringify_1.stringify;

	  var query
	    , url = this
	    , protocol = url.protocol;

	  if (protocol &amp;&amp; protocol.charAt(protocol.length - 1) !== &#39;:&#39;) protocol += &#39;:&#39;;

	  var result = protocol + (url.slashes ? &#39;//&#39; : &#39;&#39;);

	  if (url.username) {
	    result += url.username;
	    if (url.password) result += &#39;:&#39;+ url.password;
	    result += &#39;@&#39;;
	  }

	  result += url.host + url.pathname;

	  query = &#39;object&#39; === typeof url.query ? stringify(url.query) : url.query;
	  if (query) result += &#39;?&#39; !== query.charAt(0) ? &#39;?&#39;+ query : query;

	  if (url.hash) result += url.hash;

	  return result;
	}

	Url.prototype = { set: set, toString: toString };

	//
	// Expose the URL parser and some additional properties that might be useful for
	// others or testing.
	//
	Url.extractProtocol = extractProtocol;
	Url.location = lolcation;
	Url.trimLeft = trimLeft;
	Url.qs = querystringify_1;

	var urlParse = Url;

	var _URLParser = /*#__PURE__*/Object.freeze({
		&#39;default&#39;: urlParse,
		__moduleExports: urlParse
	});

	const URLParser = typeof _URLParser === &#39;function&#39; ? _URLParser : urlParse;

	const LCHPrimitiveURLCallback = function(inputData) {
		if (typeof inputData !== &#39;string&#39;) {
			// throw new Error(&#39;LCHErrorInputNotValid&#39;);
			return false;
		}

		if (!(new URLParser(inputData, {})).hostname) { // To parse an input independently of the browser&#39;s current URL (e.g. for functionality parity with the library in a Node environment), pass an empty location object as the second parameter
			return false;
		}

		return true;
	};

	const LCHPrimitiveStringCanonicalExampleCallback = function() {
		return &#39;https://example.com&#39;;
	};

	const LCHPrimitiveURLRecipe = function() {
		return {
			LCHRecipeSignature: &#39;URL&#39;,
			LCHRecipeCallback: LCHPrimitiveURLCallback,
			LCHRecipeOutputType: &#39;Bool&#39;,
			LCHRecipeCanonicalExampleCallback: LCHPrimitiveStringCanonicalExampleCallback,
		};
	};

	var URL = /*#__PURE__*/Object.freeze({
		LCHPrimitiveURLCallback: LCHPrimitiveURLCallback,
		LCHPrimitiveStringCanonicalExampleCallback: LCHPrimitiveStringCanonicalExampleCallback,
		LCHPrimitiveURLRecipe: LCHPrimitiveURLRecipe
	});

	const LCHPrimitiveServiceSearchURLTemplateCallback = function(inputData) {
		if (!LCHPrimitiveURLCallback(inputData)) {
			return false;
		}

		if (!inputData.match(/LCHSEARCHTOKEN/i)) {
			return false;
		}

		return true;
	};

	const LCHPrimitiveServiceSearchURLTemplateCanonicalExampleCallback = function() {
		return &#39;https://example.com?q=LCHSEARCHTOKEN&#39;;
	};

	const LCHPrimitiveServiceSearchURLTemplateRecipe = function() {
		return {
			LCHRecipeCallback: LCHPrimitiveServiceSearchURLTemplateCallback,
			LCHRecipeOutputType: &#39;Bool&#39;,
			LCHRecipeCanonicalExampleCallback: LCHPrimitiveServiceSearchURLTemplateCanonicalExampleCallback,
			LCHRecipeSignature: &#39;ServiceSearchURLTemplate&#39;,
			_LCHRecipeTypeIsExclusive: true,
		};
	};

	var ServiceSearchURLTemplate = /*#__PURE__*/Object.freeze({
		LCHPrimitiveServiceSearchURLTemplateCallback: LCHPrimitiveServiceSearchURLTemplateCallback,
		LCHPrimitiveServiceSearchURLTemplateCanonicalExampleCallback: LCHPrimitiveServiceSearchURLTemplateCanonicalExampleCallback,
		LCHPrimitiveServiceSearchURLTemplateRecipe: LCHPrimitiveServiceSearchURLTemplateRecipe
	});

	const LCHPrimitiveStringCallback = function(inputData) {
		return typeof inputData === &#39;string&#39;;
	};

	const LCHPrimitiveStringCanonicalExampleCallback$1 = function() {
		return &#39;&#39;;
	};

	const LCHPrimitiveStringRecipe = function() {
		return {
			LCHRecipeSignature: &#39;String&#39;,
			LCHRecipeCallback: LCHPrimitiveStringCallback,
			LCHRecipeOutputType: &#39;Bool&#39;,
			LCHRecipeCanonicalExampleCallback: LCHPrimitiveStringCanonicalExampleCallback$1,
		};
	};

	var String$1 = /*#__PURE__*/Object.freeze({
		LCHPrimitiveStringCallback: LCHPrimitiveStringCallback,
		LCHPrimitiveStringCanonicalExampleCallback: LCHPrimitiveStringCanonicalExampleCallback$1,
		LCHPrimitiveStringRecipe: LCHPrimitiveStringRecipe
	});

	const LCHTypeCommandCallback = function(inputData) {
		// if (LCHRecipesErrors(inputData)) {
		// 	throw new Error(&#39;LCHErrorInputNotValid&#39;);
		// }

		if (!inputData.LCHRecipeName) {
			return false;
		}
		
		if (inputData.LCHRecipeCallback.length) {
			return false;
		}

		return true;
	};

	const LCHTypeStringCanonicalExampleCallback = function() {
		return {
			LCHRecipeName: &#39;alfa&#39;,
			LCHRecipeCallback () {},
		};
	};

	const LCHTypeCommandRecipe = function() {
		return {
			LCHRecipeSignature: &#39;Command&#39;,
			LCHRecipeCallback: LCHTypeCommandCallback,
			LCHRecipeOutputType: &#39;Bool&#39;,
			LCHRecipeCanonicalExampleCallback: LCHTypeStringCanonicalExampleCallback,
		};
	};

	var Command = /*#__PURE__*/Object.freeze({
		LCHTypeCommandCallback: LCHTypeCommandCallback,
		LCHTypeStringCanonicalExampleCallback: LCHTypeStringCanonicalExampleCallback,
		LCHTypeCommandRecipe: LCHTypeCommandRecipe
	});

	const LCHTypeSubjectContainerCallback = function(inputData) {
		if (!inputData.LCHRecipeName) {
			return false;
		}
		
		if (inputData.LCHRecipeOutputType !== &#39;SubjectContainer&#39;) {
			return false;
		}

		return true;
	};

	const LCHTypeSubjectContainerCanonicalExampleCallback = function() {
		return {
			LCHRecipeName: &#39;alfa&#39;,
			LCHRecipeCallback () {},
			LCHRecipeOutputType: &#39;SubjectContainer&#39;,
		};
	};

	const LCHTypeSubjectContainerRecipe = function() {
		return {
			LCHRecipeSignature: &#39;SubjectContainer&#39;,
			LCHRecipeCallback: LCHTypeSubjectContainerCallback,
			LCHRecipeOutputType: &#39;Bool&#39;,
			LCHRecipeCanonicalExampleCallback: LCHTypeSubjectContainerCanonicalExampleCallback,
			_LCHRecipeTypeIsExclusive: true,
		};
	};

	var SubjectContainer = /*#__PURE__*/Object.freeze({
		LCHTypeSubjectContainerCallback: LCHTypeSubjectContainerCallback,
		LCHTypeSubjectContainerCanonicalExampleCallback: LCHTypeSubjectContainerCanonicalExampleCallback,
		LCHTypeSubjectContainerRecipe: LCHTypeSubjectContainerRecipe
	});

	const LCHDateLocalOffsetSubtractedCallback = function(inputData) {
		return new Date(Date.parse(inputData) - inputData.getTimezoneOffset() * 1000 * 60);
	};

	const LCHDateLocalOffsetSubtractedRecipe = function() {
		return {
			LCHRecipeSignature: &#39;LCHDateLocalOffsetSubtracted&#39;,
			LCHRecipeInputTypes: &#39;Date&#39;,
			LCHRecipeCallback: LCHDateLocalOffsetSubtractedCallback,
		};
	};

	var LCHDateLocalOffsetSubtracted = /*#__PURE__*/Object.freeze({
		LCHDateLocalOffsetSubtractedCallback: LCHDateLocalOffsetSubtractedCallback,
		LCHDateLocalOffsetSubtractedRecipe: LCHDateLocalOffsetSubtractedRecipe
	});

	const LCHReadTextFileCallback = async function(inputData = {}) {
		return new Promise(function (res, rej) {
			return Object.assign(document.createElement(&#39;input&#39;), inputData, {
				type: &#39;file&#39;,
				onchange (event) {
					return Object.assign(new FileReader(), {
						onload (event) {
							return res(event.target.result);
						},
					}).readAsText(event.target.files[0]);
				},
			}).click();
		});
	};

	const LCHReadTextFileRecipe = function() {
		return {
			LCHRecipeSignature: &#39;LCHReadTextFile&#39;,
			LCHRecipeCallback: LCHReadTextFileCallback,
		};
	};

	var LCHReadTextFile = /*#__PURE__*/Object.freeze({
		LCHReadTextFileCallback: LCHReadTextFileCallback,
		LCHReadTextFileRecipe: LCHReadTextFileRecipe
	});

	const LCHReadTextFileObjectsCallback = async function(inputData = {}) {
		return new Promise(function (res, rej) {
			return Object.assign(document.createElement(&#39;input&#39;), inputData, {
				type: &#39;file&#39;,
				onchange (event) {
					return res(Promise.all([...event.target.files].map(function (e) {
						return new Promise(function (res, rej) {
							return Object.assign(new FileReader(), {
								onload (event) {
									return res(Object.assign(e, {
										_LCHReadTextFileObjectContent: event.target.result,
									}));
								},
							}).readAsText(e);
						});
					})));
				},
			}).click();
		});
	};

	const LCHReadTextFileObjectsRecipe = function() {
		return {
			LCHRecipeSignature: &#39;LCHReadTextFileObjects&#39;,
			LCHRecipeCallback: LCHReadTextFileObjectsCallback,
		};
	};

	var LCHReadTextFileObjects = /*#__PURE__*/Object.freeze({
		LCHReadTextFileObjectsCallback: LCHReadTextFileObjectsCallback,
		LCHReadTextFileObjectsRecipe: LCHReadTextFileObjectsRecipe
	});

	var FileSaver_min = createCommonjsModule(function (module, exports) {
	(function(a,b){b();})(commonjsGlobal,function(){function b(a,b){return &#34;undefined&#34;==typeof b?b={autoBom:!1}:&#34;object&#34;!=typeof b&amp;&amp;(console.warn(&#34;Deprecated: Expected third argument to be a object&#34;),b={autoBom:!b}),b.autoBom&amp;&amp;/^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(a.type)?new Blob([&#34;\uFEFF&#34;,a],{type:a.type}):a}function c(a,b,c){var d=new XMLHttpRequest;d.open(&#34;GET&#34;,a),d.responseType=&#34;blob&#34;,d.onload=function(){g(d.response,b,c);},d.onerror=function(){console.error(&#34;could not download file&#34;);},d.send();}function d(a){var b=new XMLHttpRequest;b.open(&#34;HEAD&#34;,a,!1);try{b.send();}catch(a){}return 200&lt;=b.status&amp;&amp;299&gt;=b.status}function e(a){try{a.dispatchEvent(new MouseEvent(&#34;click&#34;));}catch(c){var b=document.createEvent(&#34;MouseEvents&#34;);b.initMouseEvent(&#34;click&#34;,!0,!0,window,0,0,0,80,20,!1,!1,!1,!1,0,null),a.dispatchEvent(b);}}var f=&#34;object&#34;==typeof window&amp;&amp;window.window===window?window:&#34;object&#34;==typeof self&amp;&amp;self.self===self?self:&#34;object&#34;==typeof commonjsGlobal&amp;&amp;commonjsGlobal.global===commonjsGlobal?commonjsGlobal:void 0,a=f.navigator&amp;&amp;/Macintosh/.test(navigator.userAgent)&amp;&amp;/AppleWebKit/.test(navigator.userAgent)&amp;&amp;!/Safari/.test(navigator.userAgent),g=f.saveAs||(&#34;object&#34;!=typeof window||window!==f?function(){}:&#34;download&#34;in HTMLAnchorElement.prototype&amp;&amp;!a?function(b,g,h){var i=f.URL||f.webkitURL,j=document.createElement(&#34;a&#34;);g=g||b.name||&#34;download&#34;,j.download=g,j.rel=&#34;noopener&#34;,&#34;string&#34;==typeof b?(j.href=b,j.origin===location.origin?e(j):d(j.href)?c(b,g,h):e(j,j.target=&#34;_blank&#34;)):(j.href=i.createObjectURL(b),setTimeout(function(){i.revokeObjectURL(j.href);},4E4),setTimeout(function(){e(j);},0));}:&#34;msSaveOrOpenBlob&#34;in navigator?function(f,g,h){if(g=g||f.name||&#34;download&#34;,&#34;string&#34;!=typeof f)navigator.msSaveOrOpenBlob(b(f,h),g);else if(d(f))c(f,g,h);else{var i=document.createElement(&#34;a&#34;);i.href=f,i.target=&#34;_blank&#34;,setTimeout(function(){e(i);});}}:function(b,d,e,g){if(g=g||open(&#34;&#34;,&#34;_blank&#34;),g&amp;&amp;(g.document.title=g.document.body.innerText=&#34;downloading...&#34;),&#34;string&#34;==typeof b)return c(b,d,e);var h=&#34;application/octet-stream&#34;===b.type,i=/constructor/i.test(f.HTMLElement)||f.safari,j=/CriOS\/[\d]+/.test(navigator.userAgent);if((j||h&amp;&amp;i||a)&amp;&amp;&#34;undefined&#34;!=typeof FileReader){var k=new FileReader;k.onloadend=function(){var a=k.result;a=j?a:a.replace(/^data:[^;]*;/,&#34;data:attachment/file;&#34;),g?g.location.href=a:location=a,g=null;},k.readAsDataURL(b);}else{var l=f.URL||f.webkitURL,m=l.createObjectURL(b);g?g.location=m:location.href=m,g=null,setTimeout(function(){l.revokeObjectURL(m);},4E4);}});f.saveAs=g.saveAs=g,(module.exports=g);});


	});

	const LCHSaveFileCallback = function(param1, param2) {
		if (typeof param1 !== &#39;string&#39;) {
			throw new Error(&#39;LCHErrorInputNotValid&#39;);
		}

		if (typeof param2 !== &#39;string&#39;) {
			throw new Error(&#39;LCHErrorInputNotValid&#39;);
		}

		if (!param2.trim()) {
			throw new Error(&#39;LCHErrorInputNotValid&#39;);
		}

		return FileSaver_min.saveAs(new Blob([param1], {type: &#39;text/plain;charset=utf-8&#39;}), param2);
	};

	const LCHSaveFileRecipe = function() {
		return {
			LCHRecipeSignature: &#39;LCHSaveFile&#39;,
			LCHRecipeCallback: LCHSaveFileCallback,
		};
	};

	var LCHSaveFile = /*#__PURE__*/Object.freeze({
		LCHSaveFileCallback: LCHSaveFileCallback,
		LCHSaveFileRecipe: LCHSaveFileRecipe
	});

	// https://stackoverflow.com/questions/1599660/which-html-elements-can-receive-focus
	const LCHFocusElementsSelector= [
		&#39;a[href]:not([tabindex=&#34;-1&#34;])&#39;,
	  // &#39;area[href]:not([tabindex=&#34;-1&#34;])&#39;,
	  &#39;input:not([disabled]):not([tabindex=&#34;-1&#34;]):not([type=&#34;hidden&#34;])&#39;,
	  // &#39;select:not([disabled]):not([tabindex=&#34;-1&#34;])&#39;,
	  // &#39;textarea:not([disabled]):not([tabindex=&#34;-1&#34;])&#39;,
	  &#39;button:not([disabled]):not([tabindex=&#34;-1&#34;])&#39;,
	  // &#39;iframe:not([tabindex=&#34;-1&#34;])&#39;,
	  // &#39;[tabindex]:not([tabindex=&#34;-1&#34;])&#39;,
	  // &#39;[contentEditable=true]:not([tabindex=&#34;-1&#34;])&#39;,
	].join(&#39;,&#39;);

	const LCHActiveDocumentsFocusElements = function(inputData) {
		if (typeof inputData !== &#39;object&#39; || inputData === null || typeof inputData.querySelectorAll !== &#39;function&#39;) {
			throw new Error(&#39;LCHErrorInputNotValid&#39;);
		}

		const aggregate = {
			ids: {},
		};

		return [].concat.apply([], inputData.querySelectorAll(LCHFocusElementsSelector)).filter(function (e) {
			return {
				&#39;A&#39;: function FocusElementAnchorFilter (e) {
					if (!e.href) {
						return false;
					}				
					if (!e.textContent.trim() &amp;&amp; !e.title.trim()) {
						return false;
					}				
					return true;
				},
				&#39;INPUT&#39;: function FocusElementInputFilter (e) {
					if (!aggregate.labels) {
						aggregate.labels = Array.from(inputData.querySelectorAll(&#39;label&#39;));
					}
					aggregate.ids[e.id] = aggregate.labels.filter(function (label) {
						return label.getAttribute(&#39;for&#39;) === e.id;
					}).map(function (e) {
						return e.textContent.trim();
					}).shift();

					if (!e.name.trim() &amp;&amp; !e.placeholder.trim() &amp;&amp; !aggregate.ids[e.id]) {
						return false;
					}
					return true;
				},
				&#39;BUTTON&#39;: function FocusElementButtonFilter (e) {
					if (!e.textContent.trim()) {
						return false;
					}
					return true;
				}
			}[e.tagName](e);
		}).map(function (e) {
			return {
				LCHRecipeName: {
					&#39;A&#39;: function FocusElementAnchorNameg (e) {
						return e.textContent.trim() || e.title.trim()
					},
					&#39;INPUT&#39;: function FocusElementInputNameg (e) {
						return aggregate.ids[e.id] || e.placeholder.trim() || e.name.trim();
					},
					&#39;BUTTON&#39;: function FocusElementButtonName (e) {
						return e.textContent.trim();
					},
				}[e.tagName](e),
				LCHRecipeCallback () {
					return e;
				},
				LCHRecipeOutputType: &#39;DOMElement&#39;,
			};
		});
	};

	const LCHActiveDocumentFocusElementsCallback = function() {
		return LCHActiveDocumentsFocusElements(document);
	};

	const LCHActiveDocumentFocusElementsRecipe = function() {
		return {
			LCHRecipeSignature: &#39;LCHActiveDocumentFocusElements&#39;,
			LCHRecipeOutputType: &#39;SubjectContainer&#39;,
			LCHRecipeCallback: LCHActiveDocumentFocusElementsCallback,
		};
	};

	var LCHActiveDocumentFocusElements = /*#__PURE__*/Object.freeze({
		LCHActiveDocumentsFocusElements: LCHActiveDocumentsFocusElements,
		LCHActiveDocumentFocusElementsCallback: LCHActiveDocumentFocusElementsCallback,
		LCHActiveDocumentFocusElementsRecipe: LCHActiveDocumentFocusElementsRecipe
	});

	const LCHCopyToClipboardCallback = function(inputData) {
		if (typeof inputData !== &#39;string&#39;) {
			throw new Error(&#39;LCHErrorInputNotValid&#39;);
		}

		if (!inputData.trim().length) {
			throw new Error(&#39;LCHErrorInputNotValid&#39;);
		}

		// if (typeof navigator !== &#39;undefined&#39; &amp;&amp; navigator.clipboard) {
		// 	return Promise.resolve((async function () {
		// 		return await navigator.clipboard.writeText(inputData);
		// 	})());
		// }

		// if (typeof document !== &#39;undefined&#39;) {
		// 	(function () {
		// 		const el = document.createElement(&#39;textarea&#39;);
				
		// 		el.value = inputData;
				
		// 		el.setAttribute(&#39;readonly&#39;, &#39;&#39;);
		// 		el.style.position = &#39;fixed&#39;;
		// 		el.style.top = 0;
				
		// 		document.body.appendChild(el);
		// 		el.select();
		// 		document.execCommand(&#39;copy&#39;);
				
		// 		el.remove();
		// 	})();
		// }

		return {
			LCHComponentDescriptorName: &#39;LCHCopyToClipboard&#39;,
			LCHComponentDescriptorProps: {
				inputData: inputData,
			},
			LCHComponentDescriptorCompletionHandlerSignature: &#39;LCHCopyToClipboardCompletionHandler&#39;,
			LCHComponentDescriptorOLSKLocalized: true,
		};
	};

	const LCHCopyToClipboardRecipe = function() {
		return {
			LCHRecipeSignature: &#39;LCHCopyToClipboard&#39;,
			LCHRecipeInputTypes: &#39;String&#39;,
			LCHRecipeCallback: LCHCopyToClipboardCallback,
		};
	};

	var LCHCopyToClipboard = /*#__PURE__*/Object.freeze({
		LCHCopyToClipboardCallback: LCHCopyToClipboardCallback,
		LCHCopyToClipboardRecipe: LCHCopyToClipboardRecipe
	});

	const LCHDOMElementFocusCallback = function(inputData) {
		if (!inputData) {
			return;
		}

		inputData.focus();
	};

	const LCHDOMElementFocusRecipe = function() {
		return {
			LCHRecipeSignature: &#39;LCHDOMElementFocus&#39;,
			LCHRecipeInputTypes: &#39;DOMElement&#39;,
			LCHRecipeCallback: LCHDOMElementFocusCallback,
		};
	};

	var LCHDOMElementFocus = /*#__PURE__*/Object.freeze({
		LCHDOMElementFocusCallback: LCHDOMElementFocusCallback,
		LCHDOMElementFocusRecipe: LCHDOMElementFocusRecipe
	});

	const LCHLargeTextCallback = function(inputData) {
		if (typeof document === &#39;undefined&#39;) {
			return;
		}

		const rootElement = document.createElement(&#39;div&#39;);
		rootElement.className = &#39;LCHLargeTextContainer&#39;;

		for (let [key, value] of Object.entries({
			width: &#39;100%&#39;,

			position: &#39;fixed&#39;,
			top: &#39;45%&#39;,
			left: &#39;0&#39;,

			textAlign: &#39;center&#39;,

			cursor: &#39;default&#39;,
		})) {
			rootElement.style[key] = value;
		}

		const span = document.createElement(&#39;span&#39;);
		span.textContent = inputData;
		rootElement.appendChild(span);

		for (let [key, value] of Object.entries({
			display: &#39;block-inline&#39;,
			borderRadius: &#39;20px&#39;,
			boxShadow: &#39;0 0 10px 0px hsla(0, 0%, 0%, 0.1)&#39;,
			padding: &#39;20px&#39;,

			background: &#39;hsla(0, 0%, 0%, 0.8)&#39;,
			color: &#39;white&#39;,
			fontFamily: &#39;Arial&#39;,
			fontSize: &#39;72pt&#39;,
			fontWeight: &#39;bold&#39;,
			textAlign: &#39;center&#39;,
			textShadow: &#39;5px 5px 10px hsla(0, 0%, 0%, 0.5)&#39;,
			overflowWrap: &#39;break-word&#39;,
		})) {
			span.style[key] = value;
		}
		
		document.body.appendChild(rootElement);

		let handler = function (event) {
			event.preventDefault();

			if (!event.key &amp;&amp; rootElement.contains(event.target)) {
		  	return;
			}
			
			window.removeEventListener(&#39;click&#39;, handler);
			window.removeEventListener(&#39;keydown&#39;, handler);
			
			rootElement.remove();
		};

		setTimeout(function () {
			window.addEventListener(&#39;click&#39;, handler);
			window.addEventListener(&#39;keydown&#39;, handler);
		});
	};

	const LCHLargeTextRecipe = function() {
		return {
			LCHRecipeSignature: &#39;LCHLargeText&#39;,
			LCHRecipeInputTypes: &#39;String&#39;,
			LCHRecipeCallback: LCHLargeTextCallback,
		};
	};

	var LCHLargeText = /*#__PURE__*/Object.freeze({
		LCHLargeTextCallback: LCHLargeTextCallback,
		LCHLargeTextRecipe: LCHLargeTextRecipe
	});

	const LCHRunCommandCallback = function(inputData) {
		return inputData;
	};

	const LCHRunCommandRecipe = function() {
		return {
			LCHRecipeSignature: &#39;LCHRunCommand&#39;,
			LCHRecipeInputTypes: &#39;Command&#39;,
			LCHRecipeCallback: LCHRunCommandCallback,
		};
	};

	var LCHRunCommand = /*#__PURE__*/Object.freeze({
		LCHRunCommandCallback: LCHRunCommandCallback,
		LCHRunCommandRecipe: LCHRunCommandRecipe
	});

	const LCHFlip = function(param1, param2) {
		if (typeof param1 !== &#39;function&#39;) {
			throw new Error(&#39;LCHErrorInputNotValid&#39;);
		}

		return function() {
			return param1.apply(param2, [...arguments].reverse());
		};
	};

	const LCHSearchActionURLFrom = function(param1, param2) {
		if (typeof param1 !== &#39;string&#39;) {
			throw new Error(&#39;LCHErrorInputNotValid&#39;);
		}

		if (typeof param2 !== &#39;string&#39;) {
			throw new Error(&#39;LCHErrorInputNotValid&#39;);
		}

		if (!param1.match(/LCHSEARCHTOKEN/i)) {
			return param1;
		}

		return param1.replace(/LCHSEARCHTOKEN/i, param2.split(&#39; &#39;).map(function (e) {
			return encodeURIComponent(e);
		}).join(&#39;+&#39;));
	};

	const LCHSearchWithCallback = function(param1, param2) {
		return this.api.fn(&#39;LCHURLOpen&#39;)(LCHSearchActionURLFrom(param2, param1));
	};

	const LCHSearchWithRecipe = function() {
		return {
			LCHRecipeSignature: &#39;LCHSearchWith&#39;,
			LCHRecipeInputTypes: &#39;String,ServiceSearchURLTemplate&#39;,
			LCHRecipeCallback: LCHSearchWithCallback,
		};
	};
	const LCHSearchForCallback = function() {
		return LCHFlip(LCHSearchWithCallback, this)(...arguments);
	};

	const LCHSearchForRecipe = function() {
		return {
			LCHRecipeSignature: &#39;LCHSearchFor&#39;,
			LCHRecipeInputTypes: &#39;ServiceSearchURLTemplate,String&#39;,
			LCHRecipeCallback: LCHSearchForCallback,
		};
	};

	var LCHSearchAction = /*#__PURE__*/Object.freeze({
		LCHSearchActionURLFrom: LCHSearchActionURLFrom,
		LCHSearchWithCallback: LCHSearchWithCallback,
		LCHSearchWithRecipe: LCHSearchWithRecipe,
		LCHSearchForCallback: LCHSearchForCallback,
		LCHSearchForRecipe: LCHSearchForRecipe
	});

	const LCHServiceSearchWikipediaCallback = function() {
		return &#39;https://wikipedia.org/w/index.php?search=LCHSEARCHTOKEN&#39;;
	};

	const LCHServiceSearchWikipediaRecipe = function() {
		return {
			LCHRecipeName: &#39;Wikipedia&#39;,
			LCHRecipeOutputType: &#39;ServiceSearchURLTemplate&#39;,
			LCHRecipeCallback: LCHServiceSearchWikipediaCallback,
			LCHRecipeSignature: &#39;LCHServiceSearchWikipedia&#39;,
		};
	};

	var LCHServiceSearchWikipedia = /*#__PURE__*/Object.freeze({
		LCHServiceSearchWikipediaCallback: LCHServiceSearchWikipediaCallback,
		LCHServiceSearchWikipediaRecipe: LCHServiceSearchWikipediaRecipe
	});

	const LCHSubjectContainerShowContentsCallback = function(inputData) {
		return inputData;
	};

	const LCHSubjectContainerShowContentsRecipe = function() {
		return {
			LCHRecipeSignature: &#39;LCHSubjectContainerShowContents&#39;,
			LCHRecipeInputTypes: &#39;SubjectContainer&#39;,
			LCHRecipeCallback: LCHSubjectContainerShowContentsCallback,
		};
	};

	var LCHSubjectContainerShowContents = /*#__PURE__*/Object.freeze({
		LCHSubjectContainerShowContentsCallback: LCHSubjectContainerShowContentsCallback,
		LCHSubjectContainerShowContentsRecipe: LCHSubjectContainerShowContentsRecipe
	});

	const LCHURLOpenCallback = function(inputData) {
		if (!inputData) {
			return;
		}

		window.open(inputData, &#39;_blank&#39;).focus();
	};

	const LCHURLOpenRecipe = function() {
		return {
			LCHRecipeSignature: &#39;LCHURLOpen&#39;,
			LCHRecipeInputTypes: &#39;URL&#39;,
			LCHRecipeCallback: LCHURLOpenCallback,
		};
	};

	var LCHURLOpen = /*#__PURE__*/Object.freeze({
		LCHURLOpenCallback: LCHURLOpenCallback,
		LCHURLOpenRecipe: LCHURLOpenRecipe
	});

	const LCHLauncherStandardRecipes = function() {
		return [].concat.apply([], [
			Bool,
			Date$1,
			DOMElement,
			ServiceSearchURLTemplate,
			String$1,
			URL,
			
			Command,
			ServiceSearch,
			SubjectContainer,
			
			LCHActiveDocumentFocusElements,

			LCHDateLocalOffsetSubtracted,
			LCHReadTextFile,
			LCHReadTextFileObjects,
			LCHSaveFile,

			LCHCopyToClipboard,
			LCHDOMElementFocus,
			LCHLargeText,
			LCHRunCommand,
			LCHSearchAction,
			LCHServiceSearchWikipedia,
			LCHSubjectContainerShowContents,
			LCHURLOpen,
		].map(function (e) {
			return Object.entries(e).filter(function (e) {
				return e.shift().includes(&#39;Recipe&#39;);
			}).map(function (e) {
				return e.pop()();
			}).map(function (e) {
				return e;
			});
		}));
	};

	Array.prototype._LCHIntersect = function() {
		return this.map(function (e) {
			return new Set(e);
		}).reduce(function (a, b) {
			return a.filter(i =&gt; b.has(i));
		}, [...new Set([].concat.apply([], this))]);
	};

	const mod$2 = {

		LCHRecipesErrors (inputData, options = {}) {
			if (typeof inputData !== &#39;object&#39; || inputData === null) {
				throw new Error(&#39;LCHErrorInputNotValid&#39;);
			}

			const errors = mod.LCHFormulaTo(mod.LCHFormulaErrors(mod.LCHFormulaFrom(inputData)) || {}, &#39;LCHRecipe&#39;);

			if (typeof inputData.LCHRecipeCallback !== &#39;function&#39;) {
				errors.LCHRecipeCallback = [
					&#39;LCHErrorNotFunction&#39;,
				];
			}

			if (typeof inputData.LCHRecipeName === &#39;string&#39;) {
				if (!inputData.LCHRecipeName.trim()) {
					errors.LCHRecipeName = [
						&#39;LCHErrorNotFilled&#39;,
					];
				}
			}

			if (typeof inputData.LCHRecipeInputTypes === &#39;string&#39;) {
				if (inputData.LCHRecipeInputTypes.trim() !== inputData.LCHRecipeInputTypes) {
					errors.LCHRecipeInputTypes = [
						&#39;LCHErrorNotTrimmed&#39;,
					];
				}

				if (!inputData.LCHRecipeInputTypes.trim()) {
					errors.LCHRecipeInputTypes = [
						&#39;LCHErrorNotFilled&#39;,
					];
				}
			}

			if (typeof inputData.LCHRecipeOutputType === &#39;string&#39;) {
				if (inputData.LCHRecipeOutputType.trim() !== inputData.LCHRecipeOutputType) {
					errors.LCHRecipeOutputType = [
						&#39;LCHErrorNotTrimmed&#39;,
					];
				}

				if (!inputData.LCHRecipeOutputType.trim()) {
					errors.LCHRecipeOutputType = [
						&#39;LCHErrorNotFilled&#39;,
					];
				}
			}

			if (inputData.LCHRecipeCanonicalExampleCallback !== undefined || options.LCHOptionValidateIfNotPresent) {
				if (typeof inputData.LCHRecipeCanonicalExampleCallback !== &#39;function&#39;) {
					errors.LCHRecipeCanonicalExampleCallback = [
						&#39;LCHErrorNotFunction&#39;,
					];
				}
			}

			if (typeof inputData.LCHRecipeSignature === &#39;string&#39;) {
				if (!inputData.LCHRecipeSignature.trim()) {
					errors.LCHRecipeSignature = [
						&#39;LCHErrorNotFilled&#39;,
					];
				} else if (inputData.LCHRecipeSignature.trim() !== inputData.LCHRecipeSignature) {
					errors.LCHRecipeSignature = [
						&#39;LCHErrorNotTrimmed&#39;,
					];
				}
			}

			return Object.entries(errors).length ? errors : null;
		},

		LCHRecipesIsCommand (inputData) {
			if (mod$2.LCHRecipesErrors(inputData)) {
				throw new Error(&#39;LCHErrorInputNotValid&#39;);
			}

			if (!inputData.LCHRecipeName) {
				return false;
			}
			
			if (inputData.LCHRecipeInputTypes) {
				return false;
			}

			if (inputData.LCHRecipeOutputType) {
				return false;
			}

			return true;
		},

		LCHRecipesIsSubject (inputData) {
			if (mod$2.LCHRecipesErrors(inputData)) {
				throw new Error(&#39;LCHErrorInputNotValid&#39;);
			}

			if (!inputData.LCHRecipeName) {
				return false;
			}
			
			// if (inputData.LCHRecipeInputTypes) {
			// 	return false;
			// }

			if (!inputData.LCHRecipeOutputType) {
				return false;
			}

			return true;
		},

		LCHRecipesIsAction (inputData) {
			if (mod$2.LCHRecipesErrors(inputData)) {
				throw new Error(&#39;LCHErrorInputNotValid&#39;);
			}

			if (!inputData.LCHRecipeName) {
				return false;
			}

			if (!inputData.LCHRecipeInputTypes) {
				return false;
			}
			
			// if (!inputData.LCHRecipeCallback.length) {
			// 	return false;
			// }

			return true;
		},

		LCHRecipesIsType (inputData) {
			if (mod$2.LCHRecipesErrors(inputData)) {
				throw new Error(&#39;LCHErrorInputNotValid&#39;);
			}
			
			// if (inputData.LCHRecipeCallback.length !== 1) {
			// 	return false;
			// }

			if (inputData.LCHRecipeOutputType !== &#39;Bool&#39;) {
				return false;
			}

			if (!inputData.LCHRecipeCanonicalExampleCallback) {
				return false;
			}

			if (!inputData.LCHRecipeSignature) {
				return false;
			}

			return true;
		},

		LCHRecipesIsTask (inputData) {
			if (mod$2.LCHRecipesErrors(inputData)) {
				throw new Error(&#39;LCHErrorInputNotValid&#39;);
			}
			
			// if (inputData.LCHRecipeCallback.length) {
			// 	return false;
			// }

			if (!inputData.LCHRecipeURLFilter) {
				return false;
			}

			if (inputData.LCHRecipeIsAutomatic !== true) {
				return false;
			}

			return true;
		},

		LCHLauncherConvertTypeServiceSearch (inputData, _stringCallback) {
			if (!Array.isArray(inputData)) {
				throw new Error(&#39;LCHErrorInputNotValid&#39;);
			}

			return inputData.filter(function (e) {
				if (typeof e !== &#39;object&#39; || e === null) {
					return false;
				}
				
				return true;
			}).map(function (e) {
				if (!LCHTypeServiceSearchRecipe().LCHRecipeCallback(e)) {
					return e;
				}

				return {
					LCHRecipeName: _stringCallback(e.LCHRecipeName),
					LCHRecipeInputTypes: &#39;String&#39;,
					LCHRecipeCallback (inputData) {
						return this.api.fn(&#39;LCHSearchWith&#39;)(inputData, e);
					},
					_LCHLauncherGenerated: true,
				};
			});
		},

		LCHRecipesActionTakesObject (inputData) {
			if (mod$2.LCHRecipesErrors(inputData)) {
				throw new Error(&#39;LCHErrorInputNotValid&#39;);
			}

			if (!mod$2.LCHRecipesIsAction(inputData)) {
				throw new Error(&#39;LCHErrorInputNotValid&#39;);
			}
			
			if (mod$1.LCHRuntimeInputTypes(inputData.LCHRecipeInputTypes).length &lt; 2) {
				return false;
			}
			
			// if (inputData.LCHRecipeCallback.length &lt; 2) {
			// 	return false;
			// }

			return true;
		},

		LCHRecipesActionTakesParams (inputData) {
			if (mod$2.LCHRecipesErrors(inputData)) {
				throw new Error(&#39;LCHErrorInputNotValid&#39;);
			}

			if (!mod$2.LCHRecipesIsAction(inputData)) {
				throw new Error(&#39;LCHErrorInputNotValid&#39;);
			}
			
			if (mod$1.LCHRuntimeInputTypes(inputData.LCHRecipeInputTypes).pop() !== &#39;Object&#39;) {
				return false;
			}
			
			// if (inputData.LCHRecipeCallback.length !== LCHRuntime.LCHRuntimeInputTypes(inputData.LCHRecipeInputTypes).length) {
			// 	return false;
			// }

			return true;
		},

		LCHAPITypeEquivalenceMapForRecipes (inputData) {
			if (!Array.isArray(inputData)) {
				throw new Error(&#39;LCHErrorInputNotValid&#39;);
			}

			const uniqueSignatures = [];
			const validRecipes = inputData.filter(function (e) {
				if (mod$2.LCHRecipesErrors(e)) {
					return false;
				}

				if (!mod$2.LCHRecipesIsType(e)) {
					return false;
				}

				if (!e.LCHRecipeCallback(e.LCHRecipeCanonicalExampleCallback())) {
					return false;
				}

				if (uniqueSignatures.includes(e.LCHRecipeSignature)) {
					return false;
				}

				uniqueSignatures.push(e.LCHRecipeSignature);

				return true;
			});

			return validRecipes.reduce(function (coll, item) {
				coll[item.LCHRecipeSignature] = validRecipes.filter(function (e) {
					if (item === e) {
						return true;
					}

					if (e._LCHRecipeTypeIsExclusive) {
						return false;
					}

					if (item._LCHRecipeTypeIsExclusive) {
						return false;
					}

					return e.LCHRecipeCallback(item.LCHRecipeCanonicalExampleCallback());
				}).map(function (e) {
					return e.LCHRecipeSignature;
				});

				return coll;
			}, {});
		},

		LCHAPITypeNameMap (inputData) {
			if (!Array.isArray(inputData)) {
				throw new Error(&#39;LCHErrorInputNotValid&#39;);
			}

			const validRecipes = inputData.filter(function (e) {
				if (mod$2.LCHRecipesErrors(e)) {
					return false;
				}

				return mod$2.LCHRecipesIsType(e);
			});

			return validRecipes.reduce(function (coll, item) {
				if (coll[item.LCHRecipeSignature]) {
					return coll;
				}

				coll[item.LCHRecipeSignature] = item.LCHRecipeName || item.LCHRecipeSignature;

				return coll;
			}, {});
		},

		LCHAPIActionsForType (param1, param2) {
			if (typeof param1 !== &#39;string&#39;) {
				throw new Error(&#39;LCHErrorInputNotValid&#39;);
			}

			if (!Array.isArray(param2)) {
				throw new Error(&#39;LCHErrorInputNotValid&#39;);
			}

			return param2.filter(function (e) {
				if (mod$2.LCHRecipesErrors(e)) {
					return false;
				}

				if (!mod$2.LCHRecipesIsAction(e)) {
					return false;
				}

				if (mod$1.LCHRuntimeInputTypes(e.LCHRecipeInputTypes).shift() !== param1) {
					return false;
				}

				return true;
			});
		},

		LCHAPISubjectsForType (param1, param2) {
			if (typeof param1 !== &#39;string&#39;) {
				throw new Error(&#39;LCHErrorInputNotValid&#39;);
			}

			if (!Array.isArray(param2)) {
				throw new Error(&#39;LCHErrorInputNotValid&#39;);
			}

			return param2.filter(function (e) {
				if (mod$2.LCHRecipesErrors(e)) {
					return false;
				}

				if (!mod$2.LCHRecipesIsSubject(e)) {
					return false;
				}

				if (e.LCHRecipeOutputType !== param1) {
					return false;
				}

				return true;
			});
		},

		LCHCompositionErrors (inputData) {
			if (typeof inputData !== &#39;object&#39; || inputData === null) {
				throw new Error(&#39;LCHErrorInputNotValid&#39;);
			}

			if (!inputData.LCHCompositionAction) {
				return {
					LCHCompositionAction: [
						&#39;LCHErrorInputNotPresent&#39;,
					],
				};
			}

			if (!mod$2.LCHRecipesIsAction(inputData.LCHCompositionAction)) {
				return {
					LCHCompositionAction: [
						&#39;LCHErrorInputNotValid&#39;,
					],
				};
			}

			const errors = {};

			if (!inputData.LCHCompositionSubjectPrimary) {
				return {
					LCHCompositionSubjectPrimary: [
						&#39;LCHErrorInputNotPresent&#39;,
					],
				};
			} else if (inputData.LCHCompositionAction.LCHRecipeInputTypes === &#39;Command&#39; &amp;&amp; mod$2.LCHRecipesIsCommand(inputData.LCHCompositionSubjectPrimary)) ;

			// if (!mod.LCHRecipesIsSubject(inputData.LCHCompositionSubjectPrimary)) {
			// 	errors.LCHCompositionSubjectPrimary = [
			// 		&#39;LCHErrorInputNotValid&#39;,
			// 	];
			// }

			else if (inputData.LCHCompositionAction.LCHRecipeInputTypes &amp;&amp; !mod$1.LCHRuntimeInputTypes(inputData.LCHCompositionAction.LCHRecipeInputTypes).includes(inputData.LCHCompositionSubjectPrimary.LCHRecipeOutputType)) {
				errors.LCHCompositionSubjectPrimary = [
					&#39;LCHErrorInputNotValid&#39;,
				];
			}

			if (inputData.LCHCompositionAction.LCHRecipeInputTypes &amp;&amp; mod$1.LCHRuntimeInputTypes(inputData.LCHCompositionAction.LCHRecipeInputTypes).length === 2 &amp;&amp; !inputData.LCHCompositionSubjectSecondary) {
				errors.LCHCompositionSubjectSecondary = [
					&#39;LCHErrorInputNotValid&#39;,
				];
			}

			if (inputData.LCHCompositionSubjectSecondary !== undefined) {
				if (!mod$2.LCHRecipesIsSubject(inputData.LCHCompositionSubjectSecondary)) {
					errors.LCHCompositionSubjectSecondary = [
						&#39;LCHErrorInputNotValid&#39;,
					];
				}

				if (inputData.LCHCompositionAction.LCHRecipeInputTypes &amp;&amp; !mod$1.LCHRuntimeInputTypes(inputData.LCHCompositionAction.LCHRecipeInputTypes).includes(inputData.LCHCompositionSubjectSecondary.LCHRecipeOutputType)) {
					errors.LCHCompositionSubjectSecondary = [
						&#39;LCHErrorInputNotValid&#39;,
					];
				}
			}

			return Object.entries(errors).length ? errors : null;
		},

		async LCHAPIExecuteComposition (inputData, api = {}) {
			if (mod$2.LCHCompositionErrors(inputData)) {
				throw new Error(&#39;LCHErrorInputNotValid&#39;);
			}

			if (typeof api.fn !== &#39;function&#39;) {
				throw new Error(&#39;LCHErrorInputNotValid&#39;);
			}

			return mod$2.LCHAPIExecuteRecipe(inputData.LCHCompositionAction, [
				await mod$2.LCHAPIExecuteRecipe(inputData.LCHCompositionSubjectPrimary, [], api),
			].concat(inputData.LCHCompositionSubjectSecondary ? [
				await mod$2.LCHAPIExecuteRecipe(inputData.LCHCompositionSubjectSecondary, [], api),
			] : []), api);
		},

		async LCHAPIExecuteRecipe (param1, param2 = [], param3 = {}) {
			if (mod$2.LCHRecipesErrors(param1)) {
				throw new Error(&#39;LCHErrorInputNotValid&#39;);
			}

			if (!Array.isArray(param2)) {
				throw new Error(&#39;LCHErrorInputNotValid&#39;);
			}

			if (typeof param3.fn !== &#39;function&#39;) {
				throw new Error(&#39;LCHErrorInputNotValid&#39;);
			}

			if (param1.LCHRecipeStyle &amp;&amp; typeof document !== &#39;undefined&#39;) {
				document.body.appendChild(document.createElement(&#39;style&#39;)).innerHTML = param1.LCHRecipeStyle;
			}

			return Promise.resolve(param1.LCHRecipeCallback.apply({
				api: param3,
			}, param2.length ? param2 : undefined)); // #mysterious Firefox throws `Permission denied to access property &#34;length&#34;` if array is empty
		},

		LCHComponentDescriptorsErrors (inputData) {
			if (typeof inputData !== &#39;object&#39; || inputData === null) {
				throw new Error(&#39;LCHErrorInputNotValid&#39;);
			}

			const errors = {};

			if (typeof inputData.LCHComponentDescriptorName !== &#39;string&#39;) {
				errors.LCHComponentDescriptorName = [
					&#39;LCHErrorNotString&#39;,
				];
			}

			if (typeof inputData.LCHComponentDescriptorName === &#39;string&#39; &amp;&amp; !inputData.LCHComponentDescriptorName) {
				errors.LCHComponentDescriptorName = [
					&#39;LCHErrorNotFilled&#39;,
				];
			}

			if (typeof inputData.LCHComponentDescriptorName === &#39;string&#39; &amp;&amp; inputData.LCHComponentDescriptorName.trim() !== inputData.LCHComponentDescriptorName) {
				errors.LCHComponentDescriptorName = [
					&#39;LCHErrorNotTrimmed&#39;,
				];
			}

			if (typeof inputData.LCHComponentDescriptorCompletionHandlerSignature !== &#39;string&#39;) {
				errors.LCHComponentDescriptorCompletionHandlerSignature = [
					&#39;LCHErrorNotString&#39;,
				];
			}

			if (typeof inputData.LCHComponentDescriptorCompletionHandlerSignature === &#39;string&#39; &amp;&amp; !inputData.LCHComponentDescriptorCompletionHandlerSignature) {
				errors.LCHComponentDescriptorCompletionHandlerSignature = [
					&#39;LCHErrorNotFilled&#39;,
				];
			}

			if (typeof inputData.LCHComponentDescriptorCompletionHandlerSignature === &#39;string&#39; &amp;&amp; inputData.LCHComponentDescriptorCompletionHandlerSignature.trim() !== inputData.LCHComponentDescriptorCompletionHandlerSignature) {
				errors.LCHComponentDescriptorCompletionHandlerSignature = [
					&#39;LCHErrorNotTrimmed&#39;,
				];
			}

			if (inputData.LCHComponentDescriptorProps !== undefined) {
				if (typeof inputData.LCHComponentDescriptorProps !== &#39;object&#39; || inputData.LCHComponentDescriptorProps === null) {
					errors.LCHComponentDescriptorProps = [
						&#39;LCHErrorNotObject&#39;,
					];
				}
			}

			return Object.entries(errors).length ? errors : null;
		},

		LCHRuntimeFilteredRecipes  (param1, param2) {
			if (!Array.isArray(param1)) {
				throw new Error(&#39;LCHErrorInputNotValid&#39;);
			}

			if (typeof param2 !== &#39;string&#39;) {
				throw new Error(&#39;LCHErrorInputNotValid&#39;);
			}

			return param1.filter(function (e) {
				if (mod$2.LCHRecipesErrors(e)) {
					return false;
				}

				if (typeof e.LCHRecipeURLFilter === &#39;undefined&#39;) {
					return true;
				}

				return mod$1.LCHRuntimeURLFilter(e.LCHRecipeURLFilter, param2);
			});
		},

		LCHRuntimeFilteredTasks  (inputData) {
			if (!Array.isArray(inputData)) {
				throw new Error(&#39;LCHErrorInputNotValid&#39;);
			}

			return inputData.filter(function (e) {
				if (!mod$2.LCHRecipesIsTask(e)) {
					return false;
				}

				if (e.LCHRecipeIsExcluded) {
					return !e.LCHRecipeIsExcluded();
				}

				return true;
			});
		},

		LCHAPIRunTasks  () {
			const inputData = mod$2.LCHRuntimeFilteredRecipes.apply(null, [...arguments]);
			const api = mod$1.LCHRuntimeAPI(LCHLauncherStandardRecipes().concat(inputData));

			return Promise.all(mod$2.LCHRuntimeFilteredTasks(inputData).map(function (e) {
				return mod$2.LCHAPIExecuteRecipe(e, [], api);
			}));
		},

		LCHRecipeProxyErrors (inputData, options = {}) {
			if (typeof inputData !== &#39;object&#39; || inputData === null) {
				return {};
			}

			const errors = {};

			if (typeof inputData.LCHRecipeProxyName !== &#39;string&#39;) {
				errors.LCHRecipeProxyName = [
					&#39;LCHErrorNotString&#39;,
				];
			}

			if (typeof inputData.LCHRecipeProxySignature !== &#39;string&#39;) {
				errors.LCHRecipeProxySignature = [
					&#39;LCHErrorNotString&#39;,
				];
			}

			return Object.entries(errors).length ? errors : null;
		},

	};

	const mod$3 = {

		LCHLauncherOptions (inputData, notify = function () {}) {
			if (typeof inputData !== &#39;object&#39; || inputData === null) {
				throw new Error(&#39;LCHErrorInputNotValid&#39;);
			}

			if (typeof inputData.LCHOptionRecipes === &#39;undefined&#39;) {
				inputData.LCHOptionRecipes = [];
			}
			if (!Array.isArray(inputData.LCHOptionRecipes)) {
				throw new Error(&#39;LCHOptionRecipesNotArray&#39;);
			}
			inputData.LCHOptionRecipes = inputData.LCHOptionRecipes.filter(function (e) {
				const errors = mod$2.LCHRecipesErrors(e);

				if (errors) {
					notify(&#39;LCHOptionRecipesItemNotValid&#39;, e, errors);
				}
				return !errors;
			});

			if (typeof inputData.LCHOptionMode === &#39;undefined&#39;) {
				inputData.LCHOptionMode = mod$3.LCHLauncherModes().shift();
			}
			if (typeof inputData.LCHOptionMode !== &#39;undefined&#39;) {
				if (!mod$3.LCHLauncherModes().includes(inputData.LCHOptionMode)) {
					throw new Error(&#39;LCHOptionModeNotValid&#39;);
				}		}
			if (typeof inputData.LCHOptionCompletionHandler !== &#39;undefined&#39;) {
				if (typeof inputData.LCHOptionCompletionHandler !== &#39;function&#39;) {
					throw new Error(&#39;LCHOptionCompletionHandlerNotFunction&#39;);
				}		}
			if (typeof inputData.LCHOptionLanguage === &#39;undefined&#39;) {
				inputData.LCHOptionLanguage = &#39;en&#39;;
			}
			if (typeof inputData.LCHOptionLanguage !== &#39;string&#39;) {
				throw new Error(&#39;LCHOptionLanguageNotString&#39;)
			}
			return inputData;
		},

		LCHLauncherModeCommit () {
			return &#39;kLCHLauncherModeCommit&#39;;
		},

		LCHLauncherModePreview () {
			return &#39;kLCHLauncherModePreview&#39;;
		},

		LCHLauncherModePipe () {
			return &#39;kLCHLauncherModePipe&#39;;
		},

		LCHLauncherModeTask () {
			return &#39;kLCHLauncherModeTask&#39;;
		},

		LCHLauncherModes () {
			return [
				mod$3.LCHLauncherModeCommit(),
				mod$3.LCHLauncherModePreview(),
				mod$3.LCHLauncherModePipe(),
				mod$3.LCHLauncherModeTask(),
			];
		},

		LCHLauncherUIRecipesForMode (param1, param2) {
			if (!Array.isArray(param1)) {
				throw new Error(&#39;LCHErrorInputNotValid&#39;);
			}

			if (!mod$3.LCHLauncherModes().includes(param2)) {
				throw new Error(&#39;LCHErrorInputNotValid&#39;);
			}

			return param1.filter(function (e) {
				if (typeof e !== &#39;object&#39; || e === null) {
					return false;
				}

				if (typeof e.LCHRecipeInputTypes === &#39;string&#39; &amp;&amp; e.LCHRecipeInputTypes.split(&#39;,&#39;).length &gt; 2) {
					return false;
				}

				if (param2 === mod$3.LCHLauncherModeCommit()) {
					return mod$2.LCHRecipesIsCommand(e);
					// if (LCHLauncherAPI.LCHRecipesIsCommand(e)) {
					// 	return true;
					// };

					// if (!LCHLauncherAPI.LCHRecipesIsAction(e)) {
					// 	return false;
					// };

					// if (e.LCHRecipeCallback.length !== 1) {
					// 	return false;
					// };

					// if (e.LCHRecipeInputTypes !== &#39;String&#39;) {
					// 	return false;
					// };

					// if (e._LCHLauncherGenerated !== true) {
					// 	return false;
					// };
				}

				if (param2 === mod$3.LCHLauncherModePreview()) {
					return mod$2.LCHRecipesIsCommand(e);
				}
				
				return true;
			});
		},

		// import * as _fuzzysearch from &#39;fuzzysearch&#39;;
		// const fuzzysearch = typeof _fuzzysearch === &#39;function&#39; ? _fuzzysearch : _fuzzysearch.default;
		// LCHLauncherFilterForText (inputData) {
		// 	if (typeof inputData !== &#39;string&#39;) {
		// 		throw new Error(&#39;LCHErrorInputNotValid&#39;);
		// 	}

		// 	return function (e) {
		// 		return [e.LCHRecipeName].filter(function (e) {
		// 			if (!e) {
		// 				return false;
		// 			}

		// 			return fuzzysearch(inputData.toLowerCase(), e.toLowerCase());
		// 		}).length &gt; 0;
		// 	};
		// };

		LCHLauncherThrottleDuration: main_1() ? 25 : 1000,

		LCHLauncherKeyboardEventIsTextInput (inputData) {
			if (typeof inputData !== &#39;object&#39; || inputData === null) {
				throw new Error(&#39;LCHErrorInputNotValid&#39;);
			}

			if ([
				inputData.metaKey,
				inputData.shiftKey,
				inputData.ctrlKey,
				inputData.altKey,
			].includes(true)) {
				return false;
			}

			if (!inputData.key) {
				return false;
			}
			
			if ([
				&#39;Unidentified&#39;,
				&#39;Tab&#39;,
				&#39;CapsLock&#39;,
				&#39;ArrowRight&#39;,
				&#39;ArrowLeft&#39;,
				&#39;Backspace&#39;,
				&#39;\\&#39;,
				&#39;.&#39;,
				&#39;,&#39;,
				&#39; &#39;,
			].includes(inputData.key)) {
				return false;
			}
			
			return true;
		},

		LCHLauncherActionComparator (inputData) {
			if (typeof inputData !== &#39;string&#39;) {
				throw new Error(&#39;LCHErrorInputNotValid&#39;);
			}

			return function (a, b) {
				const param1s = [
					a.LCHRecipeInputTypes.split(&#39;,&#39;)[0],
					b.LCHRecipeInputTypes.split(&#39;,&#39;)[0],
				];
				const param2s = [
					a.LCHRecipeInputTypes.split(&#39;,&#39;)[1],
					b.LCHRecipeInputTypes.split(&#39;,&#39;)[1],
				];

				if (param1s[0] === inputData &amp;&amp; param1s[1] === inputData) {
					if (!param2s[0] &amp;&amp; param2s[1]) {
						return -1;
					}

					if (param2s[0] &amp;&amp; !param2s[1]) {
						return 1;
					}
				}

				if (param1s[0] === inputData &amp;&amp; param1s[1] !== inputData) {
					return -1;
				}

				if (param1s[1] === inputData &amp;&amp; param1s[0] !== inputData) {
					return 1;
				}

				return 1;
			};
		},

		LCHLauncherConstrainIndex (param1, param2) {
			if (!Array.isArray(param1)) {
				throw new Error(&#39;LCHErrorInputNotValid&#39;);
			}

			if (typeof param2 !== &#39;number&#39;) {
				throw new Error(&#39;LCHErrorInputNotValid&#39;);
			}

			if (param2 &lt; 0) {
				return param1.length - 1;
			}

			if (param2 &gt;= param1.length) {
				return 0;
			}

			return param2;
		},

		LCHLauncherReloadableSubjects (inputData) {
			if (!Array.isArray(inputData)) {
				throw new Error(&#39;LCHErrorInputNotValid&#39;);
			}

			return [].concat.apply([], inputData).filter(function (e) {
				if (typeof e !== &#39;object&#39; || e === null) {
					return false;
				}

				if (mod$2.LCHRecipesErrors(e)) {
					return false;
				}
				if (!mod$2.LCHRecipesIsSubject(e)) {
					return false;
				}
				return true;
			});
		},

	};

	const LCHModeCommit = mod$3.LCHLauncherModeCommit();
	const LCHModePreview = mod$3.LCHLauncherModePreview();
	const LCHModePipe = mod$3.LCHLauncherModePipe();

	const mod$4 = {

		// DATA

		DataSingletonExists () {
			return !!mod$4._ValueSingleton;
		},

		// VALUE

		_ValueClass: undefined,
		
		_ValueTarget: undefined,
		
		_ValueSingleton: undefined,

		// CONTROL

		ControlRunTasks (inputData) {
			mod$2.LCHAPIRunTasks(inputData, window.location.href);
		},
		
		// LIFECYCLE

		LifecycleSingletonCreate (inputData = {}) {
			if (mod$4._ValueSingleton) {
				mod$4.LifecycleSingletonDestroy();
			}

			if (typeof document !== &#39;undefined&#39;) {
				document.body.appendChild(mod$4._ValueTarget = document.createElement(&#39;div&#39;));
			}

			mod$4._ValueSingleton = new mod$4._ValueClass({
				target: mod$4._ValueTarget,
				props: {
					LRTOptions: inputData,
					LRTDidFinish () {
						mod$4.LifecycleSingletonDestroy();

						if (typeof inputData.LCHOptionCompletionHandler !== &#39;function&#39;) {
							return;
						}

						inputData.LCHOptionCompletionHandler();
					},
				},
			});
		},

		LifecycleSingletonDestroy () {
			mod$4._ValueSingleton.$destroy();
			
			delete mod$4._ValueSingleton;

			if (typeof document === &#39;undefined&#39;) {
				return;
			}

			mod$4._ValueTarget.remove();

			delete mod$4._ValueTarget;
		},

	};

	const LCHPackage = function () {
		const outputData = {
			LCHModeCommit,
			LCHModePreview,
			LCHModePipe,

			LCHSingletonCreate: mod$4.LifecycleSingletonCreate,
			LCHSingletonExists: mod$4.DataSingletonExists,
			LCHSingletonDestroy: mod$4.LifecycleSingletonDestroy,

			LCHTasksRun: mod$4.ControlRunTasks,
		};

		Object.freeze(outputData);

		return outputData;
	};

	var uiBehaviour = createCommonjsModule(function (module, exports) {
	(function (global, factory) {
	     module.exports = factory() ;
	}(commonjsGlobal, function () {
	    function noop() { }
	    function assign(tar, src) {
	        // @ts-ignore
	        for (const k in src)
	            tar[k] = src[k];
	        return tar;
	    }
	    function add_location(element, file, line, column, char) {
	        element.__svelte_meta = {
	            loc: { file, line, column, char }
	        };
	    }
	    function run(fn) {
	        return fn();
	    }
	    function blank_object() {
	        return Object.create(null);
	    }
	    function run_all(fns) {
	        fns.forEach(run);
	    }
	    function is_function(thing) {
	        return typeof thing === &#39;function&#39;;
	    }
	    function safe_not_equal(a, b) {
	        return a != a ? b == b : a !== b || ((a &amp;&amp; typeof a === &#39;object&#39;) || typeof a === &#39;function&#39;);
	    }
	    function is_empty(obj) {
	        return Object.keys(obj).length === 0;
	    }
	    function create_slot(definition, ctx, $$scope, fn) {
	        if (definition) {
	            const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);
	            return definition[0](slot_ctx);
	        }
	    }
	    function get_slot_context(definition, ctx, $$scope, fn) {
	        return definition[1] &amp;&amp; fn
	            ? assign($$scope.ctx.slice(), definition[1](fn(ctx)))
	            : $$scope.ctx;
	    }
	    function get_slot_changes(definition, $$scope, dirty, fn) {
	        if (definition[2] &amp;&amp; fn) {
	            const lets = definition[2](fn(dirty));
	            if ($$scope.dirty === undefined) {
	                return lets;
	            }
	            if (typeof lets === &#39;object&#39;) {
	                const merged = [];
	                const len = Math.max($$scope.dirty.length, lets.length);
	                for (let i = 0; i &lt; len; i += 1) {
	                    merged[i] = $$scope.dirty[i] | lets[i];
	                }
	                return merged;
	            }
	            return $$scope.dirty | lets;
	        }
	        return $$scope.dirty;
	    }
	    function update_slot(slot, slot_definition, ctx, $$scope, dirty, get_slot_changes_fn, get_slot_context_fn) {
	        const slot_changes = get_slot_changes(slot_definition, $$scope, dirty, get_slot_changes_fn);
	        if (slot_changes) {
	            const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);
	            slot.p(slot_context, slot_changes);
	        }
	    }
	    function null_to_empty(value) {
	        return value == null ? &#39;&#39; : value;
	    }

	    function append(target, node) {
	        target.appendChild(node);
	    }
	    function insert(target, node, anchor) {
	        target.insertBefore(node, anchor || null);
	    }
	    function detach(node) {
	        node.parentNode.removeChild(node);
	    }
	    function destroy_each(iterations, detaching) {
	        for (let i = 0; i &lt; iterations.length; i += 1) {
	            if (iterations[i])
	                iterations[i].d(detaching);
	        }
	    }
	    function element(name) {
	        return document.createElement(name);
	    }
	    function text(data) {
	        return document.createTextNode(data);
	    }
	    function space() {
	        return text(&#39; &#39;);
	    }
	    function empty() {
	        return text(&#39;&#39;);
	    }
	    function listen(node, event, handler, options) {
	        node.addEventListener(event, handler, options);
	        return () =&gt; node.removeEventListener(event, handler, options);
	    }
	    function attr(node, attribute, value) {
	        if (value == null)
	            node.removeAttribute(attribute);
	        else if (node.getAttribute(attribute) !== value)
	            node.setAttribute(attribute, value);
	    }
	    function children(element) {
	        return Array.from(element.childNodes);
	    }
	    function set_input_value(input, value) {
	        input.value = value == null ? &#39;&#39; : value;
	    }
	    function toggle_class(element, name, toggle) {
	        element.classList[toggle ? &#39;add&#39; : &#39;remove&#39;](name);
	    }
	    function custom_event(type, detail) {
	        const e = document.createEvent(&#39;CustomEvent&#39;);
	        e.initCustomEvent(type, false, false, detail);
	        return e;
	    }

	    let current_component;
	    function set_current_component(component) {
	        current_component = component;
	    }
	    function get_current_component() {
	        if (!current_component)
	            throw new Error(&#39;Function called outside component initialization&#39;);
	        return current_component;
	    }
	    function onMount(fn) {
	        get_current_component().$$.on_mount.push(fn);
	    }
	    function afterUpdate(fn) {
	        get_current_component().$$.after_update.push(fn);
	    }
	    function createEventDispatcher() {
	        const component = get_current_component();
	        return (type, detail) =&gt; {
	            const callbacks = component.$$.callbacks[type];
	            if (callbacks) {
	                // TODO are there situations where events could be dispatched
	                // in a server (non-DOM) environment?
	                const event = custom_event(type, detail);
	                callbacks.slice().forEach(fn =&gt; {
	                    fn.call(component, event);
	                });
	            }
	        };
	    }

	    const dirty_components = [];
	    const binding_callbacks = [];
	    const render_callbacks = [];
	    const flush_callbacks = [];
	    const resolved_promise = Promise.resolve();
	    let update_scheduled = false;
	    function schedule_update() {
	        if (!update_scheduled) {
	            update_scheduled = true;
	            resolved_promise.then(flush);
	        }
	    }
	    function add_render_callback(fn) {
	        render_callbacks.push(fn);
	    }
	    let flushing = false;
	    const seen_callbacks = new Set();
	    function flush() {
	        if (flushing)
	            return;
	        flushing = true;
	        do {
	            // first, call beforeUpdate functions
	            // and update components
	            for (let i = 0; i &lt; dirty_components.length; i += 1) {
	                const component = dirty_components[i];
	                set_current_component(component);
	                update(component.$$);
	            }
	            set_current_component(null);
	            dirty_components.length = 0;
	            while (binding_callbacks.length)
	                binding_callbacks.pop()();
	            // then, once components are updated, call
	            // afterUpdate functions. This may cause
	            // subsequent updates...
	            for (let i = 0; i &lt; render_callbacks.length; i += 1) {
	                const callback = render_callbacks[i];
	                if (!seen_callbacks.has(callback)) {
	                    // ...so guard against infinite loops
	                    seen_callbacks.add(callback);
	                    callback();
	                }
	            }
	            render_callbacks.length = 0;
	        } while (dirty_components.length);
	        while (flush_callbacks.length) {
	            flush_callbacks.pop()();
	        }
	        update_scheduled = false;
	        flushing = false;
	        seen_callbacks.clear();
	    }
	    function update($$) {
	        if ($$.fragment !== null) {
	            $$.update();
	            run_all($$.before_update);
	            const dirty = $$.dirty;
	            $$.dirty = [-1];
	            $$.fragment &amp;&amp; $$.fragment.p($$.ctx, dirty);
	            $$.after_update.forEach(add_render_callback);
	        }
	    }
	    const outroing = new Set();
	    let outros;
	    function group_outros() {
	        outros = {
	            r: 0,
	            c: [],
	            p: outros // parent group
	        };
	    }
	    function check_outros() {
	        if (!outros.r) {
	            run_all(outros.c);
	        }
	        outros = outros.p;
	    }
	    function transition_in(block, local) {
	        if (block &amp;&amp; block.i) {
	            outroing.delete(block);
	            block.i(local);
	        }
	    }
	    function transition_out(block, local, detach, callback) {
	        if (block &amp;&amp; block.o) {
	            if (outroing.has(block))
	                return;
	            outroing.add(block);
	            outros.c.push(() =&gt; {
	                outroing.delete(block);
	                if (callback) {
	                    if (detach)
	                        block.d(1);
	                    callback();
	                }
	            });
	            block.o(local);
	        }
	    }

	    const globals = (typeof window !== &#39;undefined&#39;
	        ? window
	        : typeof globalThis !== &#39;undefined&#39;
	            ? globalThis
	            : commonjsGlobal);

	    function get_spread_update(levels, updates) {
	        const update = {};
	        const to_null_out = {};
	        const accounted_for = { $$scope: 1 };
	        let i = levels.length;
	        while (i--) {
	            const o = levels[i];
	            const n = updates[i];
	            if (n) {
	                for (const key in o) {
	                    if (!(key in n))
	                        to_null_out[key] = 1;
	                }
	                for (const key in n) {
	                    if (!accounted_for[key]) {
	                        update[key] = n[key];
	                        accounted_for[key] = 1;
	                    }
	                }
	                levels[i] = n;
	            }
	            else {
	                for (const key in o) {
	                    accounted_for[key] = 1;
	                }
	            }
	        }
	        for (const key in to_null_out) {
	            if (!(key in update))
	                update[key] = undefined;
	        }
	        return update;
	    }
	    function get_spread_object(spread_props) {
	        return typeof spread_props === &#39;object&#39; &amp;&amp; spread_props !== null ? spread_props : {};
	    }
	    function create_component(block) {
	        block &amp;&amp; block.c();
	    }
	    function mount_component(component, target, anchor, customElement) {
	        const { fragment, on_mount, on_destroy, after_update } = component.$$;
	        fragment &amp;&amp; fragment.m(target, anchor);
	        if (!customElement) {
	            // onMount happens before the initial afterUpdate
	            add_render_callback(() =&gt; {
	                const new_on_destroy = on_mount.map(run).filter(is_function);
	                if (on_destroy) {
	                    on_destroy.push(...new_on_destroy);
	                }
	                else {
	                    // Edge case - component was destroyed immediately,
	                    // most likely as a result of a binding initialising
	                    run_all(new_on_destroy);
	                }
	                component.$$.on_mount = [];
	            });
	        }
	        after_update.forEach(add_render_callback);
	    }
	    function destroy_component(component, detaching) {
	        const $$ = component.$$;
	        if ($$.fragment !== null) {
	            run_all($$.on_destroy);
	            $$.fragment &amp;&amp; $$.fragment.d(detaching);
	            // TODO null out other refs, including component.$$ (but need to
	            // preserve final state?)
	            $$.on_destroy = $$.fragment = null;
	            $$.ctx = [];
	        }
	    }
	    function make_dirty(component, i) {
	        if (component.$$.dirty[0] === -1) {
	            dirty_components.push(component);
	            schedule_update();
	            component.$$.dirty.fill(0);
	        }
	        component.$$.dirty[(i / 31) | 0] |= (1 &lt;&lt; (i % 31));
	    }
	    function init(component, options, instance, create_fragment, not_equal, props, dirty = [-1]) {
	        const parent_component = current_component;
	        set_current_component(component);
	        const $$ = component.$$ = {
	            fragment: null,
	            ctx: null,
	            // state
	            props,
	            update: noop,
	            not_equal,
	            bound: blank_object(),
	            // lifecycle
	            on_mount: [],
	            on_destroy: [],
	            on_disconnect: [],
	            before_update: [],
	            after_update: [],
	            context: new Map(parent_component ? parent_component.$$.context : options.context || []),
	            // everything else
	            callbacks: blank_object(),
	            dirty,
	            skip_bound: false
	        };
	        let ready = false;
	        $$.ctx = instance
	            ? instance(component, options.props || {}, (i, ret, ...rest) =&gt; {
	                const value = rest.length ? rest[0] : ret;
	                if ($$.ctx &amp;&amp; not_equal($$.ctx[i], $$.ctx[i] = value)) {
	                    if (!$$.skip_bound &amp;&amp; $$.bound[i])
	                        $$.bound[i](value);
	                    if (ready)
	                        make_dirty(component, i);
	                }
	                return ret;
	            })
	            : [];
	        $$.update();
	        ready = true;
	        run_all($$.before_update);
	        // `false` as a special case of no DOM component
	        $$.fragment = create_fragment ? create_fragment($$.ctx) : false;
	        if (options.target) {
	            if (options.hydrate) {
	                const nodes = children(options.target);
	                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
	                $$.fragment &amp;&amp; $$.fragment.l(nodes);
	                nodes.forEach(detach);
	            }
	            else {
	                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
	                $$.fragment &amp;&amp; $$.fragment.c();
	            }
	            if (options.intro)
	                transition_in(component.$$.fragment);
	            mount_component(component, options.target, options.anchor, options.customElement);
	            flush();
	        }
	        set_current_component(parent_component);
	    }
	    /**
	     * Base class for Svelte components. Used when dev=false.
	     */
	    class SvelteComponent {
	        $destroy() {
	            destroy_component(this, 1);
	            this.$destroy = noop;
	        }
	        $on(type, callback) {
	            const callbacks = (this.$$.callbacks[type] || (this.$$.callbacks[type] = []));
	            callbacks.push(callback);
	            return () =&gt; {
	                const index = callbacks.indexOf(callback);
	                if (index !== -1)
	                    callbacks.splice(index, 1);
	            };
	        }
	        $set($$props) {
	            if (this.$$set &amp;&amp; !is_empty($$props)) {
	                this.$$.skip_bound = true;
	                this.$$set($$props);
	                this.$$.skip_bound = false;
	            }
	        }
	    }

	    function dispatch_dev(type, detail) {
	        document.dispatchEvent(custom_event(type, Object.assign({ version: &#39;3.38.2&#39; }, detail)));
	    }
	    function append_dev(target, node) {
	        dispatch_dev(&#39;SvelteDOMInsert&#39;, { target, node });
	        append(target, node);
	    }
	    function insert_dev(target, node, anchor) {
	        dispatch_dev(&#39;SvelteDOMInsert&#39;, { target, node, anchor });
	        insert(target, node, anchor);
	    }
	    function detach_dev(node) {
	        dispatch_dev(&#39;SvelteDOMRemove&#39;, { node });
	        detach(node);
	    }
	    function listen_dev(node, event, handler, options, has_prevent_default, has_stop_propagation) {
	        const modifiers = options === true ? [&#39;capture&#39;] : options ? Array.from(Object.keys(options)) : [];
	        if (has_prevent_default)
	            modifiers.push(&#39;preventDefault&#39;);
	        if (has_stop_propagation)
	            modifiers.push(&#39;stopPropagation&#39;);
	        dispatch_dev(&#39;SvelteDOMAddEventListener&#39;, { node, event, handler, modifiers });
	        const dispose = listen(node, event, handler, options);
	        return () =&gt; {
	            dispatch_dev(&#39;SvelteDOMRemoveEventListener&#39;, { node, event, handler, modifiers });
	            dispose();
	        };
	    }
	    function attr_dev(node, attribute, value) {
	        attr(node, attribute, value);
	        if (value == null)
	            dispatch_dev(&#39;SvelteDOMRemoveAttribute&#39;, { node, attribute });
	        else
	            dispatch_dev(&#39;SvelteDOMSetAttribute&#39;, { node, attribute, value });
	    }
	    function set_data_dev(text, data) {
	        data = &#39;&#39; + data;
	        if (text.wholeText === data)
	            return;
	        dispatch_dev(&#39;SvelteDOMSetData&#39;, { node: text, data });
	        text.data = data;
	    }
	    function validate_each_argument(arg) {
	        if (typeof arg !== &#39;string&#39; &amp;&amp; !(arg &amp;&amp; typeof arg === &#39;object&#39; &amp;&amp; &#39;length&#39; in arg)) {
	            let msg = &#39;{#each} only iterates over array-like objects.&#39;;
	            if (typeof Symbol === &#39;function&#39; &amp;&amp; arg &amp;&amp; Symbol.iterator in arg) {
	                msg += &#39; You can use a spread to convert this iterable into an array.&#39;;
	            }
	            throw new Error(msg);
	        }
	    }
	    function validate_slots(name, slot, keys) {
	        for (const slot_key of Object.keys(slot)) {
	            if (!~keys.indexOf(slot_key)) {
	                console.warn(`&lt;${name}&gt; received an unexpected slot &#34;${slot_key}&#34;.`);
	            }
	        }
	    }
	    /**
	     * Base class for Svelte components with some minor dev-enhancements. Used when dev=true.
	     */
	    class SvelteComponentDev extends SvelteComponent {
	        constructor(options) {
	            if (!options || (!options.target &amp;&amp; !options.$$inline)) {
	                throw new Error(&#34;&#39;target&#39; is a required option&#34;);
	            }
	            super();
	        }
	        $destroy() {
	            super.$destroy();
	            this.$destroy = () =&gt; {
	                console.warn(&#39;Component was already destroyed&#39;); // eslint-disable-line no-console
	            };
	        }
	        $capture_state() { }
	        $inject_state() { }
	    }

	    var commonjsGlobal$1 = typeof globalThis !== &#39;undefined&#39; ? globalThis : typeof window !== &#39;undefined&#39; ? window : typeof commonjsGlobal !== &#39;undefined&#39; ? commonjsGlobal : typeof self !== &#39;undefined&#39; ? self : {};

	    function commonjsRequire () {
	    	throw new Error(&#39;Dynamic requires are not currently supported by rollup-plugin-commonjs&#39;);
	    }

	    function unwrapExports (x) {
	    	return x &amp;&amp; x.__esModule &amp;&amp; Object.prototype.hasOwnProperty.call(x, &#39;default&#39;) ? x[&#39;default&#39;] : x;
	    }

	    function createCommonjsModule(fn, module) {
	    	return module = { exports: {} }, fn(module, module.exports), module.exports;
	    }

	    var main = createCommonjsModule(function (module, exports) {
	    const _require = commonjsRequire;

	    const mod = {

	    	OLSKSpecUIArguments (inputData) {
	    		if (!Array.isArray(inputData)) {
	    			throw new Error(&#39;OLSKErrorInputNotValid&#39;);
	    		}

	    		return inputData.map(function (e) {
	    			if (e.match(/^match=/)) {
	    				return e.replace(/^match=/, &#39;-os-match=&#39;);
	    			}

	    			if (e.match(/^skip=/)) {
	    				return e.replace(/^skip=/, &#39;-os-skip=&#39;);
	    			}

	    			return e;
	    		});
	    	},

	    	OLSKSpecUITestPaths (inputData) {
	    		if (typeof inputData !== &#39;string&#39;) {
	    			throw new Error(&#39;OLSKErrorInputNotValid&#39;);
	    		}

	    		if (!_require().OLSKDiskIsRealFolderPath(inputData)) {
	    			throw new Error(&#39;OLSKErrorInputNotValid&#39;);
	    		}

	    		return _require().sync(&#39;**/ui-test-*.js&#39;, {
	    			cwd: inputData,
	    			realpath: true,
	    		}).filter(function (e) {
	    			return !e.match(_require().OLSKDiskStandardIgnorePattern());
	    		});
	    	},

	    	OLSKSpecUISourcePaths (inputData) {
	    		if (typeof inputData !== &#39;string&#39;) {
	    			throw new Error(&#39;OLSKErrorInputNotValid&#39;);
	    		}

	    		if (!_require().OLSKDiskIsRealFolderPath(inputData)) {
	    			throw new Error(&#39;OLSKErrorInputNotValid&#39;);
	    		}

	    		return _require().sync(&#39;**/+(ui-behaviour.js|*.ejs|*.md|*.html)&#39;, {
	    			cwd: inputData,
	    			realpath: true,
	    		}).filter(function (e) {
	    			if (e.match(&#39;__compiled&#39;)) {
	    				return true;
	    			}
	    			
	    			return !e.match(_require().OLSKDiskStandardIgnorePattern());
	    		});
	    	},

	    	OLSKSpecMochaPaths (inputData) {
	    		if (typeof inputData !== &#39;object&#39; || inputData === null) {
	    			throw new Error(&#39;OLSKErrorInputNotValid&#39;);
	    		}

	    		if (typeof inputData.ParamPackageDirectory !== &#39;string&#39;) {
	    			throw new Error(&#39;OLSKErrorInputNotValid&#39;);
	    		}

	    		if (typeof inputData.ParamWorkingDirectory !== &#39;string&#39;) {
	    			throw new Error(&#39;OLSKErrorInputNotValid&#39;);
	    		}

	    		return [
	    			_require().join(inputData.ParamPackageDirectory, &#39;./node_modules/.bin/mocha&#39;),
	    			_require().join(inputData.ParamPackageDirectory, &#39;../.bin/mocha&#39;),
	    			_require().join(inputData.ParamWorkingDirectory, &#39;./node_modules/.bin/mocha&#39;),
	    			];
	    	},

	    	_OLSKSpecMochaReplaceES6Import (inputData) {
	    		const exportable = [];
	    		
	    		inputData = inputData
	    			.replace(/^import \* as (\w+) from [&#39;&#34;]([^&#39;&#34;]+)[&#39;&#34;];?/gm, &#39;var $1 = require(&#34;$2&#34;);&#39;)
	    			// .replace(/^import (\w+) from [&#39;&#34;]([^&#39;&#34;]+)[&#39;&#34;];?/gm, &#39;var {default: $1} = require(&#34;$2&#34;);&#39;)
	    			.replace(/^import (\w+) from [&#39;&#34;]([^&#39;&#34;]+)[&#39;&#34;];?/gm, &#39;var _$1 = require(&#34;$2&#34;); const $1 = _$1.default || _$1&#39;)
	    			.replace(/^import {([^}]+)} from [&#39;&#34;](.+)[&#39;&#34;];?/gm, &#39;var {$1} = require(&#34;$2&#34;);&#39;)
	    			.replace(/^export default /gm, &#39;exports.default = &#39;)
	    			.replace(/^export (const|let|var|class|function) (\w+)/gm, (match, type, name) =&gt; {
	    				exportable.push(name);
	    				return `${type} ${name}`;
	    			})
	    			.replace(/^export \{([^}]+)\}(?: from [&#39;&#34;]([^&#39;&#34;]+)[&#39;&#34;];?)?/gm, (match, names, source) =&gt; {
	    				names.split(&#39;,&#39;).filter(Boolean).forEach(name =&gt; {
	    					exportable.push(name);
	    				});

	    				return source ? `const { ${names} } = require(&#34;${source}&#34;);` : &#39;&#39;;
	    			})
	    			.replace(/^export function (\w+)/gm, &#39;exports.$1 = function $1&#39;);

	    		exportable.forEach(name =&gt; {
	    			inputData += `\nexports.${name} = ${name};`;
	    		});

	    		return inputData;
	    	},
	    	
	    };

	    Object.assign(exports, mod);

	    {
	    	exports.OLSK_SPEC_UI = function () {
	    		if (typeof navigator === &#39;undefined&#39;) {
	    			return false;
	    		}

	    		if (typeof window !== &#39;undefined&#39; &amp;&amp; window.location.hostname === &#39;loc.tests&#39;) {
	    			return true;
	    		}

	    		return navigator.appName === &#39;Zombie&#39;;
	    	};
	    }
	    });
	    var main_1 = main.OLSK_SPEC_UI;

	    const mod = {

	    	LCHFormulaSafeStringFields: [
	    		&#39;LCHFormulaID&#39;,
	    		&#39;LCHFormulaName&#39;,
	    		&#39;LCHFormulaSignature&#39;,
	    		&#39;LCHFormulaInputTypes&#39;,
	    		&#39;LCHFormulaOutputType&#39;,
	    		&#39;LCHFormulaStyle&#39;,
	    		&#39;LCHFormulaURLFilter&#39;,
	    		&#39;LCHFormulaCreationDate&#39;,
	    		&#39;LCHFormulaModificationDate&#39;,
	    		&#39;LCHFormulaSyntaxErrorMessage&#39;,
	    		&#39;@context&#39;,
	    	],

	    	LCHFormulaErrors (inputData, options = {}) {
	    		if (typeof inputData !== &#39;object&#39; || inputData === null) {
	    			throw new Error(&#39;LCHErrorInputNotValid&#39;);
	    		}

	    		const errors = {};

	    		if (inputData.LCHFormulaName !== undefined || options.LCHOptionValidateIfNotPresent) {
	    			if (typeof inputData.LCHFormulaName !== &#39;string&#39;) {
	    				errors.LCHFormulaName = [
	    					&#39;LCHErrorNotString&#39;,
	    				];
	    			}
	    		}

	    		if (inputData.LCHFormulaSignature !== undefined || options.LCHOptionValidateIfNotPresent) {
	    			if (typeof inputData.LCHFormulaSignature !== &#39;string&#39;) {
	    				errors.LCHFormulaSignature = [
	    					&#39;LCHErrorNotString&#39;,
	    				];
	    			}
	    		}

	    		if (inputData.LCHFormulaInputTypes !== undefined || options.LCHOptionValidateIfNotPresent) {
	    			if (typeof inputData.LCHFormulaInputTypes !== &#39;string&#39;) {
	    				errors.LCHFormulaInputTypes = [
	    					&#39;LCHErrorNotString&#39;,
	    				];
	    			}
	    		}

	    		if (inputData.LCHFormulaOutputType !== undefined || options.LCHOptionValidateIfNotPresent) {
	    			if (typeof inputData.LCHFormulaOutputType !== &#39;string&#39;) {
	    				errors.LCHFormulaOutputType = [
	    					&#39;LCHErrorNotString&#39;,
	    				];
	    			}
	    		}

	    		if (inputData.LCHFormulaIsHidden !== undefined) {
	    			if (typeof inputData.LCHFormulaIsHidden !== &#39;function&#39;) {
	    				errors.LCHFormulaIsHidden = [
	    					&#39;LCHErrorNotFunction&#39;,
	    				];
	    			}
	    		}

	    		if (inputData.LCHFormulaURLFilter !== undefined || options.LCHOptionValidateIfNotPresent) {
	    			if (typeof inputData.LCHFormulaURLFilter !== &#39;string&#39;) {
	    				errors.LCHFormulaURLFilter = [
	    					&#39;LCHErrorNotString&#39;,
	    				];
	    			}
	    		}

	    		if (inputData.LCHFormulaIsAutomatic !== undefined || options.LCHOptionValidateIfNotPresent) {
	    			if (typeof inputData.LCHFormulaIsAutomatic !== &#39;boolean&#39;) {
	    				errors.LCHFormulaIsAutomatic = [
	    					&#39;LCHErrorNotBoolean&#39;,
	    				];
	    			}
	    		}

	    		if (inputData.LCHFormulaStyle !== undefined || options.LCHOptionValidateIfNotPresent) {
	    			if (typeof inputData.LCHFormulaStyle !== &#39;string&#39;) {
	    				errors.LCHFormulaStyle = [
	    					&#39;LCHErrorNotString&#39;,
	    				];
	    			}
	    		}

	    		if (inputData.LCHFormulaIsFlagged !== undefined || options.LCHOptionValidateIfNotPresent) {
	    			if (typeof inputData.LCHFormulaIsFlagged !== &#39;boolean&#39;) {
	    				errors.LCHFormulaIsFlagged = [
	    					&#39;LCHErrorNotBoolean&#39;,
	    				];
	    			}
	    		}

	    		return Object.entries(errors).length ? errors : null;
	    	},

	    	LCHFormulaFrom (inputData) {
	    		if (typeof inputData !== &#39;object&#39; || inputData === null) {
	    			throw new Error(&#39;LCHErrorInputNotValid&#39;);
	    		}

	    		return Object.entries(inputData).reduce(function (coll, item) {
	    			coll[item[0].replace(/LCH[A-Z][a-z]+/, &#39;LCHFormula&#39;)] = item[1];

	    			return coll;
	    		}, {});
	    	},

	    	LCHFormulaTo (param1, param2) {
	    		if (typeof param1 !== &#39;object&#39; || param1 === null) {
	    			throw new Error(&#39;LCHErrorInputNotValid&#39;);
	    		}

	    		if (typeof param2 !== &#39;string&#39;) {
	    			throw new Error(&#39;LCHErrorInputNotValid&#39;);
	    		}

	    		return Object.entries(param1).reduce(function (coll, item) {
	    			coll[item[0].replace(&#39;LCHFormula&#39;, param2)] = item[1];

	    			return coll;
	    		}, {});
	    	},

	    	LCHFormulaToEvaluate (inputData) {
	    		if (mod.LCHFormulaErrors(inputData)) {
	    			throw new Error(&#39;LCHErrorInputNotValid&#39;);
	    		}

	    		let outputData = Object.fromEntries(Object.entries(inputData).filter(function (e) {
	    			return !mod.LCHFormulaSafeStringFields.includes(e[0]);
	    		}));

	    		if (outputData.LCHFormulaCallbackArgs || outputData.LCHFormulaCallbackBody) {
	    			outputData.LCHFormulaCallbackRaw = `(function (${ outputData.LCHFormulaCallbackArgs || &#39;&#39; }) { ${ outputData.LCHFormulaCallbackBody || &#39;&#39; } })`;
	    			delete outputData.LCHFormulaCallbackArgs;
	    			delete outputData.LCHFormulaCallbackBody;
	    		}

	    		if (outputData.LCHFormulaCanonicalExampleCallbackBody) {
	    			outputData.LCHFormulaCanonicalExampleCallbackRaw = `(function () { ${ outputData.LCHFormulaCanonicalExampleCallbackBody || &#39;&#39; } })`;
	    			delete outputData.LCHFormulaCanonicalExampleCallbackBody;
	    		}

	    		return outputData;
	    	},

	    };

	    const mod$1 = {

	    	LCHRuntimeURLFilter (param1, param2) {
	    		if (typeof param1 !== &#39;string&#39;) {
	    			throw new Error(&#39;LCHErrorInputNotValid&#39;);
	    		}

	    		if (typeof param2 !== &#39;string&#39;) {
	    			throw new Error(&#39;LCHErrorInputNotValid&#39;);
	    		}

	    		if (!param2) {
	    			throw new Error(&#39;LCHErrorInputNotValid&#39;);
	    		}

	    		if (param1 === &#39;*&#39;) {
	    			return true;
	    		}

	    		let match = param1.match(/^\/(.*)\/(\w*)/i);

	    		if (!match || !match.shift()) {
	    			return param2.includes(param1);
	    		}

	    		return !!param2.match(new RegExp(match[0], match[1]));
	    	},

	    	LCHRuntimeInputTypes(inputData) {
	    		if (typeof inputData !== &#39;string&#39;) {
	    			throw new Error(&#39;LCHErrorInputNotValid&#39;);
	    		}

	    		return inputData.split(&#39;,&#39;).map(function (e) {
	    			return e.trim();
	    		}).filter(function (e) {
	    			return !!e;
	    		});
	    	},

	    	LCHRuntimeAPI(inputData) {
	    		if (!Array.isArray(inputData)) {
	    			throw new Error(&#39;LCHErrorInputNotValid&#39;);
	    		}

	    		const outputData = {
	    			fn (signature) {
	    				if (typeof signature !== &#39;string&#39;) {
	    					throw new Error(&#39;LCHErrorIdentifierNotString&#39;);
	    				}

	    				if (signature === &#39;&#39;) {
	    					throw new Error(&#39;LCHErrorIdentifierBlank&#39;);
	    				}

	    				if (signature.trim() !== signature) {
	    					throw new Error(&#39;LCHErrorIdentifierContainsUntrimmedWhitespace&#39;);
	    				}

	    				let functionObject = inputData.filter(function (e) {
	    					return e.LCHRecipeSignature === signature;
	    				}).shift();

	    				if (!functionObject) {
	    					throw new Error(&#39;LCHErrorIdentifierNotDefined&#39;);
	    				}

	    				return functionObject.LCHRecipeCallback.bind({
	    					api: outputData,
	    				});
	    			},
	    		};

	    		Object.assign(outputData, inputData.reduce(function (coll, item) {
	    			if (!coll[item.LCHRecipeSignature]) {
	    				coll[item.LCHRecipeSignature] = function () {
	    					const args = arguments;

	    					(item.LCHRecipeInputTypes ? mod$1.LCHRuntimeInputTypes(item.LCHRecipeInputTypes) : []).forEach(function (e, i) {
	    						if (!coll[e](args[i])) {
	    							throw new Error(&#39;LCHErrorTypeMismatch&#39;);
	    						}
	    					});

	    					return item.LCHRecipeCallback.apply({
	    						api: outputData,
	    					}, args);
	    				};
	    			}

	    			return coll;
	    		}, {}));

	    		Object.freeze(outputData);

	    		return outputData;
	    	},

	    };

	    const LCHTypeServiceSearchCallback = function(inputData) {
	    	if (!inputData.LCHRecipeName) {
	    		return false;
	    	}
	    	
	    	if (inputData.LCHRecipeCallback.length) {
	    		return false;
	    	}
	    	
	    	if (inputData.LCHRecipeOutputType !== &#39;ServiceSearchURLTemplate&#39;) {
	    		return false;
	    	}

	    	return true;
	    };

	    const LCHTypeServiceSearchCanonicalExampleCallback = function() {
	    	return {
	    		LCHRecipeName: &#39;alfa&#39;,
	    		LCHRecipeCallback () {
	    			return &#39;https://example.com?q=LCHSEARCHTOKEN&#39;;
	    		},
	    		LCHRecipeOutputType: &#39;ServiceSearchURLTemplate&#39;,
	    	};
	    };

	    const LCHTypeServiceSearchRecipe = function() {
	    	return {
	    		LCHRecipeSignature: &#39;ServiceSearch&#39;,
	    		LCHRecipeCallback: LCHTypeServiceSearchCallback,
	    		LCHRecipeOutputType: &#39;Bool&#39;,
	    		LCHRecipeCanonicalExampleCallback: LCHTypeServiceSearchCanonicalExampleCallback,
	    	};
	    };

	    var ServiceSearch = /*#__PURE__*/Object.freeze({
	        LCHTypeServiceSearchCallback: LCHTypeServiceSearchCallback,
	        LCHTypeServiceSearchCanonicalExampleCallback: LCHTypeServiceSearchCanonicalExampleCallback,
	        LCHTypeServiceSearchRecipe: LCHTypeServiceSearchRecipe
	    });

	    const LCHPrimitiveBoolCallback = function(inputData) {
	    	return !!inputData;
	    };

	    const LCHPrimitiveBoolRecipe = function() {
	    	return {
	    		LCHRecipeSignature: &#39;Bool&#39;,
	    		LCHRecipeCallback: LCHPrimitiveBoolCallback,
	    	};
	    };

	    var Bool = /*#__PURE__*/Object.freeze({
	        LCHPrimitiveBoolCallback: LCHPrimitiveBoolCallback,
	        LCHPrimitiveBoolRecipe: LCHPrimitiveBoolRecipe
	    });

	    const LCHPrimitiveDateCallback = function(inputData) {
	    	if (!(inputData instanceof Date)) {
	    		return false;
	    	}

	    	if (Number.isNaN(inputData.getTime())) {
	    		return false;
	    	}

	    	return true;
	    };

	    const LCHPrimitiveDateCanonicalExampleCallback = function() {
	    	return new Date(0);
	    };

	    const LCHPrimitiveDateRecipe = function() {
	    	return {
	    		LCHRecipeSignature: &#39;Date&#39;,
	    		LCHRecipeCallback: LCHPrimitiveDateCallback,
	    		LCHRecipeOutputType: &#39;Bool&#39;,
	    		LCHRecipeCanonicalExampleCallback: LCHPrimitiveDateCanonicalExampleCallback,
	    	};
	    };

	    var Date$1 = /*#__PURE__*/Object.freeze({
	        LCHPrimitiveDateCallback: LCHPrimitiveDateCallback,
	        LCHPrimitiveDateCanonicalExampleCallback: LCHPrimitiveDateCanonicalExampleCallback,
	        LCHPrimitiveDateRecipe: LCHPrimitiveDateRecipe
	    });

	    const LCHPrimitiveDOMElementCallback = function(inputData) {
	    	if (typeof inputData !== &#39;object&#39; || inputData === null) {
	    		return false;
	    	}

	    	if (typeof inputData.focus !== &#39;function&#39;) {
	    		return false;
	    	}

	    	return true;
	    };

	    const LCHPrimitiveDOMElementCanonicalExampleCallback = function() {
	    	return {
	    		focus () {},
	    	};
	    };

	    const LCHPrimitiveDOMElementRecipe = function() {
	    	return {
	    		LCHRecipeCallback: LCHPrimitiveDOMElementCallback,
	    		LCHRecipeOutputType: &#39;Bool&#39;,
	    		LCHRecipeCanonicalExampleCallback: LCHPrimitiveDOMElementCanonicalExampleCallback,
	    		LCHRecipeSignature: &#39;DOMElement&#39;,
	    		_LCHRecipeTypeIsExclusive: true,
	    	};
	    };

	    var DOMElement = /*#__PURE__*/Object.freeze({
	        LCHPrimitiveDOMElementCallback: LCHPrimitiveDOMElementCallback,
	        LCHPrimitiveDOMElementCanonicalExampleCallback: LCHPrimitiveDOMElementCanonicalExampleCallback,
	        LCHPrimitiveDOMElementRecipe: LCHPrimitiveDOMElementRecipe
	    });

	    /**
	     * Check if we&#39;re required to add a port number.
	     *
	     * @see https://url.spec.whatwg.org/#default-port
	     * @param {Number|String} port Port number we need to check
	     * @param {String} protocol Protocol we need to check against.
	     * @returns {Boolean} Is it a default port for the given protocol
	     * @api private
	     */
	    var requiresPort = function required(port, protocol) {
	      protocol = protocol.split(&#39;:&#39;)[0];
	      port = +port;

	      if (!port) return false;

	      switch (protocol) {
	        case &#39;http&#39;:
	        case &#39;ws&#39;:
	        return port !== 80;

	        case &#39;https&#39;:
	        case &#39;wss&#39;:
	        return port !== 443;

	        case &#39;ftp&#39;:
	        return port !== 21;

	        case &#39;gopher&#39;:
	        return port !== 70;

	        case &#39;file&#39;:
	        return false;
	      }

	      return port !== 0;
	    };

	    var has = Object.prototype.hasOwnProperty
	      , undef;

	    /**
	     * Decode a URI encoded string.
	     *
	     * @param {String} input The URI encoded string.
	     * @returns {String|Null} The decoded string.
	     * @api private
	     */
	    function decode(input) {
	      try {
	        return decodeURIComponent(input.replace(/\+/g, &#39; &#39;));
	      } catch (e) {
	        return null;
	      }
	    }

	    /**
	     * Attempts to encode a given input.
	     *
	     * @param {String} input The string that needs to be encoded.
	     * @returns {String|Null} The encoded string.
	     * @api private
	     */
	    function encode(input) {
	      try {
	        return encodeURIComponent(input);
	      } catch (e) {
	        return null;
	      }
	    }

	    /**
	     * Simple query string parser.
	     *
	     * @param {String} query The query string that needs to be parsed.
	     * @returns {Object}
	     * @api public
	     */
	    function querystring(query) {
	      var parser = /([^=?#&amp;]+)=?([^&amp;]*)/g
	        , result = {}
	        , part;

	      while (part = parser.exec(query)) {
	        var key = decode(part[1])
	          , value = decode(part[2]);

	        //
	        // Prevent overriding of existing properties. This ensures that build-in
	        // methods like `toString` or __proto__ are not overriden by malicious
	        // querystrings.
	        //
	        // In the case if failed decoding, we want to omit the key/value pairs
	        // from the result.
	        //
	        if (key === null || value === null || key in result) continue;
	        result[key] = value;
	      }

	      return result;
	    }

	    /**
	     * Transform a query string to an object.
	     *
	     * @param {Object} obj Object that should be transformed.
	     * @param {String} prefix Optional prefix.
	     * @returns {String}
	     * @api public
	     */
	    function querystringify(obj, prefix) {
	      prefix = prefix || &#39;&#39;;

	      var pairs = []
	        , value
	        , key;

	      //
	      // Optionally prefix with a &#39;?&#39; if needed
	      //
	      if (&#39;string&#39; !== typeof prefix) prefix = &#39;?&#39;;

	      for (key in obj) {
	        if (has.call(obj, key)) {
	          value = obj[key];

	          //
	          // Edge cases where we actually want to encode the value to an empty
	          // string instead of the stringified value.
	          //
	          if (!value &amp;&amp; (value === null || value === undef || isNaN(value))) {
	            value = &#39;&#39;;
	          }

	          key = encode(key);
	          value = encode(value);

	          //
	          // If we failed to encode the strings, we should bail out as we don&#39;t
	          // want to add invalid strings to the query.
	          //
	          if (key === null || value === null) continue;
	          pairs.push(key +&#39;=&#39;+ value);
	        }
	      }

	      return pairs.length ? prefix + pairs.join(&#39;&amp;&#39;) : &#39;&#39;;
	    }

	    //
	    // Expose the module.
	    //
	    var stringify = querystringify;
	    var parse = querystring;

	    var querystringify_1 = {
	    	stringify: stringify,
	    	parse: parse
	    };

	    var slashes = /^[A-Za-z][A-Za-z0-9+-.]*:[\\/]+/
	      , protocolre = /^([a-z][a-z0-9.+-]*:)?([\\/]{1,})?([\S\s]*)/i
	      , whitespace = &#39;[\\x09\\x0A\\x0B\\x0C\\x0D\\x20\\xA0\\u1680\\u180E\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200A\\u202F\\u205F\\u3000\\u2028\\u2029\\uFEFF]&#39;
	      , left = new RegExp(&#39;^&#39;+ whitespace +&#39;+&#39;);

	    /**
	     * Trim a given string.
	     *
	     * @param {String} str String to trim.
	     * @public
	     */
	    function trimLeft(str) {
	      return (str ? str : &#39;&#39;).toString().replace(left, &#39;&#39;);
	    }

	    /**
	     * These are the parse rules for the URL parser, it informs the parser
	     * about:
	     *
	     * 0. The char it Needs to parse, if it&#39;s a string it should be done using
	     *    indexOf, RegExp using exec and NaN means set as current value.
	     * 1. The property we should set when parsing this value.
	     * 2. Indication if it&#39;s backwards or forward parsing, when set as number it&#39;s
	     *    the value of extra chars that should be split off.
	     * 3. Inherit from location if non existing in the parser.
	     * 4. `toLowerCase` the resulting value.
	     */
	    var rules = [
	      [&#39;#&#39;, &#39;hash&#39;],                        // Extract from the back.
	      [&#39;?&#39;, &#39;query&#39;],                       // Extract from the back.
	      function sanitize(address) {          // Sanitize what is left of the address
	        return address.replace(&#39;\\&#39;, &#39;/&#39;);
	      },
	      [&#39;/&#39;, &#39;pathname&#39;],                    // Extract from the back.
	      [&#39;@&#39;, &#39;auth&#39;, 1],                     // Extract from the front.
	      [NaN, &#39;host&#39;, undefined, 1, 1],       // Set left over value.
	      [/:(\d+)$/, &#39;port&#39;, undefined, 1],    // RegExp the back.
	      [NaN, &#39;hostname&#39;, undefined, 1, 1]    // Set left over.
	    ];

	    /**
	     * These properties should not be copied or inherited from. This is only needed
	     * for all non blob URL&#39;s as a blob URL does not include a hash, only the
	     * origin.
	     *
	     * @type {Object}
	     * @private
	     */
	    var ignore = { hash: 1, query: 1 };

	    /**
	     * The location object differs when your code is loaded through a normal page,
	     * Worker or through a worker using a blob. And with the blobble begins the
	     * trouble as the location object will contain the URL of the blob, not the
	     * location of the page where our code is loaded in. The actual origin is
	     * encoded in the `pathname` so we can thankfully generate a good &#34;default&#34;
	     * location from it so we can generate proper relative URL&#39;s again.
	     *
	     * @param {Object|String} loc Optional default location object.
	     * @returns {Object} lolcation object.
	     * @public
	     */
	    function lolcation(loc) {
	      var globalVar;

	      if (typeof window !== &#39;undefined&#39;) globalVar = window;
	      else if (typeof commonjsGlobal$1 !== &#39;undefined&#39;) globalVar = commonjsGlobal$1;
	      else if (typeof self !== &#39;undefined&#39;) globalVar = self;
	      else globalVar = {};

	      var location = globalVar.location || {};
	      loc = loc || location;

	      var finaldestination = {}
	        , type = typeof loc
	        , key;

	      if (&#39;blob:&#39; === loc.protocol) {
	        finaldestination = new Url(unescape(loc.pathname), {});
	      } else if (&#39;string&#39; === type) {
	        finaldestination = new Url(loc, {});
	        for (key in ignore) delete finaldestination[key];
	      } else if (&#39;object&#39; === type) {
	        for (key in loc) {
	          if (key in ignore) continue;
	          finaldestination[key] = loc[key];
	        }

	        if (finaldestination.slashes === undefined) {
	          finaldestination.slashes = slashes.test(loc.href);
	        }
	      }

	      return finaldestination;
	    }

	    /**
	     * @typedef ProtocolExtract
	     * @type Object
	     * @property {String} protocol Protocol matched in the URL, in lowercase.
	     * @property {Boolean} slashes `true` if protocol is followed by &#34;//&#34;, else `false`.
	     * @property {String} rest Rest of the URL that is not part of the protocol.
	     */

	    /**
	     * Extract protocol information from a URL with/without double slash (&#34;//&#34;).
	     *
	     * @param {String} address URL we want to extract from.
	     * @return {ProtocolExtract} Extracted information.
	     * @private
	     */
	    function extractProtocol(address) {
	      address = trimLeft(address);

	      var match = protocolre.exec(address)
	        , protocol = match[1] ? match[1].toLowerCase() : &#39;&#39;
	        , slashes = !!(match[2] &amp;&amp; match[2].length &gt;= 2)
	        , rest =  match[2] &amp;&amp; match[2].length === 1 ? &#39;/&#39; + match[3] : match[3];

	      return {
	        protocol: protocol,
	        slashes: slashes,
	        rest: rest
	      };
	    }

	    /**
	     * Resolve a relative URL pathname against a base URL pathname.
	     *
	     * @param {String} relative Pathname of the relative URL.
	     * @param {String} base Pathname of the base URL.
	     * @return {String} Resolved pathname.
	     * @private
	     */
	    function resolve(relative, base) {
	      if (relative === &#39;&#39;) return base;

	      var path = (base || &#39;/&#39;).split(&#39;/&#39;).slice(0, -1).concat(relative.split(&#39;/&#39;))
	        , i = path.length
	        , last = path[i - 1]
	        , unshift = false
	        , up = 0;

	      while (i--) {
	        if (path[i] === &#39;.&#39;) {
	          path.splice(i, 1);
	        } else if (path[i] === &#39;..&#39;) {
	          path.splice(i, 1);
	          up++;
	        } else if (up) {
	          if (i === 0) unshift = true;
	          path.splice(i, 1);
	          up--;
	        }
	      }

	      if (unshift) path.unshift(&#39;&#39;);
	      if (last === &#39;.&#39; || last === &#39;..&#39;) path.push(&#39;&#39;);

	      return path.join(&#39;/&#39;);
	    }

	    /**
	     * The actual URL instance. Instead of returning an object we&#39;ve opted-in to
	     * create an actual constructor as it&#39;s much more memory efficient and
	     * faster and it pleases my OCD.
	     *
	     * It is worth noting that we should not use `URL` as class name to prevent
	     * clashes with the global URL instance that got introduced in browsers.
	     *
	     * @constructor
	     * @param {String} address URL we want to parse.
	     * @param {Object|String} [location] Location defaults for relative paths.
	     * @param {Boolean|Function} [parser] Parser for the query string.
	     * @private
	     */
	    function Url(address, location, parser) {
	      address = trimLeft(address);

	      if (!(this instanceof Url)) {
	        return new Url(address, location, parser);
	      }

	      var relative, extracted, parse, instruction, index, key
	        , instructions = rules.slice()
	        , type = typeof location
	        , url = this
	        , i = 0;

	      //
	      // The following if statements allows this module two have compatibility with
	      // 2 different API:
	      //
	      // 1. Node.js&#39;s `url.parse` api which accepts a URL, boolean as arguments
	      //    where the boolean indicates that the query string should also be parsed.
	      //
	      // 2. The `URL` interface of the browser which accepts a URL, object as
	      //    arguments. The supplied object will be used as default values / fall-back
	      //    for relative paths.
	      //
	      if (&#39;object&#39; !== type &amp;&amp; &#39;string&#39; !== type) {
	        parser = location;
	        location = null;
	      }

	      if (parser &amp;&amp; &#39;function&#39; !== typeof parser) parser = querystringify_1.parse;

	      location = lolcation(location);

	      //
	      // Extract protocol information before running the instructions.
	      //
	      extracted = extractProtocol(address || &#39;&#39;);
	      relative = !extracted.protocol &amp;&amp; !extracted.slashes;
	      url.slashes = extracted.slashes || relative &amp;&amp; location.slashes;
	      url.protocol = extracted.protocol || location.protocol || &#39;&#39;;
	      address = extracted.rest;

	      //
	      // When the authority component is absent the URL starts with a path
	      // component.
	      //
	      if (!extracted.slashes) instructions[3] = [/(.*)/, &#39;pathname&#39;];

	      for (; i &lt; instructions.length; i++) {
	        instruction = instructions[i];

	        if (typeof instruction === &#39;function&#39;) {
	          address = instruction(address);
	          continue;
	        }

	        parse = instruction[0];
	        key = instruction[1];

	        if (parse !== parse) {
	          url[key] = address;
	        } else if (&#39;string&#39; === typeof parse) {
	          if (~(index = address.indexOf(parse))) {
	            if (&#39;number&#39; === typeof instruction[2]) {
	              url[key] = address.slice(0, index);
	              address = address.slice(index + instruction[2]);
	            } else {
	              url[key] = address.slice(index);
	              address = address.slice(0, index);
	            }
	          }
	        } else if ((index = parse.exec(address))) {
	          url[key] = index[1];
	          address = address.slice(0, index.index);
	        }

	        url[key] = url[key] || (
	          relative &amp;&amp; instruction[3] ? location[key] || &#39;&#39; : &#39;&#39;
	        );

	        //
	        // Hostname, host and protocol should be lowercased so they can be used to
	        // create a proper `origin`.
	        //
	        if (instruction[4]) url[key] = url[key].toLowerCase();
	      }

	      //
	      // Also parse the supplied query string in to an object. If we&#39;re supplied
	      // with a custom parser as function use that instead of the default build-in
	      // parser.
	      //
	      if (parser) url.query = parser(url.query);

	      //
	      // If the URL is relative, resolve the pathname against the base URL.
	      //
	      if (
	          relative
	        &amp;&amp; location.slashes
	        &amp;&amp; url.pathname.charAt(0) !== &#39;/&#39;
	        &amp;&amp; (url.pathname !== &#39;&#39; || location.pathname !== &#39;&#39;)
	      ) {
	        url.pathname = resolve(url.pathname, location.pathname);
	      }

	      //
	      // Default to a / for pathname if none exists. This normalizes the URL
	      // to always have a /
	      //
	      if (url.pathname.charAt(0) !== &#39;/&#39; &amp;&amp; url.hostname) {
	        url.pathname = &#39;/&#39; + url.pathname;
	      }

	      //
	      // We should not add port numbers if they are already the default port number
	      // for a given protocol. As the host also contains the port number we&#39;re going
	      // override it with the hostname which contains no port number.
	      //
	      if (!requiresPort(url.port, url.protocol)) {
	        url.host = url.hostname;
	        url.port = &#39;&#39;;
	      }

	      //
	      // Parse down the `auth` for the username and password.
	      //
	      url.username = url.password = &#39;&#39;;
	      if (url.auth) {
	        instruction = url.auth.split(&#39;:&#39;);
	        url.username = instruction[0] || &#39;&#39;;
	        url.password = instruction[1] || &#39;&#39;;
	      }

	      url.origin = url.protocol &amp;&amp; url.host &amp;&amp; url.protocol !== &#39;file:&#39;
	        ? url.protocol +&#39;//&#39;+ url.host
	        : &#39;null&#39;;

	      //
	      // The href is just the compiled result.
	      //
	      url.href = url.toString();
	    }

	    /**
	     * This is convenience method for changing properties in the URL instance to
	     * insure that they all propagate correctly.
	     *
	     * @param {String} part          Property we need to adjust.
	     * @param {Mixed} value          The newly assigned value.
	     * @param {Boolean|Function} fn  When setting the query, it will be the function
	     *                               used to parse the query.
	     *                               When setting the protocol, double slash will be
	     *                               removed from the final url if it is true.
	     * @returns {URL} URL instance for chaining.
	     * @public
	     */
	    function set(part, value, fn) {
	      var url = this;

	      switch (part) {
	        case &#39;query&#39;:
	          if (&#39;string&#39; === typeof value &amp;&amp; value.length) {
	            value = (fn || querystringify_1.parse)(value);
	          }

	          url[part] = value;
	          break;

	        case &#39;port&#39;:
	          url[part] = value;

	          if (!requiresPort(value, url.protocol)) {
	            url.host = url.hostname;
	            url[part] = &#39;&#39;;
	          } else if (value) {
	            url.host = url.hostname +&#39;:&#39;+ value;
	          }

	          break;

	        case &#39;hostname&#39;:
	          url[part] = value;

	          if (url.port) value += &#39;:&#39;+ url.port;
	          url.host = value;
	          break;

	        case &#39;host&#39;:
	          url[part] = value;

	          if (/:\d+$/.test(value)) {
	            value = value.split(&#39;:&#39;);
	            url.port = value.pop();
	            url.hostname = value.join(&#39;:&#39;);
	          } else {
	            url.hostname = value;
	            url.port = &#39;&#39;;
	          }

	          break;

	        case &#39;protocol&#39;:
	          url.protocol = value.toLowerCase();
	          url.slashes = !fn;
	          break;

	        case &#39;pathname&#39;:
	        case &#39;hash&#39;:
	          if (value) {
	            var char = part === &#39;pathname&#39; ? &#39;/&#39; : &#39;#&#39;;
	            url[part] = value.charAt(0) !== char ? char + value : value;
	          } else {
	            url[part] = value;
	          }
	          break;

	        default:
	          url[part] = value;
	      }

	      for (var i = 0; i &lt; rules.length; i++) {
	        var ins = rules[i];

	        if (ins[4]) url[ins[1]] = url[ins[1]].toLowerCase();
	      }

	      url.origin = url.protocol &amp;&amp; url.host &amp;&amp; url.protocol !== &#39;file:&#39;
	        ? url.protocol +&#39;//&#39;+ url.host
	        : &#39;null&#39;;

	      url.href = url.toString();

	      return url;
	    }

	    /**
	     * Transform the properties back in to a valid and full URL string.
	     *
	     * @param {Function} stringify Optional query stringify function.
	     * @returns {String} Compiled version of the URL.
	     * @public
	     */
	    function toString(stringify) {
	      if (!stringify || &#39;function&#39; !== typeof stringify) stringify = querystringify_1.stringify;

	      var query
	        , url = this
	        , protocol = url.protocol;

	      if (protocol &amp;&amp; protocol.charAt(protocol.length - 1) !== &#39;:&#39;) protocol += &#39;:&#39;;

	      var result = protocol + (url.slashes ? &#39;//&#39; : &#39;&#39;);

	      if (url.username) {
	        result += url.username;
	        if (url.password) result += &#39;:&#39;+ url.password;
	        result += &#39;@&#39;;
	      }

	      result += url.host + url.pathname;

	      query = &#39;object&#39; === typeof url.query ? stringify(url.query) : url.query;
	      if (query) result += &#39;?&#39; !== query.charAt(0) ? &#39;?&#39;+ query : query;

	      if (url.hash) result += url.hash;

	      return result;
	    }

	    Url.prototype = { set: set, toString: toString };

	    //
	    // Expose the URL parser and some additional properties that might be useful for
	    // others or testing.
	    //
	    Url.extractProtocol = extractProtocol;
	    Url.location = lolcation;
	    Url.trimLeft = trimLeft;
	    Url.qs = querystringify_1;

	    var urlParse = Url;

	    var _URLParser = /*#__PURE__*/Object.freeze({
	        &#39;default&#39;: urlParse,
	        __moduleExports: urlParse
	    });

	    const URLParser = typeof _URLParser === &#39;function&#39; ? _URLParser : urlParse;

	    const LCHPrimitiveURLCallback = function(inputData) {
	    	if (typeof inputData !== &#39;string&#39;) {
	    		// throw new Error(&#39;LCHErrorInputNotValid&#39;);
	    		return false;
	    	}

	    	if (!(new URLParser(inputData, {})).hostname) { // To parse an input independently of the browser&#39;s current URL (e.g. for functionality parity with the library in a Node environment), pass an empty location object as the second parameter
	    		return false;
	    	}

	    	return true;
	    };

	    const LCHPrimitiveStringCanonicalExampleCallback = function() {
	    	return &#39;https://example.com&#39;;
	    };

	    const LCHPrimitiveURLRecipe = function() {
	    	return {
	    		LCHRecipeSignature: &#39;URL&#39;,
	    		LCHRecipeCallback: LCHPrimitiveURLCallback,
	    		LCHRecipeOutputType: &#39;Bool&#39;,
	    		LCHRecipeCanonicalExampleCallback: LCHPrimitiveStringCanonicalExampleCallback,
	    	};
	    };

	    var URL = /*#__PURE__*/Object.freeze({
	        LCHPrimitiveURLCallback: LCHPrimitiveURLCallback,
	        LCHPrimitiveStringCanonicalExampleCallback: LCHPrimitiveStringCanonicalExampleCallback,
	        LCHPrimitiveURLRecipe: LCHPrimitiveURLRecipe
	    });

	    const LCHPrimitiveServiceSearchURLTemplateCallback = function(inputData) {
	    	if (!LCHPrimitiveURLCallback(inputData)) {
	    		return false;
	    	}

	    	if (!inputData.match(/LCHSEARCHTOKEN/i)) {
	    		return false;
	    	}

	    	return true;
	    };

	    const LCHPrimitiveServiceSearchURLTemplateCanonicalExampleCallback = function() {
	    	return &#39;https://example.com?q=LCHSEARCHTOKEN&#39;;
	    };

	    const LCHPrimitiveServiceSearchURLTemplateRecipe = function() {
	    	return {
	    		LCHRecipeCallback: LCHPrimitiveServiceSearchURLTemplateCallback,
	    		LCHRecipeOutputType: &#39;Bool&#39;,
	    		LCHRecipeCanonicalExampleCallback: LCHPrimitiveServiceSearchURLTemplateCanonicalExampleCallback,
	    		LCHRecipeSignature: &#39;ServiceSearchURLTemplate&#39;,
	    		_LCHRecipeTypeIsExclusive: true,
	    	};
	    };

	    var ServiceSearchURLTemplate = /*#__PURE__*/Object.freeze({
	        LCHPrimitiveServiceSearchURLTemplateCallback: LCHPrimitiveServiceSearchURLTemplateCallback,
	        LCHPrimitiveServiceSearchURLTemplateCanonicalExampleCallback: LCHPrimitiveServiceSearchURLTemplateCanonicalExampleCallback,
	        LCHPrimitiveServiceSearchURLTemplateRecipe: LCHPrimitiveServiceSearchURLTemplateRecipe
	    });

	    const LCHPrimitiveStringCallback = function(inputData) {
	    	return typeof inputData === &#39;string&#39;;
	    };

	    const LCHPrimitiveStringCanonicalExampleCallback$1 = function() {
	    	return &#39;&#39;;
	    };

	    const LCHPrimitiveStringRecipe = function() {
	    	return {
	    		LCHRecipeSignature: &#39;String&#39;,
	    		LCHRecipeCallback: LCHPrimitiveStringCallback,
	    		LCHRecipeOutputType: &#39;Bool&#39;,
	    		LCHRecipeCanonicalExampleCallback: LCHPrimitiveStringCanonicalExampleCallback$1,
	    	};
	    };

	    var String$1 = /*#__PURE__*/Object.freeze({
	        LCHPrimitiveStringCallback: LCHPrimitiveStringCallback,
	        LCHPrimitiveStringCanonicalExampleCallback: LCHPrimitiveStringCanonicalExampleCallback$1,
	        LCHPrimitiveStringRecipe: LCHPrimitiveStringRecipe
	    });

	    const LCHTypeCommandCallback = function(inputData) {
	    	// if (LCHRecipesErrors(inputData)) {
	    	// 	throw new Error(&#39;LCHErrorInputNotValid&#39;);
	    	// }

	    	if (!inputData.LCHRecipeName) {
	    		return false;
	    	}
	    	
	    	if (inputData.LCHRecipeCallback.length) {
	    		return false;
	    	}

	    	return true;
	    };

	    const LCHTypeStringCanonicalExampleCallback = function() {
	    	return {
	    		LCHRecipeName: &#39;alfa&#39;,
	    		LCHRecipeCallback () {},
	    	};
	    };

	    const LCHTypeCommandRecipe = function() {
	    	return {
	    		LCHRecipeSignature: &#39;Command&#39;,
	    		LCHRecipeCallback: LCHTypeCommandCallback,
	    		LCHRecipeOutputType: &#39;Bool&#39;,
	    		LCHRecipeCanonicalExampleCallback: LCHTypeStringCanonicalExampleCallback,
	    	};
	    };

	    var Command = /*#__PURE__*/Object.freeze({
	        LCHTypeCommandCallback: LCHTypeCommandCallback,
	        LCHTypeStringCanonicalExampleCallback: LCHTypeStringCanonicalExampleCallback,
	        LCHTypeCommandRecipe: LCHTypeCommandRecipe
	    });

	    const LCHTypeSubjectContainerCallback = function(inputData) {
	    	if (!inputData.LCHRecipeName) {
	    		return false;
	    	}
	    	
	    	if (inputData.LCHRecipeOutputType !== &#39;SubjectContainer&#39;) {
	    		return false;
	    	}

	    	return true;
	    };

	    const LCHTypeSubjectContainerCanonicalExampleCallback = function() {
	    	return {
	    		LCHRecipeName: &#39;alfa&#39;,
	    		LCHRecipeCallback () {},
	    		LCHRecipeOutputType: &#39;SubjectContainer&#39;,
	    	};
	    };

	    const LCHTypeSubjectContainerRecipe = function() {
	    	return {
	    		LCHRecipeSignature: &#39;SubjectContainer&#39;,
	    		LCHRecipeCallback: LCHTypeSubjectContainerCallback,
	    		LCHRecipeOutputType: &#39;Bool&#39;,
	    		LCHRecipeCanonicalExampleCallback: LCHTypeSubjectContainerCanonicalExampleCallback,
	    		_LCHRecipeTypeIsExclusive: true,
	    	};
	    };

	    var SubjectContainer = /*#__PURE__*/Object.freeze({
	        LCHTypeSubjectContainerCallback: LCHTypeSubjectContainerCallback,
	        LCHTypeSubjectContainerCanonicalExampleCallback: LCHTypeSubjectContainerCanonicalExampleCallback,
	        LCHTypeSubjectContainerRecipe: LCHTypeSubjectContainerRecipe
	    });

	    const LCHDateLocalOffsetSubtractedCallback = function(inputData) {
	    	return new Date(Date.parse(inputData) - inputData.getTimezoneOffset() * 1000 * 60);
	    };

	    const LCHDateLocalOffsetSubtractedRecipe = function() {
	    	return {
	    		LCHRecipeSignature: &#39;LCHDateLocalOffsetSubtracted&#39;,
	    		LCHRecipeInputTypes: &#39;Date&#39;,
	    		LCHRecipeCallback: LCHDateLocalOffsetSubtractedCallback,
	    	};
	    };

	    var LCHDateLocalOffsetSubtracted = /*#__PURE__*/Object.freeze({
	        LCHDateLocalOffsetSubtractedCallback: LCHDateLocalOffsetSubtractedCallback,
	        LCHDateLocalOffsetSubtractedRecipe: LCHDateLocalOffsetSubtractedRecipe
	    });

	    const LCHReadTextFileCallback = async function(inputData = {}) {
	    	return new Promise(function (res, rej) {
	    		return Object.assign(document.createElement(&#39;input&#39;), inputData, {
	    			type: &#39;file&#39;,
	    			onchange (event) {
	    				return Object.assign(new FileReader(), {
	    					onload (event) {
	    						return res(event.target.result);
	    					},
	    				}).readAsText(event.target.files[0]);
	    			},
	    		}).click();
	    	});
	    };

	    const LCHReadTextFileRecipe = function() {
	    	return {
	    		LCHRecipeSignature: &#39;LCHReadTextFile&#39;,
	    		LCHRecipeCallback: LCHReadTextFileCallback,
	    	};
	    };

	    var LCHReadTextFile = /*#__PURE__*/Object.freeze({
	        LCHReadTextFileCallback: LCHReadTextFileCallback,
	        LCHReadTextFileRecipe: LCHReadTextFileRecipe
	    });

	    const LCHReadTextFileObjectsCallback = async function(inputData = {}) {
	    	return new Promise(function (res, rej) {
	    		return Object.assign(document.createElement(&#39;input&#39;), inputData, {
	    			type: &#39;file&#39;,
	    			onchange (event) {
	    				return res(Promise.all([...event.target.files].map(function (e) {
	    					return new Promise(function (res, rej) {
	    						return Object.assign(new FileReader(), {
	    							onload (event) {
	    								return res(Object.assign(e, {
	    									_LCHReadTextFileObjectContent: event.target.result,
	    								}));
	    							},
	    						}).readAsText(e);
	    					});
	    				})));
	    			},
	    		}).click();
	    	});
	    };

	    const LCHReadTextFileObjectsRecipe = function() {
	    	return {
	    		LCHRecipeSignature: &#39;LCHReadTextFileObjects&#39;,
	    		LCHRecipeCallback: LCHReadTextFileObjectsCallback,
	    	};
	    };

	    var LCHReadTextFileObjects = /*#__PURE__*/Object.freeze({
	        LCHReadTextFileObjectsCallback: LCHReadTextFileObjectsCallback,
	        LCHReadTextFileObjectsRecipe: LCHReadTextFileObjectsRecipe
	    });

	    var FileSaver_min = createCommonjsModule(function (module, exports) {
	    (function(a,b){b();})(commonjsGlobal$1,function(){function b(a,b){return &#34;undefined&#34;==typeof b?b={autoBom:!1}:&#34;object&#34;!=typeof b&amp;&amp;(console.warn(&#34;Deprecated: Expected third argument to be a object&#34;),b={autoBom:!b}),b.autoBom&amp;&amp;/^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(a.type)?new Blob([&#34;\uFEFF&#34;,a],{type:a.type}):a}function c(a,b,c){var d=new XMLHttpRequest;d.open(&#34;GET&#34;,a),d.responseType=&#34;blob&#34;,d.onload=function(){g(d.response,b,c);},d.onerror=function(){console.error(&#34;could not download file&#34;);},d.send();}function d(a){var b=new XMLHttpRequest;b.open(&#34;HEAD&#34;,a,!1);try{b.send();}catch(a){}return 200&lt;=b.status&amp;&amp;299&gt;=b.status}function e(a){try{a.dispatchEvent(new MouseEvent(&#34;click&#34;));}catch(c){var b=document.createEvent(&#34;MouseEvents&#34;);b.initMouseEvent(&#34;click&#34;,!0,!0,window,0,0,0,80,20,!1,!1,!1,!1,0,null),a.dispatchEvent(b);}}var f=&#34;object&#34;==typeof window&amp;&amp;window.window===window?window:&#34;object&#34;==typeof self&amp;&amp;self.self===self?self:&#34;object&#34;==typeof commonjsGlobal$1&amp;&amp;commonjsGlobal$1.global===commonjsGlobal$1?commonjsGlobal$1:void 0,a=f.navigator&amp;&amp;/Macintosh/.test(navigator.userAgent)&amp;&amp;/AppleWebKit/.test(navigator.userAgent)&amp;&amp;!/Safari/.test(navigator.userAgent),g=f.saveAs||(&#34;object&#34;!=typeof window||window!==f?function(){}:&#34;download&#34;in HTMLAnchorElement.prototype&amp;&amp;!a?function(b,g,h){var i=f.URL||f.webkitURL,j=document.createElement(&#34;a&#34;);g=g||b.name||&#34;download&#34;,j.download=g,j.rel=&#34;noopener&#34;,&#34;string&#34;==typeof b?(j.href=b,j.origin===location.origin?e(j):d(j.href)?c(b,g,h):e(j,j.target=&#34;_blank&#34;)):(j.href=i.createObjectURL(b),setTimeout(function(){i.revokeObjectURL(j.href);},4E4),setTimeout(function(){e(j);},0));}:&#34;msSaveOrOpenBlob&#34;in navigator?function(f,g,h){if(g=g||f.name||&#34;download&#34;,&#34;string&#34;!=typeof f)navigator.msSaveOrOpenBlob(b(f,h),g);else if(d(f))c(f,g,h);else{var i=document.createElement(&#34;a&#34;);i.href=f,i.target=&#34;_blank&#34;,setTimeout(function(){e(i);});}}:function(b,d,e,g){if(g=g||open(&#34;&#34;,&#34;_blank&#34;),g&amp;&amp;(g.document.title=g.document.body.innerText=&#34;downloading...&#34;),&#34;string&#34;==typeof b)return c(b,d,e);var h=&#34;application/octet-stream&#34;===b.type,i=/constructor/i.test(f.HTMLElement)||f.safari,j=/CriOS\/[\d]+/.test(navigator.userAgent);if((j||h&amp;&amp;i||a)&amp;&amp;&#34;undefined&#34;!=typeof FileReader){var k=new FileReader;k.onloadend=function(){var a=k.result;a=j?a:a.replace(/^data:[^;]*;/,&#34;data:attachment/file;&#34;),g?g.location.href=a:location=a,g=null;},k.readAsDataURL(b);}else{var l=f.URL||f.webkitURL,m=l.createObjectURL(b);g?g.location=m:location.href=m,g=null,setTimeout(function(){l.revokeObjectURL(m);},4E4);}});f.saveAs=g.saveAs=g,(module.exports=g);});


	    });

	    const LCHSaveFileCallback = function(param1, param2) {
	    	if (typeof param1 !== &#39;string&#39;) {
	    		throw new Error(&#39;LCHErrorInputNotValid&#39;);
	    	}

	    	if (typeof param2 !== &#39;string&#39;) {
	    		throw new Error(&#39;LCHErrorInputNotValid&#39;);
	    	}

	    	if (!param2.trim()) {
	    		throw new Error(&#39;LCHErrorInputNotValid&#39;);
	    	}

	    	return FileSaver_min.saveAs(new Blob([param1], {type: &#39;text/plain;charset=utf-8&#39;}), param2);
	    };

	    const LCHSaveFileRecipe = function() {
	    	return {
	    		LCHRecipeSignature: &#39;LCHSaveFile&#39;,
	    		LCHRecipeCallback: LCHSaveFileCallback,
	    	};
	    };

	    var LCHSaveFile = /*#__PURE__*/Object.freeze({
	        LCHSaveFileCallback: LCHSaveFileCallback,
	        LCHSaveFileRecipe: LCHSaveFileRecipe
	    });

	    // https://stackoverflow.com/questions/1599660/which-html-elements-can-receive-focus
	    const LCHFocusElementsSelector= [
	    	&#39;a[href]:not([tabindex=&#34;-1&#34;])&#39;,
	      // &#39;area[href]:not([tabindex=&#34;-1&#34;])&#39;,
	      &#39;input:not([disabled]):not([tabindex=&#34;-1&#34;]):not([type=&#34;hidden&#34;])&#39;,
	      // &#39;select:not([disabled]):not([tabindex=&#34;-1&#34;])&#39;,
	      // &#39;textarea:not([disabled]):not([tabindex=&#34;-1&#34;])&#39;,
	      &#39;button:not([disabled]):not([tabindex=&#34;-1&#34;])&#39;,
	      // &#39;iframe:not([tabindex=&#34;-1&#34;])&#39;,
	      // &#39;[tabindex]:not([tabindex=&#34;-1&#34;])&#39;,
	      // &#39;[contentEditable=true]:not([tabindex=&#34;-1&#34;])&#39;,
	    ].join(&#39;,&#39;);

	    const LCHActiveDocumentsFocusElements = function(inputData) {
	    	if (typeof inputData !== &#39;object&#39; || inputData === null || typeof inputData.querySelectorAll !== &#39;function&#39;) {
	    		throw new Error(&#39;LCHErrorInputNotValid&#39;);
	    	}

	    	const aggregate = {
	    		ids: {},
	    	};

	    	return [].concat.apply([], inputData.querySelectorAll(LCHFocusElementsSelector)).filter(function (e) {
	    		return {
	    			&#39;A&#39;: function FocusElementAnchorFilter (e) {
	    				if (!e.href) {
	    					return false;
	    				}				
	    				if (!e.textContent.trim() &amp;&amp; !e.title.trim()) {
	    					return false;
	    				}				
	    				return true;
	    			},
	    			&#39;INPUT&#39;: function FocusElementInputFilter (e) {
	    				if (!aggregate.labels) {
	    					aggregate.labels = Array.from(inputData.querySelectorAll(&#39;label&#39;));
	    				}
	    				aggregate.ids[e.id] = aggregate.labels.filter(function (label) {
	    					return label.getAttribute(&#39;for&#39;) === e.id;
	    				}).map(function (e) {
	    					return e.textContent.trim();
	    				}).shift();

	    				if (!e.name.trim() &amp;&amp; !e.placeholder.trim() &amp;&amp; !aggregate.ids[e.id]) {
	    					return false;
	    				}
	    				return true;
	    			},
	    			&#39;BUTTON&#39;: function FocusElementButtonFilter (e) {
	    				if (!e.textContent.trim()) {
	    					return false;
	    				}
	    				return true;
	    			}
	    		}[e.tagName](e);
	    	}).map(function (e) {
	    		return {
	    			LCHRecipeName: {
	    				&#39;A&#39;: function FocusElementAnchorNameg (e) {
	    					return e.textContent.trim() || e.title.trim()
	    				},
	    				&#39;INPUT&#39;: function FocusElementInputNameg (e) {
	    					return aggregate.ids[e.id] || e.placeholder.trim() || e.name.trim();
	    				},
	    				&#39;BUTTON&#39;: function FocusElementButtonName (e) {
	    					return e.textContent.trim();
	    				},
	    			}[e.tagName](e),
	    			LCHRecipeCallback () {
	    				return e;
	    			},
	    			LCHRecipeOutputType: &#39;DOMElement&#39;,
	    		};
	    	});
	    };

	    const LCHActiveDocumentFocusElementsCallback = function() {
	    	return LCHActiveDocumentsFocusElements(document);
	    };

	    const LCHActiveDocumentFocusElementsRecipe = function() {
	    	return {
	    		LCHRecipeSignature: &#39;LCHActiveDocumentFocusElements&#39;,
	    		LCHRecipeOutputType: &#39;SubjectContainer&#39;,
	    		LCHRecipeCallback: LCHActiveDocumentFocusElementsCallback,
	    	};
	    };

	    var LCHActiveDocumentFocusElements = /*#__PURE__*/Object.freeze({
	        LCHActiveDocumentsFocusElements: LCHActiveDocumentsFocusElements,
	        LCHActiveDocumentFocusElementsCallback: LCHActiveDocumentFocusElementsCallback,
	        LCHActiveDocumentFocusElementsRecipe: LCHActiveDocumentFocusElementsRecipe
	    });

	    const LCHCopyToClipboardCallback = function(inputData) {
	    	if (typeof inputData !== &#39;string&#39;) {
	    		throw new Error(&#39;LCHErrorInputNotValid&#39;);
	    	}

	    	if (!inputData.trim().length) {
	    		throw new Error(&#39;LCHErrorInputNotValid&#39;);
	    	}

	    	// if (typeof navigator !== &#39;undefined&#39; &amp;&amp; navigator.clipboard) {
	    	// 	return Promise.resolve((async function () {
	    	// 		return await navigator.clipboard.writeText(inputData);
	    	// 	})());
	    	// }

	    	// if (typeof document !== &#39;undefined&#39;) {
	    	// 	(function () {
	    	// 		const el = document.createElement(&#39;textarea&#39;);
	    			
	    	// 		el.value = inputData;
	    			
	    	// 		el.setAttribute(&#39;readonly&#39;, &#39;&#39;);
	    	// 		el.style.position = &#39;fixed&#39;;
	    	// 		el.style.top = 0;
	    			
	    	// 		document.body.appendChild(el);
	    	// 		el.select();
	    	// 		document.execCommand(&#39;copy&#39;);
	    			
	    	// 		el.remove();
	    	// 	})();
	    	// }

	    	return {
	    		LCHComponentDescriptorName: &#39;LCHCopyToClipboard&#39;,
	    		LCHComponentDescriptorProps: {
	    			inputData: inputData,
	    		},
	    		LCHComponentDescriptorCompletionHandlerSignature: &#39;LCHCopyToClipboardCompletionHandler&#39;,
	    		LCHComponentDescriptorOLSKLocalized: true,
	    	};
	    };

	    const LCHCopyToClipboardRecipe = function() {
	    	return {
	    		LCHRecipeSignature: &#39;LCHCopyToClipboard&#39;,
	    		LCHRecipeInputTypes: &#39;String&#39;,
	    		LCHRecipeCallback: LCHCopyToClipboardCallback,
	    	};
	    };

	    var LCHCopyToClipboard = /*#__PURE__*/Object.freeze({
	        LCHCopyToClipboardCallback: LCHCopyToClipboardCallback,
	        LCHCopyToClipboardRecipe: LCHCopyToClipboardRecipe
	    });

	    const LCHDOMElementFocusCallback = function(inputData) {
	    	if (!inputData) {
	    		return;
	    	}

	    	inputData.focus();
	    };

	    const LCHDOMElementFocusRecipe = function() {
	    	return {
	    		LCHRecipeSignature: &#39;LCHDOMElementFocus&#39;,
	    		LCHRecipeInputTypes: &#39;DOMElement&#39;,
	    		LCHRecipeCallback: LCHDOMElementFocusCallback,
	    	};
	    };

	    var LCHDOMElementFocus = /*#__PURE__*/Object.freeze({
	        LCHDOMElementFocusCallback: LCHDOMElementFocusCallback,
	        LCHDOMElementFocusRecipe: LCHDOMElementFocusRecipe
	    });

	    const LCHLargeTextCallback = function(inputData) {
	    	if (typeof document === &#39;undefined&#39;) {
	    		return;
	    	}

	    	const rootElement = document.createElement(&#39;div&#39;);
	    	rootElement.className = &#39;LCHLargeTextContainer&#39;;

	    	for (let [key, value] of Object.entries({
	    		width: &#39;100%&#39;,

	    		position: &#39;fixed&#39;,
	    		top: &#39;45%&#39;,
	    		left: &#39;0&#39;,

	    		textAlign: &#39;center&#39;,

	    		cursor: &#39;default&#39;,
	    	})) {
	    		rootElement.style[key] = value;
	    	}

	    	const span = document.createElement(&#39;span&#39;);
	    	span.textContent = inputData;
	    	rootElement.appendChild(span);

	    	for (let [key, value] of Object.entries({
	    		display: &#39;block-inline&#39;,
	    		borderRadius: &#39;20px&#39;,
	    		boxShadow: &#39;0 0 10px 0px hsla(0, 0%, 0%, 0.1)&#39;,
	    		padding: &#39;20px&#39;,

	    		background: &#39;hsla(0, 0%, 0%, 0.8)&#39;,
	    		color: &#39;white&#39;,
	    		fontFamily: &#39;Arial&#39;,
	    		fontSize: &#39;72pt&#39;,
	    		fontWeight: &#39;bold&#39;,
	    		textAlign: &#39;center&#39;,
	    		textShadow: &#39;5px 5px 10px hsla(0, 0%, 0%, 0.5)&#39;,
	    		overflowWrap: &#39;break-word&#39;,
	    	})) {
	    		span.style[key] = value;
	    	}
	    	
	    	document.body.appendChild(rootElement);

	    	let handler = function (event) {
	    		event.preventDefault();

	    		if (!event.key &amp;&amp; rootElement.contains(event.target)) {
	    	  	return;
	    		}
	    		
	    		window.removeEventListener(&#39;click&#39;, handler);
	    		window.removeEventListener(&#39;keydown&#39;, handler);
	    		
	    		rootElement.remove();
	    	};

	    	setTimeout(function () {
	    		window.addEventListener(&#39;click&#39;, handler);
	    		window.addEventListener(&#39;keydown&#39;, handler);
	    	});
	    };

	    const LCHLargeTextRecipe = function() {
	    	return {
	    		LCHRecipeSignature: &#39;LCHLargeText&#39;,
	    		LCHRecipeInputTypes: &#39;String&#39;,
	    		LCHRecipeCallback: LCHLargeTextCallback,
	    	};
	    };

	    var LCHLargeText = /*#__PURE__*/Object.freeze({
	        LCHLargeTextCallback: LCHLargeTextCallback,
	        LCHLargeTextRecipe: LCHLargeTextRecipe
	    });

	    const LCHRunCommandCallback = function(inputData) {
	    	return inputData;
	    };

	    const LCHRunCommandRecipe = function() {
	    	return {
	    		LCHRecipeSignature: &#39;LCHRunCommand&#39;,
	    		LCHRecipeInputTypes: &#39;Command&#39;,
	    		LCHRecipeCallback: LCHRunCommandCallback,
	    	};
	    };

	    var LCHRunCommand = /*#__PURE__*/Object.freeze({
	        LCHRunCommandCallback: LCHRunCommandCallback,
	        LCHRunCommandRecipe: LCHRunCommandRecipe
	    });

	    const LCHFlip = function(param1, param2) {
	    	if (typeof param1 !== &#39;function&#39;) {
	    		throw new Error(&#39;LCHErrorInputNotValid&#39;);
	    	}

	    	return function() {
	    		return param1.apply(param2, [...arguments].reverse());
	    	};
	    };

	    const LCHSearchActionURLFrom = function(param1, param2) {
	    	if (typeof param1 !== &#39;string&#39;) {
	    		throw new Error(&#39;LCHErrorInputNotValid&#39;);
	    	}

	    	if (typeof param2 !== &#39;string&#39;) {
	    		throw new Error(&#39;LCHErrorInputNotValid&#39;);
	    	}

	    	if (!param1.match(/LCHSEARCHTOKEN/i)) {
	    		return param1;
	    	}

	    	return param1.replace(/LCHSEARCHTOKEN/i, param2.split(&#39; &#39;).map(function (e) {
	    		return encodeURIComponent(e);
	    	}).join(&#39;+&#39;));
	    };

	    const LCHSearchWithCallback = function(param1, param2) {
	    	return this.api.fn(&#39;LCHURLOpen&#39;)(LCHSearchActionURLFrom(param2, param1));
	    };

	    const LCHSearchWithRecipe = function() {
	    	return {
	    		LCHRecipeSignature: &#39;LCHSearchWith&#39;,
	    		LCHRecipeInputTypes: &#39;String,ServiceSearchURLTemplate&#39;,
	    		LCHRecipeCallback: LCHSearchWithCallback,
	    	};
	    };
	    const LCHSearchForCallback = function() {
	    	return LCHFlip(LCHSearchWithCallback, this)(...arguments);
	    };

	    const LCHSearchForRecipe = function() {
	    	return {
	    		LCHRecipeSignature: &#39;LCHSearchFor&#39;,
	    		LCHRecipeInputTypes: &#39;ServiceSearchURLTemplate,String&#39;,
	    		LCHRecipeCallback: LCHSearchForCallback,
	    	};
	    };

	    var LCHSearchAction = /*#__PURE__*/Object.freeze({
	        LCHSearchActionURLFrom: LCHSearchActionURLFrom,
	        LCHSearchWithCallback: LCHSearchWithCallback,
	        LCHSearchWithRecipe: LCHSearchWithRecipe,
	        LCHSearchForCallback: LCHSearchForCallback,
	        LCHSearchForRecipe: LCHSearchForRecipe
	    });

	    const LCHServiceSearchWikipediaCallback = function() {
	    	return &#39;https://wikipedia.org/w/index.php?search=LCHSEARCHTOKEN&#39;;
	    };

	    const LCHServiceSearchWikipediaRecipe = function() {
	    	return {
	    		LCHRecipeName: &#39;Wikipedia&#39;,
	    		LCHRecipeOutputType: &#39;ServiceSearchURLTemplate&#39;,
	    		LCHRecipeCallback: LCHServiceSearchWikipediaCallback,
	    		LCHRecipeSignature: &#39;LCHServiceSearchWikipedia&#39;,
	    	};
	    };

	    var LCHServiceSearchWikipedia = /*#__PURE__*/Object.freeze({
	        LCHServiceSearchWikipediaCallback: LCHServiceSearchWikipediaCallback,
	        LCHServiceSearchWikipediaRecipe: LCHServiceSearchWikipediaRecipe
	    });

	    const LCHSubjectContainerShowContentsCallback = function(inputData) {
	    	return inputData;
	    };

	    const LCHSubjectContainerShowContentsRecipe = function() {
	    	return {
	    		LCHRecipeSignature: &#39;LCHSubjectContainerShowContents&#39;,
	    		LCHRecipeInputTypes: &#39;SubjectContainer&#39;,
	    		LCHRecipeCallback: LCHSubjectContainerShowContentsCallback,
	    	};
	    };

	    var LCHSubjectContainerShowContents = /*#__PURE__*/Object.freeze({
	        LCHSubjectContainerShowContentsCallback: LCHSubjectContainerShowContentsCallback,
	        LCHSubjectContainerShowContentsRecipe: LCHSubjectContainerShowContentsRecipe
	    });

	    const LCHURLOpenCallback = function(inputData) {
	    	if (!inputData) {
	    		return;
	    	}

	    	window.open(inputData, &#39;_blank&#39;).focus();
	    };

	    const LCHURLOpenRecipe = function() {
	    	return {
	    		LCHRecipeSignature: &#39;LCHURLOpen&#39;,
	    		LCHRecipeInputTypes: &#39;URL&#39;,
	    		LCHRecipeCallback: LCHURLOpenCallback,
	    	};
	    };

	    var LCHURLOpen = /*#__PURE__*/Object.freeze({
	        LCHURLOpenCallback: LCHURLOpenCallback,
	        LCHURLOpenRecipe: LCHURLOpenRecipe
	    });

	    const LCHLauncherStandardRecipes = function() {
	    	return [].concat.apply([], [
	    		Bool,
	    		Date$1,
	    		DOMElement,
	    		ServiceSearchURLTemplate,
	    		String$1,
	    		URL,
	    		
	    		Command,
	    		ServiceSearch,
	    		SubjectContainer,
	    		
	    		LCHActiveDocumentFocusElements,

	    		LCHDateLocalOffsetSubtracted,
	    		LCHReadTextFile,
	    		LCHReadTextFileObjects,
	    		LCHSaveFile,

	    		LCHCopyToClipboard,
	    		LCHDOMElementFocus,
	    		LCHLargeText,
	    		LCHRunCommand,
	    		LCHSearchAction,
	    		LCHServiceSearchWikipedia,
	    		LCHSubjectContainerShowContents,
	    		LCHURLOpen,
	    	].map(function (e) {
	    		return Object.entries(e).filter(function (e) {
	    			return e.shift().includes(&#39;Recipe&#39;);
	    		}).map(function (e) {
	    			return e.pop()();
	    		}).map(function (e) {
	    			return e;
	    		});
	    	}));
	    };

	    Array.prototype._LCHIntersect = function() {
	    	return this.map(function (e) {
	    		return new Set(e);
	    	}).reduce(function (a, b) {
	    		return a.filter(i =&gt; b.has(i));
	    	}, [...new Set([].concat.apply([], this))]);
	    };

	    const mod$2 = {

	    	LCHRecipesErrors (inputData, options = {}) {
	    		if (typeof inputData !== &#39;object&#39; || inputData === null) {
	    			throw new Error(&#39;LCHErrorInputNotValid&#39;);
	    		}

	    		const errors = mod.LCHFormulaTo(mod.LCHFormulaErrors(mod.LCHFormulaFrom(inputData)) || {}, &#39;LCHRecipe&#39;);

	    		if (typeof inputData.LCHRecipeCallback !== &#39;function&#39;) {
	    			errors.LCHRecipeCallback = [
	    				&#39;LCHErrorNotFunction&#39;,
	    			];
	    		}

	    		if (typeof inputData.LCHRecipeName === &#39;string&#39;) {
	    			if (!inputData.LCHRecipeName.trim()) {
	    				errors.LCHRecipeName = [
	    					&#39;LCHErrorNotFilled&#39;,
	    				];
	    			}
	    		}

	    		if (typeof inputData.LCHRecipeInputTypes === &#39;string&#39;) {
	    			if (inputData.LCHRecipeInputTypes.trim() !== inputData.LCHRecipeInputTypes) {
	    				errors.LCHRecipeInputTypes = [
	    					&#39;LCHErrorNotTrimmed&#39;,
	    				];
	    			}

	    			if (!inputData.LCHRecipeInputTypes.trim()) {
	    				errors.LCHRecipeInputTypes = [
	    					&#39;LCHErrorNotFilled&#39;,
	    				];
	    			}
	    		}

	    		if (typeof inputData.LCHRecipeOutputType === &#39;string&#39;) {
	    			if (inputData.LCHRecipeOutputType.trim() !== inputData.LCHRecipeOutputType) {
	    				errors.LCHRecipeOutputType = [
	    					&#39;LCHErrorNotTrimmed&#39;,
	    				];
	    			}

	    			if (!inputData.LCHRecipeOutputType.trim()) {
	    				errors.LCHRecipeOutputType = [
	    					&#39;LCHErrorNotFilled&#39;,
	    				];
	    			}
	    		}

	    		if (inputData.LCHRecipeCanonicalExampleCallback !== undefined || options.LCHOptionValidateIfNotPresent) {
	    			if (typeof inputData.LCHRecipeCanonicalExampleCallback !== &#39;function&#39;) {
	    				errors.LCHRecipeCanonicalExampleCallback = [
	    					&#39;LCHErrorNotFunction&#39;,
	    				];
	    			}
	    		}

	    		if (typeof inputData.LCHRecipeSignature === &#39;string&#39;) {
	    			if (!inputData.LCHRecipeSignature.trim()) {
	    				errors.LCHRecipeSignature = [
	    					&#39;LCHErrorNotFilled&#39;,
	    				];
	    			} else if (inputData.LCHRecipeSignature.trim() !== inputData.LCHRecipeSignature) {
	    				errors.LCHRecipeSignature = [
	    					&#39;LCHErrorNotTrimmed&#39;,
	    				];
	    			}
	    		}

	    		return Object.entries(errors).length ? errors : null;
	    	},

	    	LCHRecipesIsCommand (inputData) {
	    		if (mod$2.LCHRecipesErrors(inputData)) {
	    			throw new Error(&#39;LCHErrorInputNotValid&#39;);
	    		}

	    		if (!inputData.LCHRecipeName) {
	    			return false;
	    		}
	    		
	    		if (inputData.LCHRecipeInputTypes) {
	    			return false;
	    		}

	    		if (inputData.LCHRecipeOutputType) {
	    			return false;
	    		}

	    		return true;
	    	},

	    	LCHRecipesIsSubject (inputData) {
	    		if (mod$2.LCHRecipesErrors(inputData)) {
	    			throw new Error(&#39;LCHErrorInputNotValid&#39;);
	    		}

	    		if (!inputData.LCHRecipeName) {
	    			return false;
	    		}
	    		
	    		// if (inputData.LCHRecipeInputTypes) {
	    		// 	return false;
	    		// }

	    		if (!inputData.LCHRecipeOutputType) {
	    			return false;
	    		}

	    		return true;
	    	},

	    	LCHRecipesIsAction (inputData) {
	    		if (mod$2.LCHRecipesErrors(inputData)) {
	    			throw new Error(&#39;LCHErrorInputNotValid&#39;);
	    		}

	    		if (!inputData.LCHRecipeName) {
	    			return false;
	    		}

	    		if (!inputData.LCHRecipeInputTypes) {
	    			return false;
	    		}
	    		
	    		// if (!inputData.LCHRecipeCallback.length) {
	    		// 	return false;
	    		// }

	    		return true;
	    	},

	    	LCHRecipesIsType (inputData) {
	    		if (mod$2.LCHRecipesErrors(inputData)) {
	    			throw new Error(&#39;LCHErrorInputNotValid&#39;);
	    		}
	    		
	    		// if (inputData.LCHRecipeCallback.length !== 1) {
	    		// 	return false;
	    		// }

	    		if (inputData.LCHRecipeOutputType !== &#39;Bool&#39;) {
	    			return false;
	    		}

	    		if (!inputData.LCHRecipeCanonicalExampleCallback) {
	    			return false;
	    		}

	    		if (!inputData.LCHRecipeSignature) {
	    			return false;
	    		}

	    		return true;
	    	},

	    	LCHRecipesIsTask (inputData) {
	    		if (mod$2.LCHRecipesErrors(inputData)) {
	    			throw new Error(&#39;LCHErrorInputNotValid&#39;);
	    		}
	    		
	    		// if (inputData.LCHRecipeCallback.length) {
	    		// 	return false;
	    		// }

	    		if (!inputData.LCHRecipeURLFilter) {
	    			return false;
	    		}

	    		if (inputData.LCHRecipeIsAutomatic !== true) {
	    			return false;
	    		}

	    		return true;
	    	},

	    	LCHLauncherConvertTypeServiceSearch (inputData, _stringCallback) {
	    		if (!Array.isArray(inputData)) {
	    			throw new Error(&#39;LCHErrorInputNotValid&#39;);
	    		}

	    		return inputData.filter(function (e) {
	    			if (typeof e !== &#39;object&#39; || e === null) {
	    				return false;
	    			}
	    			
	    			return true;
	    		}).map(function (e) {
	    			if (!LCHTypeServiceSearchRecipe().LCHRecipeCallback(e)) {
	    				return e;
	    			}

	    			return {
	    				LCHRecipeName: _stringCallback(e.LCHRecipeName),
	    				LCHRecipeInputTypes: &#39;String&#39;,
	    				LCHRecipeCallback (inputData) {
	    					return this.api.fn(&#39;LCHSearchWith&#39;)(inputData, e);
	    				},
	    				_LCHLauncherGenerated: true,
	    			};
	    		});
	    	},

	    	LCHRecipesActionTakesObject (inputData) {
	    		if (mod$2.LCHRecipesErrors(inputData)) {
	    			throw new Error(&#39;LCHErrorInputNotValid&#39;);
	    		}

	    		if (!mod$2.LCHRecipesIsAction(inputData)) {
	    			throw new Error(&#39;LCHErrorInputNotValid&#39;);
	    		}
	    		
	    		if (mod$1.LCHRuntimeInputTypes(inputData.LCHRecipeInputTypes).length &lt; 2) {
	    			return false;
	    		}
	    		
	    		// if (inputData.LCHRecipeCallback.length &lt; 2) {
	    		// 	return false;
	    		// }

	    		return true;
	    	},

	    	LCHRecipesActionTakesParams (inputData) {
	    		if (mod$2.LCHRecipesErrors(inputData)) {
	    			throw new Error(&#39;LCHErrorInputNotValid&#39;);
	    		}

	    		if (!mod$2.LCHRecipesIsAction(inputData)) {
	    			throw new Error(&#39;LCHErrorInputNotValid&#39;);
	    		}
	    		
	    		if (mod$1.LCHRuntimeInputTypes(inputData.LCHRecipeInputTypes).pop() !== &#39;Object&#39;) {
	    			return false;
	    		}
	    		
	    		// if (inputData.LCHRecipeCallback.length !== LCHRuntime.LCHRuntimeInputTypes(inputData.LCHRecipeInputTypes).length) {
	    		// 	return false;
	    		// }

	    		return true;
	    	},

	    	LCHAPITypeEquivalenceMapForRecipes (inputData) {
	    		if (!Array.isArray(inputData)) {
	    			throw new Error(&#39;LCHErrorInputNotValid&#39;);
	    		}

	    		const uniqueSignatures = [];
	    		const validRecipes = inputData.filter(function (e) {
	    			if (mod$2.LCHRecipesErrors(e)) {
	    				return false;
	    			}

	    			if (!mod$2.LCHRecipesIsType(e)) {
	    				return false;
	    			}

	    			if (!e.LCHRecipeCallback(e.LCHRecipeCanonicalExampleCallback())) {
	    				return false;
	    			}

	    			if (uniqueSignatures.includes(e.LCHRecipeSignature)) {
	    				return false;
	    			}

	    			uniqueSignatures.push(e.LCHRecipeSignature);

	    			return true;
	    		});

	    		return validRecipes.reduce(function (coll, item) {
	    			coll[item.LCHRecipeSignature] = validRecipes.filter(function (e) {
	    				if (item === e) {
	    					return true;
	    				}

	    				if (e._LCHRecipeTypeIsExclusive) {
	    					return false;
	    				}

	    				if (item._LCHRecipeTypeIsExclusive) {
	    					return false;
	    				}

	    				return e.LCHRecipeCallback(item.LCHRecipeCanonicalExampleCallback());
	    			}).map(function (e) {
	    				return e.LCHRecipeSignature;
	    			});

	    			return coll;
	    		}, {});
	    	},

	    	LCHAPITypeNameMap (inputData) {
	    		if (!Array.isArray(inputData)) {
	    			throw new Error(&#39;LCHErrorInputNotValid&#39;);
	    		}

	    		const validRecipes = inputData.filter(function (e) {
	    			if (mod$2.LCHRecipesErrors(e)) {
	    				return false;
	    			}

	    			return mod$2.LCHRecipesIsType(e);
	    		});

	    		return validRecipes.reduce(function (coll, item) {
	    			if (coll[item.LCHRecipeSignature]) {
	    				return coll;
	    			}

	    			coll[item.LCHRecipeSignature] = item.LCHRecipeName || item.LCHRecipeSignature;

	    			return coll;
	    		}, {});
	    	},

	    	LCHAPIActionsForType (param1, param2) {
	    		if (typeof param1 !== &#39;string&#39;) {
	    			throw new Error(&#39;LCHErrorInputNotValid&#39;);
	    		}

	    		if (!Array.isArray(param2)) {
	    			throw new Error(&#39;LCHErrorInputNotValid&#39;);
	    		}

	    		return param2.filter(function (e) {
	    			if (mod$2.LCHRecipesErrors(e)) {
	    				return false;
	    			}

	    			if (!mod$2.LCHRecipesIsAction(e)) {
	    				return false;
	    			}

	    			if (mod$1.LCHRuntimeInputTypes(e.LCHRecipeInputTypes).shift() !== param1) {
	    				return false;
	    			}

	    			return true;
	    		});
	    	},

	    	LCHAPISubjectsForType (param1, param2) {
	    		if (typeof param1 !== &#39;string&#39;) {
	    			throw new Error(&#39;LCHErrorInputNotValid&#39;);
	    		}

	    		if (!Array.isArray(param2)) {
	    			throw new Error(&#39;LCHErrorInputNotValid&#39;);
	    		}

	    		return param2.filter(function (e) {
	    			if (mod$2.LCHRecipesErrors(e)) {
	    				return false;
	    			}

	    			if (!mod$2.LCHRecipesIsSubject(e)) {
	    				return false;
	    			}

	    			if (e.LCHRecipeOutputType !== param1) {
	    				return false;
	    			}

	    			return true;
	    		});
	    	},

	    	LCHCompositionErrors (inputData) {
	    		if (typeof inputData !== &#39;object&#39; || inputData === null) {
	    			throw new Error(&#39;LCHErrorInputNotValid&#39;);
	    		}

	    		if (!inputData.LCHCompositionAction) {
	    			return {
	    				LCHCompositionAction: [
	    					&#39;LCHErrorInputNotPresent&#39;,
	    				],
	    			};
	    		}

	    		if (!mod$2.LCHRecipesIsAction(inputData.LCHCompositionAction)) {
	    			return {
	    				LCHCompositionAction: [
	    					&#39;LCHErrorInputNotValid&#39;,
	    				],
	    			};
	    		}

	    		const errors = {};

	    		if (!inputData.LCHCompositionSubjectPrimary) {
	    			return {
	    				LCHCompositionSubjectPrimary: [
	    					&#39;LCHErrorInputNotPresent&#39;,
	    				],
	    			};
	    		} else if (inputData.LCHCompositionAction.LCHRecipeInputTypes === &#39;Command&#39; &amp;&amp; mod$2.LCHRecipesIsCommand(inputData.LCHCompositionSubjectPrimary)) ;

	    		// if (!mod.LCHRecipesIsSubject(inputData.LCHCompositionSubjectPrimary)) {
	    		// 	errors.LCHCompositionSubjectPrimary = [
	    		// 		&#39;LCHErrorInputNotValid&#39;,
	    		// 	];
	    		// }

	    		else if (inputData.LCHCompositionAction.LCHRecipeInputTypes &amp;&amp; !mod$1.LCHRuntimeInputTypes(inputData.LCHCompositionAction.LCHRecipeInputTypes).includes(inputData.LCHCompositionSubjectPrimary.LCHRecipeOutputType)) {
	    			errors.LCHCompositionSubjectPrimary = [
	    				&#39;LCHErrorInputNotValid&#39;,
	    			];
	    		}

	    		if (inputData.LCHCompositionAction.LCHRecipeInputTypes &amp;&amp; mod$1.LCHRuntimeInputTypes(inputData.LCHCompositionAction.LCHRecipeInputTypes).length === 2 &amp;&amp; !inputData.LCHCompositionSubjectSecondary) {
	    			errors.LCHCompositionSubjectSecondary = [
	    				&#39;LCHErrorInputNotValid&#39;,
	    			];
	    		}

	    		if (inputData.LCHCompositionSubjectSecondary !== undefined) {
	    			if (!mod$2.LCHRecipesIsSubject(inputData.LCHCompositionSubjectSecondary)) {
	    				errors.LCHCompositionSubjectSecondary = [
	    					&#39;LCHErrorInputNotValid&#39;,
	    				];
	    			}

	    			if (inputData.LCHCompositionAction.LCHRecipeInputTypes &amp;&amp; !mod$1.LCHRuntimeInputTypes(inputData.LCHCompositionAction.LCHRecipeInputTypes).includes(inputData.LCHCompositionSubjectSecondary.LCHRecipeOutputType)) {
	    				errors.LCHCompositionSubjectSecondary = [
	    					&#39;LCHErrorInputNotValid&#39;,
	    				];
	    			}
	    		}

	    		return Object.entries(errors).length ? errors : null;
	    	},

	    	async LCHAPIExecuteComposition (inputData, api = {}) {
	    		if (mod$2.LCHCompositionErrors(inputData)) {
	    			throw new Error(&#39;LCHErrorInputNotValid&#39;);
	    		}

	    		if (typeof api.fn !== &#39;function&#39;) {
	    			throw new Error(&#39;LCHErrorInputNotValid&#39;);
	    		}

	    		return mod$2.LCHAPIExecuteRecipe(inputData.LCHCompositionAction, [
	    			await mod$2.LCHAPIExecuteRecipe(inputData.LCHCompositionSubjectPrimary, [], api),
	    		].concat(inputData.LCHCompositionSubjectSecondary ? [
	    			await mod$2.LCHAPIExecuteRecipe(inputData.LCHCompositionSubjectSecondary, [], api),
	    		] : []), api);
	    	},

	    	async LCHAPIExecuteRecipe (param1, param2 = [], param3 = {}) {
	    		if (mod$2.LCHRecipesErrors(param1)) {
	    			throw new Error(&#39;LCHErrorInputNotValid&#39;);
	    		}

	    		if (!Array.isArray(param2)) {
	    			throw new Error(&#39;LCHErrorInputNotValid&#39;);
	    		}

	    		if (typeof param3.fn !== &#39;function&#39;) {
	    			throw new Error(&#39;LCHErrorInputNotValid&#39;);
	    		}

	    		if (param1.LCHRecipeStyle &amp;&amp; typeof document !== &#39;undefined&#39;) {
	    			document.body.appendChild(document.createElement(&#39;style&#39;)).innerHTML = param1.LCHRecipeStyle;
	    		}

	    		return Promise.resolve(param1.LCHRecipeCallback.apply({
	    			api: param3,
	    		}, param2.length ? param2 : undefined)); // #mysterious Firefox throws `Permission denied to access property &#34;length&#34;` if array is empty
	    	},

	    	LCHComponentDescriptorsErrors (inputData) {
	    		if (typeof inputData !== &#39;object&#39; || inputData === null) {
	    			throw new Error(&#39;LCHErrorInputNotValid&#39;);
	    		}

	    		const errors = {};

	    		if (typeof inputData.LCHComponentDescriptorName !== &#39;string&#39;) {
	    			errors.LCHComponentDescriptorName = [
	    				&#39;LCHErrorNotString&#39;,
	    			];
	    		}

	    		if (typeof inputData.LCHComponentDescriptorName === &#39;string&#39; &amp;&amp; !inputData.LCHComponentDescriptorName) {
	    			errors.LCHComponentDescriptorName = [
	    				&#39;LCHErrorNotFilled&#39;,
	    			];
	    		}

	    		if (typeof inputData.LCHComponentDescriptorName === &#39;string&#39; &amp;&amp; inputData.LCHComponentDescriptorName.trim() !== inputData.LCHComponentDescriptorName) {
	    			errors.LCHComponentDescriptorName = [
	    				&#39;LCHErrorNotTrimmed&#39;,
	    			];
	    		}

	    		if (typeof inputData.LCHComponentDescriptorCompletionHandlerSignature !== &#39;string&#39;) {
	    			errors.LCHComponentDescriptorCompletionHandlerSignature = [
	    				&#39;LCHErrorNotString&#39;,
	    			];
	    		}

	    		if (typeof inputData.LCHComponentDescriptorCompletionHandlerSignature === &#39;string&#39; &amp;&amp; !inputData.LCHComponentDescriptorCompletionHandlerSignature) {
	    			errors.LCHComponentDescriptorCompletionHandlerSignature = [
	    				&#39;LCHErrorNotFilled&#39;,
	    			];
	    		}

	    		if (typeof inputData.LCHComponentDescriptorCompletionHandlerSignature === &#39;string&#39; &amp;&amp; inputData.LCHComponentDescriptorCompletionHandlerSignature.trim() !== inputData.LCHComponentDescriptorCompletionHandlerSignature) {
	    			errors.LCHComponentDescriptorCompletionHandlerSignature = [
	    				&#39;LCHErrorNotTrimmed&#39;,
	    			];
	    		}

	    		if (inputData.LCHComponentDescriptorProps !== undefined) {
	    			if (typeof inputData.LCHComponentDescriptorProps !== &#39;object&#39; || inputData.LCHComponentDescriptorProps === null) {
	    				errors.LCHComponentDescriptorProps = [
	    					&#39;LCHErrorNotObject&#39;,
	    				];
	    			}
	    		}

	    		return Object.entries(errors).length ? errors : null;
	    	},

	    	LCHRuntimeFilteredRecipes  (param1, param2) {
	    		if (!Array.isArray(param1)) {
	    			throw new Error(&#39;LCHErrorInputNotValid&#39;);
	    		}

	    		if (typeof param2 !== &#39;string&#39;) {
	    			throw new Error(&#39;LCHErrorInputNotValid&#39;);
	    		}

	    		return param1.filter(function (e) {
	    			if (mod$2.LCHRecipesErrors(e)) {
	    				return false;
	    			}

	    			if (typeof e.LCHRecipeURLFilter === &#39;undefined&#39;) {
	    				return true;
	    			}

	    			return mod$1.LCHRuntimeURLFilter(e.LCHRecipeURLFilter, param2);
	    		});
	    	},

	    	LCHRuntimeFilteredTasks  (inputData) {
	    		if (!Array.isArray(inputData)) {
	    			throw new Error(&#39;LCHErrorInputNotValid&#39;);
	    		}

	    		return inputData.filter(function (e) {
	    			if (!mod$2.LCHRecipesIsTask(e)) {
	    				return false;
	    			}

	    			if (e.LCHRecipeIsExcluded) {
	    				return !e.LCHRecipeIsExcluded();
	    			}

	    			return true;
	    		});
	    	},

	    	LCHAPIRunTasks  () {
	    		const inputData = mod$2.LCHRuntimeFilteredRecipes.apply(null, [...arguments]);
	    		const api = mod$1.LCHRuntimeAPI(LCHLauncherStandardRecipes().concat(inputData));

	    		return Promise.all(mod$2.LCHRuntimeFilteredTasks(inputData).map(function (e) {
	    			return mod$2.LCHAPIExecuteRecipe(e, [], api);
	    		}));
	    	},

	    	LCHRecipeProxyErrors (inputData, options = {}) {
	    		if (typeof inputData !== &#39;object&#39; || inputData === null) {
	    			return {};
	    		}

	    		const errors = {};

	    		if (typeof inputData.LCHRecipeProxyName !== &#39;string&#39;) {
	    			errors.LCHRecipeProxyName = [
	    				&#39;LCHErrorNotString&#39;,
	    			];
	    		}

	    		if (typeof inputData.LCHRecipeProxySignature !== &#39;string&#39;) {
	    			errors.LCHRecipeProxySignature = [
	    				&#39;LCHErrorNotString&#39;,
	    			];
	    		}

	    		return Object.entries(errors).length ? errors : null;
	    	},

	    };

	    const mod$3 = {

	    	LCHLauncherOptions (inputData, notify = function () {}) {
	    		if (typeof inputData !== &#39;object&#39; || inputData === null) {
	    			throw new Error(&#39;LCHErrorInputNotValid&#39;);
	    		}

	    		if (typeof inputData.LCHOptionRecipes === &#39;undefined&#39;) {
	    			inputData.LCHOptionRecipes = [];
	    		}
	    		if (!Array.isArray(inputData.LCHOptionRecipes)) {
	    			throw new Error(&#39;LCHOptionRecipesNotArray&#39;);
	    		}
	    		inputData.LCHOptionRecipes = inputData.LCHOptionRecipes.filter(function (e) {
	    			const errors = mod$2.LCHRecipesErrors(e);

	    			if (errors) {
	    				notify(&#39;LCHOptionRecipesItemNotValid&#39;, e, errors);
	    			}
	    			return !errors;
	    		});

	    		if (typeof inputData.LCHOptionMode === &#39;undefined&#39;) {
	    			inputData.LCHOptionMode = mod$3.LCHLauncherModes().shift();
	    		}
	    		if (typeof inputData.LCHOptionMode !== &#39;undefined&#39;) {
	    			if (!mod$3.LCHLauncherModes().includes(inputData.LCHOptionMode)) {
	    				throw new Error(&#39;LCHOptionModeNotValid&#39;);
	    			}		}
	    		if (typeof inputData.LCHOptionCompletionHandler !== &#39;undefined&#39;) {
	    			if (typeof inputData.LCHOptionCompletionHandler !== &#39;function&#39;) {
	    				throw new Error(&#39;LCHOptionCompletionHandlerNotFunction&#39;);
	    			}		}
	    		if (typeof inputData.LCHOptionLanguage === &#39;undefined&#39;) {
	    			inputData.LCHOptionLanguage = &#39;en&#39;;
	    		}
	    		if (typeof inputData.LCHOptionLanguage !== &#39;string&#39;) {
	    			throw new Error(&#39;LCHOptionLanguageNotString&#39;)
	    		}
	    		return inputData;
	    	},

	    	LCHLauncherModeCommit () {
	    		return &#39;kLCHLauncherModeCommit&#39;;
	    	},

	    	LCHLauncherModePreview () {
	    		return &#39;kLCHLauncherModePreview&#39;;
	    	},

	    	LCHLauncherModePipe () {
	    		return &#39;kLCHLauncherModePipe&#39;;
	    	},

	    	LCHLauncherModeTask () {
	    		return &#39;kLCHLauncherModeTask&#39;;
	    	},

	    	LCHLauncherModes () {
	    		return [
	    			mod$3.LCHLauncherModeCommit(),
	    			mod$3.LCHLauncherModePreview(),
	    			mod$3.LCHLauncherModePipe(),
	    			mod$3.LCHLauncherModeTask(),
	    		];
	    	},

	    	LCHLauncherUIRecipesForMode (param1, param2) {
	    		if (!Array.isArray(param1)) {
	    			throw new Error(&#39;LCHErrorInputNotValid&#39;);
	    		}

	    		if (!mod$3.LCHLauncherModes().includes(param2)) {
	    			throw new Error(&#39;LCHErrorInputNotValid&#39;);
	    		}

	    		return param1.filter(function (e) {
	    			if (typeof e !== &#39;object&#39; || e === null) {
	    				return false;
	    			}

	    			if (typeof e.LCHRecipeInputTypes === &#39;string&#39; &amp;&amp; e.LCHRecipeInputTypes.split(&#39;,&#39;).length &gt; 2) {
	    				return false;
	    			}

	    			if (param2 === mod$3.LCHLauncherModeCommit()) {
	    				return mod$2.LCHRecipesIsCommand(e);
	    				// if (LCHLauncherAPI.LCHRecipesIsCommand(e)) {
	    				// 	return true;
	    				// };

	    				// if (!LCHLauncherAPI.LCHRecipesIsAction(e)) {
	    				// 	return false;
	    				// };

	    				// if (e.LCHRecipeCallback.length !== 1) {
	    				// 	return false;
	    				// };

	    				// if (e.LCHRecipeInputTypes !== &#39;String&#39;) {
	    				// 	return false;
	    				// };

	    				// if (e._LCHLauncherGenerated !== true) {
	    				// 	return false;
	    				// };
	    			}

	    			if (param2 === mod$3.LCHLauncherModePreview()) {
	    				return mod$2.LCHRecipesIsCommand(e);
	    			}
	    			
	    			return true;
	    		});
	    	},

	    	// import * as _fuzzysearch from &#39;fuzzysearch&#39;;
	    	// const fuzzysearch = typeof _fuzzysearch === &#39;function&#39; ? _fuzzysearch : _fuzzysearch.default;
	    	// LCHLauncherFilterForText (inputData) {
	    	// 	if (typeof inputData !== &#39;string&#39;) {
	    	// 		throw new Error(&#39;LCHErrorInputNotValid&#39;);
	    	// 	}

	    	// 	return function (e) {
	    	// 		return [e.LCHRecipeName].filter(function (e) {
	    	// 			if (!e) {
	    	// 				return false;
	    	// 			}

	    	// 			return fuzzysearch(inputData.toLowerCase(), e.toLowerCase());
	    	// 		}).length &gt; 0;
	    	// 	};
	    	// };

	    	LCHLauncherThrottleDuration: main_1() ? 25 : 1000,

	    	LCHLauncherKeyboardEventIsTextInput (inputData) {
	    		if (typeof inputData !== &#39;object&#39; || inputData === null) {
	    			throw new Error(&#39;LCHErrorInputNotValid&#39;);
	    		}

	    		if ([
	    			inputData.metaKey,
	    			inputData.shiftKey,
	    			inputData.ctrlKey,
	    			inputData.altKey,
	    		].includes(true)) {
	    			return false;
	    		}

	    		if (!inputData.key) {
	    			return false;
	    		}
	    		
	    		if ([
	    			&#39;Unidentified&#39;,
	    			&#39;Tab&#39;,
	    			&#39;CapsLock&#39;,
	    			&#39;ArrowRight&#39;,
	    			&#39;ArrowLeft&#39;,
	    			&#39;Backspace&#39;,
	    			&#39;\\&#39;,
	    			&#39;.&#39;,
	    			&#39;,&#39;,
	    			&#39; &#39;,
	    		].includes(inputData.key)) {
	    			return false;
	    		}
	    		
	    		return true;
	    	},

	    	LCHLauncherActionComparator (inputData) {
	    		if (typeof inputData !== &#39;string&#39;) {
	    			throw new Error(&#39;LCHErrorInputNotValid&#39;);
	    		}

	    		return function (a, b) {
	    			const param1s = [
	    				a.LCHRecipeInputTypes.split(&#39;,&#39;)[0],
	    				b.LCHRecipeInputTypes.split(&#39;,&#39;)[0],
	    			];
	    			const param2s = [
	    				a.LCHRecipeInputTypes.split(&#39;,&#39;)[1],
	    				b.LCHRecipeInputTypes.split(&#39;,&#39;)[1],
	    			];

	    			if (param1s[0] === inputData &amp;&amp; param1s[1] === inputData) {
	    				if (!param2s[0] &amp;&amp; param2s[1]) {
	    					return -1;
	    				}

	    				if (param2s[0] &amp;&amp; !param2s[1]) {
	    					return 1;
	    				}
	    			}

	    			if (param1s[0] === inputData &amp;&amp; param1s[1] !== inputData) {
	    				return -1;
	    			}

	    			if (param1s[1] === inputData &amp;&amp; param1s[0] !== inputData) {
	    				return 1;
	    			}

	    			return 1;
	    		};
	    	},

	    	LCHLauncherConstrainIndex (param1, param2) {
	    		if (!Array.isArray(param1)) {
	    			throw new Error(&#39;LCHErrorInputNotValid&#39;);
	    		}

	    		if (typeof param2 !== &#39;number&#39;) {
	    			throw new Error(&#39;LCHErrorInputNotValid&#39;);
	    		}

	    		if (param2 &lt; 0) {
	    			return param1.length - 1;
	    		}

	    		if (param2 &gt;= param1.length) {
	    			return 0;
	    		}

	    		return param2;
	    	},

	    	LCHLauncherReloadableSubjects (inputData) {
	    		if (!Array.isArray(inputData)) {
	    			throw new Error(&#39;LCHErrorInputNotValid&#39;);
	    		}

	    		return [].concat.apply([], inputData).filter(function (e) {
	    			if (typeof e !== &#39;object&#39; || e === null) {
	    				return false;
	    			}

	    			if (mod$2.LCHRecipesErrors(e)) {
	    				return false;
	    			}
	    			if (!mod$2.LCHRecipesIsSubject(e)) {
	    				return false;
	    			}
	    			return true;
	    		});
	    	},

	    };

	    var main$1 = createCommonjsModule(function (module, exports) {
	    (function(global, factory) {
	    	 factory(exports) ;
	    }(commonjsGlobal$1, (function(exports) {
	    	const mod = {

	    		OLSKInternationalDefaultIdentifier () {
	    			return &#39;i18n&#39;;
	    		},

	    		OLSKInternationalIsTranslationFileBasename (inputData) {
	    			if (typeof inputData !== &#39;string&#39;) {
	    				return false;
	    			}

	    			if (!inputData.split(&#39;.&#39;).pop().match(/ya?ml/i)) {
	    				return false;
	    			}

	    			if (inputData.split(&#39;.&#39;).shift() !== mod.OLSKInternationalDefaultIdentifier()) {
	    				return false;
	    			}

	    			if (!mod._OLSKInternationalLanguageID(inputData)) {
	    				return false;
	    			}

	    			return true;
	    		},

	    		OLSKInternationalLanguageID (inputData) {
	    			if (!mod.OLSKInternationalIsTranslationFileBasename(inputData)) {
	    				throw new Error(&#39;OLSKErrorInputNotValid&#39;);
	    			}

	    			return mod._OLSKInternationalLanguageID(inputData);
	    		},

	    		OLSKInternationalSimplifiedLanguageCode (inputData) {
	    			if (typeof inputData !== &#39;string&#39;) {
	    				throw new Error(&#39;OLSKErrorInputNotValid&#39;);
	    			}

	    			return inputData.split(&#39;-&#39;).shift();
	    		},

	    		_OLSKInternationalLanguageID (inputData) {
	    			var elements = inputData.split(&#39;.&#39;);

	    			elements.pop();
	    			elements.shift();

	    			return elements.pop();
	    		},

	    		OLSKInternationalLocalizedString (translationKey, translationDictionary) {
	    			if (typeof translationDictionary !== &#39;object&#39; || translationDictionary === null) {
	    				throw new Error(&#39;OLSKErrorInputNotValid&#39;);
	    			}

	    			var localizedString = translationDictionary[translationKey];

	    			if (!localizedString) {
	    				localizedString = &#39;TRANSLATION_MISSING&#39;;
	    				console.log([
	    					localizedString,
	    					translationKey,
	    					]);
	    			}

	    			return localizedString;
	    		},

	    		OLSKInternationalLocalizedStringCallback (dictionary, fallbackLocales) {
	    			if (typeof dictionary !== &#39;object&#39; || dictionary === null) {
	    				throw new Error(&#39;OLSKErrorInputNotValid&#39;);
	    			}

	    			if (!Array.isArray(fallbackLocales)) {
	    				throw new Error(&#39;OLSKErrorInputNotValid&#39;);
	    			}

	    			const _locales = Object.keys(dictionary).reverse().concat(...fallbackLocales.map(function (e) {
	    					return [mod.OLSKInternationalSimplifiedLanguageCode(e), e]
	    				}).reverse());

	    			return function (signature, requestLocales) {
	    				if (!Array.isArray(requestLocales)) {
	    					throw new Error(&#39;OLSKErrorInputNotValid&#39;);
	    				}

	    				let locales = _locales.concat(...requestLocales.map(function (e) {
	    					return [mod.OLSKInternationalSimplifiedLanguageCode(e), e]
	    				}).reverse(), []);

	    				let outputData;

	    				while (!outputData &amp;&amp; locales.length) {
	    					outputData = (dictionary[locales.pop()] || {})[signature];
	    				}

	    				if (!outputData) {
	    					console.log([outputData = &#39;TRANSLATION_MISSING&#39;, signature].join(&#39; &#39;));
	    				}

	    				return outputData;				
	    			};
	    		},

	    		_OLSKInternationalPaths (cwd, filter) {
	    			if (typeof cwd !== &#39;string&#39; || !cwd.trim()) {
	    				throw new Error(&#39;OLSKErrorInputNotValid&#39;);
	    			}

	    			const _require = commonjsRequire;

	    			return _require().sync(`**/*${ mod.OLSKInternationalDefaultIdentifier() }*.y*(a)ml`, {
	    				cwd,
	    				realpath: true,
	    			}).filter(function (e) {
	    				if (!filter) {
	    					return true;
	    				}

	    				return !e.match(filter);
	    			}).filter(function (e) {
	    				return mod.OLSKInternationalIsTranslationFileBasename(_require().basename(e));
	    			});
	    		},

	    		_OLSKInternationalConstructedDictionary (inputData) {
	    			if (!Array.isArray(inputData)) {
	    				throw new Error(&#39;OLSKErrorInputNotValid&#39;);
	    			}

	    			const _require = commonjsRequire;

	    			return inputData.reduce(function (coll, item) {
	    				const key = mod.OLSKInternationalLanguageID(_require().basename(item));

	    				coll[key] = Object.assign(coll[key] || {}, _require().load(_require().readFileSync(item, &#39;utf8&#39;)));

	    				return coll;
	    			}, {});
	    		},

	    		OLSKInternationalDictionary (cwd) {
	    			return this._OLSKInternationalConstructedDictionary(this._OLSKInternationalPaths(cwd));
	    		},

	    		_OLSKInternationalCompilationObject (cwd, languageID) {
	    			const _require = commonjsRequire;

	    			return this._OLSKInternationalPaths(cwd, /node_modules|__external/).filter(function (e) {
	    				if (!languageID) {
	    					return true;
	    				}

	    				return mod.OLSKInternationalLanguageID(_require().basename(e)) === languageID;
	    			}).reduce(function (coll, item) {
	    				return Object.assign(coll, {
	    					[item]: _require().load(_require().readFileSync(item, &#39;utf8&#39;)),
	    				});
	    			}, {});
	    		},

	    		_OLSKInternationalCompilationFilePath (cwd) {
	    			if (typeof cwd !== &#39;string&#39; || !cwd.trim()) {
	    				throw new Error(&#39;OLSKErrorInputNotValid&#39;);
	    			}
	    			const _require = commonjsRequire;

	    			return _require().join(cwd, &#39;__compiled&#39;, mod.OLSKInternationalDefaultIdentifier() + &#39;-compilation.yml&#39;)
	    		},

	    		_SafeDump (inputData) {
	    			const _require = commonjsRequire;

	    			return _require().safeDump(inputData, {
	    				lineWidth: Infinity,
	    			});
	    		},

	    		OLSKInternationalWriteCompilationFile (cwd, languageID) {
	    			const _require = commonjsRequire;

	    			const data = mod._SafeDump(this._OLSKInternationalCompilationObject(cwd, languageID));

	    			const outputDirectory = _require().dirname(mod._OLSKInternationalCompilationFilePath(cwd));

	    			if (!_require().existsSync(outputDirectory)){
	    				_require().mkdirSync(outputDirectory);
	    			}

	    			_require().writeFileSync(mod._OLSKInternationalCompilationFilePath(cwd), data);
	    		},

	    		OLSKInternationalSpreadCompilationFile (cwd, languageID) {
	    			if (typeof cwd !== &#39;string&#39; || !cwd.trim()) {
	    				throw new Error(&#39;OLSKErrorInputNotValid&#39;);
	    			}

	    			const _require = commonjsRequire;

	    			const compilation = _require().load(_require().readFileSync(mod._OLSKInternationalCompilationFilePath(cwd), &#39;utf8&#39;));

	    			Object.keys(compilation).map(function (e) {
	    				return _require().writeFileSync(e, mod._SafeDump(compilation[e]));
	    			});
	    		},

	    		OLSKInternationalAddControllerLanguageCode (cwd, languageID) {
	    			if (typeof cwd !== &#39;string&#39; || !cwd.trim()) {
	    				throw new Error(&#39;OLSKErrorInputNotValid&#39;);
	    			}

	    			if (typeof languageID !== &#39;string&#39; || !languageID.trim()) {
	    				throw new Error(&#39;OLSKErrorInputNotValid&#39;);
	    			}

	    			const _require = commonjsRequire;

	    			_require().sync(&#39;controller.js&#39;, {
	    				cwd,
	    				matchBase: true,
	    				realpath: true,
	    			}).forEach(function (file) {
	    				if (file.match(/.*(\.git|DS_Store|node_modules|vendor|__\w+)\/.*/i)) {
	    					return
	    				}

	    				const item = _require();

	    				if (typeof item.OLSKControllerRoutes !== &#39;function&#39;) {
	    					return;
	    				}

	    				if (!(function(inputData) {
	    					if (Array.isArray(inputData)) {
	    						return inputData;
	    					}
	    					return Object.entries(inputData).reduce(function (coll, item) {
	    						return coll.concat(Object.assign(item[1], {
	    							OLSKRouteSignature: item[0],
	    						}));
	    					}, []);
	    				})(item.OLSKControllerRoutes()).filter(function (e) {
	    					return e.OLSKRouteLanguageCodes;
	    				}).filter(function (e) {
	    					return !e.OLSKRouteLanguageCodes.includes(languageID);
	    				}).length) {
	    					return
	    				}
	    				const match = _require().readFileSync(file, &#39;utf8&#39;).match(/OLSKRouteLanguageCodes: \[.*\]/g);

	    				if (!match) {
	    					throw new Error(`invalid OLSKRouteLanguageCodes syntax in ${ e }`);
	    				}

	    				match.map(function (e) {
	    					const match = e.match(/\[.*\]/);
	    					return _require().writeFileSync(file, _require().readFileSync(file, &#39;utf8&#39;).replace(/OLSKRouteLanguageCodes: \[.*\]/, `OLSKRouteLanguageCodes: [&#39;${JSON.parse(match[0].replace(/\&#39;/g, &#39;&#34;&#39;)).concat(languageID).join(&#39;\&#39;, \&#39;&#39;)}&#39;]`));
	    				});
	    			});

	    			if (process.argv[2].endsWith(&#39;olsk-i18n-add&#39;)) {
	    				process.exit();
	    			}
	    		},

	    	};
	    	
	    	Object.assign(exports, mod);

	    	Object.defineProperty(exports, &#39;__esModule&#39;, {
	    		value: true
	    	});

	    })));

	    {
	    	exports.OLSKLocalized = function (inputData) {
	    		return exports.OLSKInternationalLocalizedString(inputData, JSON.parse(`{&#34;en&#34;:{&#34;LCHLauncherInputPlaceholderDefault&#34;:&#34;Type to search&#34;,&#34;LCHLauncherInputPlaceholderPreview&#34;:&#34;Type to filter&#34;,&#34;LCHLauncherSubjectPromptPlaceholderText&#34;:&#34;Type to search&#34;,&#34;LCHLauncherSubjectPromptHeadingText&#34;:&#34;Subject&#34;,&#34;LCHLauncherActionPromptHeadingText&#34;:&#34;Action&#34;,&#34;LCHLauncherObjectPromptHeadingText&#34;:&#34;Object&#34;,&#34;LCHCopyToClipboardButtonText&#34;:&#34;Copy to clipboard&#34;,&#34;LCHStandardRecipeNames&#34;:{&#34;LCHActiveDocumentFocusElements&#34;:&#34;Active Document Focus Elements&#34;,&#34;LCHCopyToClipboard&#34;:&#34;Copy to clipboard&#34;,&#34;LCHLargeText&#34;:&#34;Large text&#34;,&#34;LCHDOMElementFocus&#34;:&#34;Focus&#34;,&#34;LCHRunCommand&#34;:&#34;Run Command&#34;,&#34;LCHSearchWith&#34;:&#34;Search With&#34;,&#34;LCHSearchFor&#34;:&#34;Search For&#34;,&#34;LCHSubjectContainerShowContents&#34;:&#34;Show Contents&#34;,&#34;LCHURLOpen&#34;:&#34;Open URL&#34;,&#34;SubjectContainer&#34;:&#34;Subject Container&#34;,&#34;String&#34;:&#34;String&#34;,&#34;Date&#34;:&#34;Date&#34;,&#34;URL&#34;:&#34;URL&#34;,&#34;ServiceSearchURLTemplate&#34;:&#34;Search Service URL Template&#34;,&#34;DOMElement&#34;:&#34;DOM Element&#34;}},&#34;es&#34;:{&#34;LCHLauncherInputPlaceholderDefault&#34;:&#34;Escribir para buscar&#34;,&#34;LCHLauncherInputPlaceholderPreview&#34;:&#34;Escribir para filtrar&#34;,&#34;LCHLauncherSubjectPromptPlaceholderText&#34;:&#34;Escribir para buscar&#34;,&#34;LCHLauncherSubjectPromptHeadingText&#34;:&#34;Sujeto&#34;,&#34;LCHLauncherActionPromptHeadingText&#34;:&#34;Acto&#34;,&#34;LCHLauncherObjectPromptHeadingText&#34;:&#34;Objeto&#34;,&#34;LCHCopyToClipboardButtonText&#34;:&#34;Copiar al portapapeles&#34;,&#34;LCHStandardRecipeNames&#34;:{&#34;LCHActiveDocumentFocusElements&#34;:&#34;Elementos enfocados del documento activo&#34;,&#34;LCHCopyToClipboard&#34;:&#34;Copiar al portapapeles&#34;,&#34;LCHLargeText&#34;:&#34;Texto aumentado&#34;,&#34;LCHDOMElementFocus&#34;:&#34;Enfocar&#34;,&#34;LCHRunCommand&#34;:&#34;Ejecutar comando&#34;,&#34;LCHSearchWith&#34;:&#34;Buscar con&#34;,&#34;LCHSearchFor&#34;:&#34;Buscar para&#34;,&#34;LCHSubjectContainerShowContents&#34;:&#34;Mostrar contenidos&#34;,&#34;LCHURLOpen&#34;:&#34;Abrir URL&#34;,&#34;SubjectContainer&#34;:&#34;Contenido de sujetos&#34;,&#34;String&#34;:&#34;String&#34;,&#34;Date&#34;:&#34;Date&#34;,&#34;URL&#34;:&#34;URL&#34;,&#34;ServiceSearchURLTemplate&#34;:&#34;Plantilla URL de servicio de búsqueda&#34;,&#34;DOMElement&#34;:&#34;Elemento DOM&#34;}},&#34;fr&#34;:{&#34;LCHLauncherInputPlaceholderDefault&#34;:&#34;Taper pour chercher&#34;,&#34;LCHLauncherInputPlaceholderPreview&#34;:&#34;Taper pour filtrer&#34;,&#34;LCHLauncherSubjectPromptPlaceholderText&#34;:&#34;Taper pour chercher&#34;,&#34;LCHLauncherSubjectPromptHeadingText&#34;:&#34;Sujet&#34;,&#34;LCHLauncherActionPromptHeadingText&#34;:&#34;Action&#34;,&#34;LCHLauncherObjectPromptHeadingText&#34;:&#34;Objet&#34;,&#34;LCHCopyToClipboardButtonText&#34;:&#34;Copier dans le presse-papier&#34;,&#34;LCHStandardRecipeNames&#34;:{&#34;LCHActiveDocumentFocusElements&#34;:&#34;Éléments au points du document active&#34;,&#34;LCHCopyToClipboard&#34;:&#34;Copier dans le presse-papier&#34;,&#34;LCHLargeText&#34;:&#34;Texte élargi&#34;,&#34;LCHDOMElementFocus&#34;:&#34;Faire le point&#34;,&#34;LCHRunCommand&#34;:&#34;Exécuter la commande&#34;,&#34;LCHSearchWith&#34;:&#34;Chercher avec&#34;,&#34;LCHSearchFor&#34;:&#34;Chercher pour&#34;,&#34;LCHSubjectContainerShowContents&#34;:&#34;Montrer le contenu&#34;,&#34;LCHURLOpen&#34;:&#34;Ouvrir l&#39;URL&#34;,&#34;SubjectContainer&#34;:&#34;Contenant des sujets&#34;,&#34;String&#34;:&#34;String&#34;,&#34;Date&#34;:&#34;Date&#34;,&#34;URL&#34;:&#34;URL&#34;,&#34;ServiceSearchURLTemplate&#34;:&#34;Modèle URL de service de recherche&#34;,&#34;DOMElement&#34;:&#34;Élément DOM&#34;}},&#34;pt&#34;:{&#34;LCHLauncherInputPlaceholderDefault&#34;:&#34;Digitar para pesquisar&#34;,&#34;LCHLauncherInputPlaceholderPreview&#34;:&#34;Digitar para filtrar&#34;,&#34;LCHLauncherSubjectPromptPlaceholderText&#34;:&#34;Digitar para pesquisar&#34;,&#34;LCHLauncherSubjectPromptHeadingText&#34;:&#34;Sujeito&#34;,&#34;LCHLauncherActionPromptHeadingText&#34;:&#34;Ação&#34;,&#34;LCHLauncherObjectPromptHeadingText&#34;:&#34;Objeto&#34;,&#34;LCHCopyToClipboardButtonText&#34;:&#34;Cópia na área de transferência&#34;,&#34;LCHStandardRecipeNames&#34;:{&#34;LCHActiveDocumentFocusElements&#34;:&#34;Elementos de foco no documento ativo&#34;,&#34;LCHCopyToClipboard&#34;:&#34;Cópia na área de transferência&#34;,&#34;LCHLargeText&#34;:&#34;Texto grande&#34;,&#34;LCHDOMElementFocus&#34;:&#34;Foco&#34;,&#34;LCHRunCommand&#34;:&#34;Executar Comando&#34;,&#34;LCHSearchWith&#34;:&#34;Buscar com&#34;,&#34;LCHSearchFor&#34;:&#34;Buscar por&#34;,&#34;LCHSubjectContainerShowContents&#34;:&#34;Mostrar conteúdo&#34;,&#34;LCHURLOpen&#34;:&#34;Abrir URL&#34;,&#34;SubjectContainer&#34;:&#34;Contêiner do Sujeito&#34;,&#34;String&#34;:&#34;Sequência&#34;,&#34;Date&#34;:&#34;Data&#34;,&#34;URL&#34;:&#34;URL&#34;,&#34;ServiceSearchURLTemplate&#34;:&#34;Modelo de URL do serviço de pesquisa&#34;,&#34;DOMElement&#34;:&#34;Elemento do DOM&#34;}}}`)[window.OLSKPublicConstants(&#39;OLSKSharedPageCurrentLanguage&#39;)]);
	    	};
	    }
	    });

	    var OLSKInternational = unwrapExports(main$1);
	    var main_1$1 = main$1.OLSKLocalized;

	    var fuzzysort = createCommonjsModule(function (module) {
	    (function(root, UMD) {
	      if( module.exports) module.exports = UMD();
	      else root.fuzzysort = UMD();
	    })(commonjsGlobal$1, function UMD() { function fuzzysortNew(instanceOptions) {

	      var fuzzysort = {

	        single: function(search, target, options) {
	          if(!search) return null
	          if(!isObj(search)) search = fuzzysort.getPreparedSearch(search);

	          if(!target) return null
	          if(!isObj(target)) target = fuzzysort.getPrepared(target);

	          var allowTypo = options &amp;&amp; options.allowTypo!==undefined ? options.allowTypo
	            : instanceOptions &amp;&amp; instanceOptions.allowTypo!==undefined ? instanceOptions.allowTypo
	            : true;
	          var algorithm = allowTypo ? fuzzysort.algorithm : fuzzysort.algorithmNoTypo;
	          return algorithm(search, target, search[0])
	          // var threshold = options &amp;&amp; options.threshold || instanceOptions &amp;&amp; instanceOptions.threshold || -9007199254740991
	          // var result = algorithm(search, target, search[0])
	          // if(result === null) return null
	          // if(result.score &lt; threshold) return null
	          // return result
	        },

	        go: function(search, targets, options) {
	          if(!search) return noResults
	          search = fuzzysort.prepareSearch(search);
	          var searchLowerCode = search[0];

	          var threshold = options &amp;&amp; options.threshold || instanceOptions &amp;&amp; instanceOptions.threshold || -9007199254740991;
	          var limit = options &amp;&amp; options.limit || instanceOptions &amp;&amp; instanceOptions.limit || 9007199254740991;
	          var allowTypo = options &amp;&amp; options.allowTypo!==undefined ? options.allowTypo
	            : instanceOptions &amp;&amp; instanceOptions.allowTypo!==undefined ? instanceOptions.allowTypo
	            : true;
	          var algorithm = allowTypo ? fuzzysort.algorithm : fuzzysort.algorithmNoTypo;
	          var resultsLen = 0; var limitedCount = 0;
	          var targetsLen = targets.length;

	          // This code is copy/pasted 3 times for performance reasons [options.keys, options.key, no keys]

	          // options.keys
	          if(options &amp;&amp; options.keys) {
	            var scoreFn = options.scoreFn || defaultScoreFn;
	            var keys = options.keys;
	            var keysLen = keys.length;
	            for(var i = targetsLen - 1; i &gt;= 0; --i) { var obj = targets[i];
	              var objResults = new Array(keysLen);
	              for (var keyI = keysLen - 1; keyI &gt;= 0; --keyI) {
	                var key = keys[keyI];
	                var target = getValue(obj, key);
	                if(!target) { objResults[keyI] = null; continue }
	                if(!isObj(target)) target = fuzzysort.getPrepared(target);

	                objResults[keyI] = algorithm(search, target, searchLowerCode);
	              }
	              objResults.obj = obj; // before scoreFn so scoreFn can use it
	              var score = scoreFn(objResults);
	              if(score === null) continue
	              if(score &lt; threshold) continue
	              objResults.score = score;
	              if(resultsLen &lt; limit) { q.add(objResults); ++resultsLen; }
	              else {
	                ++limitedCount;
	                if(score &gt; q.peek().score) q.replaceTop(objResults);
	              }
	            }

	          // options.key
	          } else if(options &amp;&amp; options.key) {
	            var key = options.key;
	            for(var i = targetsLen - 1; i &gt;= 0; --i) { var obj = targets[i];
	              var target = getValue(obj, key);
	              if(!target) continue
	              if(!isObj(target)) target = fuzzysort.getPrepared(target);

	              var result = algorithm(search, target, searchLowerCode);
	              if(result === null) continue
	              if(result.score &lt; threshold) continue

	              // have to clone result so duplicate targets from different obj can each reference the correct obj
	              result = {target:result.target, _targetLowerCodes:null, _nextBeginningIndexes:null, score:result.score, indexes:result.indexes, obj:obj}; // hidden

	              if(resultsLen &lt; limit) { q.add(result); ++resultsLen; }
	              else {
	                ++limitedCount;
	                if(result.score &gt; q.peek().score) q.replaceTop(result);
	              }
	            }

	          // no keys
	          } else {
	            for(var i = targetsLen - 1; i &gt;= 0; --i) { var target = targets[i];
	              if(!target) continue
	              if(!isObj(target)) target = fuzzysort.getPrepared(target);

	              var result = algorithm(search, target, searchLowerCode);
	              if(result === null) continue
	              if(result.score &lt; threshold) continue
	              if(resultsLen &lt; limit) { q.add(result); ++resultsLen; }
	              else {
	                ++limitedCount;
	                if(result.score &gt; q.peek().score) q.replaceTop(result);
	              }
	            }
	          }

	          if(resultsLen === 0) return noResults
	          var results = new Array(resultsLen);
	          for(var i = resultsLen - 1; i &gt;= 0; --i) results[i] = q.poll();
	          results.total = resultsLen + limitedCount;
	          return results
	        },

	        goAsync: function(search, targets, options) {
	          var canceled = false;
	          var p = new Promise(function(resolve, reject) {
	            if(!search) return resolve(noResults)
	            search = fuzzysort.prepareSearch(search);
	            var searchLowerCode = search[0];

	            var q = fastpriorityqueue();
	            var iCurrent = targets.length - 1;
	            var threshold = options &amp;&amp; options.threshold || instanceOptions &amp;&amp; instanceOptions.threshold || -9007199254740991;
	            var limit = options &amp;&amp; options.limit || instanceOptions &amp;&amp; instanceOptions.limit || 9007199254740991;
	            var allowTypo = options &amp;&amp; options.allowTypo!==undefined ? options.allowTypo
	              : instanceOptions &amp;&amp; instanceOptions.allowTypo!==undefined ? instanceOptions.allowTypo
	              : true;
	            var algorithm = allowTypo ? fuzzysort.algorithm : fuzzysort.algorithmNoTypo;
	            var resultsLen = 0; var limitedCount = 0;
	            function step() {
	              if(canceled) return reject(&#39;canceled&#39;)

	              var startMs = Date.now();

	              // This code is copy/pasted 3 times for performance reasons [options.keys, options.key, no keys]

	              // options.keys
	              if(options &amp;&amp; options.keys) {
	                var scoreFn = options.scoreFn || defaultScoreFn;
	                var keys = options.keys;
	                var keysLen = keys.length;
	                for(; iCurrent &gt;= 0; --iCurrent) { var obj = targets[iCurrent];
	                  var objResults = new Array(keysLen);
	                  for (var keyI = keysLen - 1; keyI &gt;= 0; --keyI) {
	                    var key = keys[keyI];
	                    var target = getValue(obj, key);
	                    if(!target) { objResults[keyI] = null; continue }
	                    if(!isObj(target)) target = fuzzysort.getPrepared(target);

	                    objResults[keyI] = algorithm(search, target, searchLowerCode);
	                  }
	                  objResults.obj = obj; // before scoreFn so scoreFn can use it
	                  var score = scoreFn(objResults);
	                  if(score === null) continue
	                  if(score &lt; threshold) continue
	                  objResults.score = score;
	                  if(resultsLen &lt; limit) { q.add(objResults); ++resultsLen; }
	                  else {
	                    ++limitedCount;
	                    if(score &gt; q.peek().score) q.replaceTop(objResults);
	                  }

	                  if(iCurrent%1000/*itemsPerCheck*/ === 0) {
	                    if(Date.now() - startMs &gt;= 10/*asyncInterval*/) {
	                      isNode?setImmediate(step):setTimeout(step);
	                      return
	                    }
	                  }
	                }

	              // options.key
	              } else if(options &amp;&amp; options.key) {
	                var key = options.key;
	                for(; iCurrent &gt;= 0; --iCurrent) { var obj = targets[iCurrent];
	                  var target = getValue(obj, key);
	                  if(!target) continue
	                  if(!isObj(target)) target = fuzzysort.getPrepared(target);

	                  var result = algorithm(search, target, searchLowerCode);
	                  if(result === null) continue
	                  if(result.score &lt; threshold) continue

	                  // have to clone result so duplicate targets from different obj can each reference the correct obj
	                  result = {target:result.target, _targetLowerCodes:null, _nextBeginningIndexes:null, score:result.score, indexes:result.indexes, obj:obj}; // hidden

	                  if(resultsLen &lt; limit) { q.add(result); ++resultsLen; }
	                  else {
	                    ++limitedCount;
	                    if(result.score &gt; q.peek().score) q.replaceTop(result);
	                  }

	                  if(iCurrent%1000/*itemsPerCheck*/ === 0) {
	                    if(Date.now() - startMs &gt;= 10/*asyncInterval*/) {
	                      isNode?setImmediate(step):setTimeout(step);
	                      return
	                    }
	                  }
	                }

	              // no keys
	              } else {
	                for(; iCurrent &gt;= 0; --iCurrent) { var target = targets[iCurrent];
	                  if(!target) continue
	                  if(!isObj(target)) target = fuzzysort.getPrepared(target);

	                  var result = algorithm(search, target, searchLowerCode);
	                  if(result === null) continue
	                  if(result.score &lt; threshold) continue
	                  if(resultsLen &lt; limit) { q.add(result); ++resultsLen; }
	                  else {
	                    ++limitedCount;
	                    if(result.score &gt; q.peek().score) q.replaceTop(result);
	                  }

	                  if(iCurrent%1000/*itemsPerCheck*/ === 0) {
	                    if(Date.now() - startMs &gt;= 10/*asyncInterval*/) {
	                      isNode?setImmediate(step):setTimeout(step);
	                      return
	                    }
	                  }
	                }
	              }

	              if(resultsLen === 0) return resolve(noResults)
	              var results = new Array(resultsLen);
	              for(var i = resultsLen - 1; i &gt;= 0; --i) results[i] = q.poll();
	              results.total = resultsLen + limitedCount;
	              resolve(results);
	            }

	            isNode?setImmediate(step):step();
	          });
	          p.cancel = function() { canceled = true; };
	          return p
	        },

	        highlight: function(result, hOpen, hClose) {
	          if(result === null) return null
	          if(hOpen === undefined) hOpen = &#39;&lt;b&gt;&#39;;
	          if(hClose === undefined) hClose = &#39;&lt;/b&gt;&#39;;
	          var highlighted = &#39;&#39;;
	          var matchesIndex = 0;
	          var opened = false;
	          var target = result.target;
	          var targetLen = target.length;
	          var matchesBest = result.indexes;
	          for(var i = 0; i &lt; targetLen; ++i) { var char = target[i];
	            if(matchesBest[matchesIndex] === i) {
	              ++matchesIndex;
	              if(!opened) { opened = true;
	                highlighted += hOpen;
	              }

	              if(matchesIndex === matchesBest.length) {
	                highlighted += char + hClose + target.substr(i+1);
	                break
	              }
	            } else {
	              if(opened) { opened = false;
	                highlighted += hClose;
	              }
	            }
	            highlighted += char;
	          }

	          return highlighted
	        },

	        prepare: function(target) {
	          if(!target) return
	          return {target:target, _targetLowerCodes:fuzzysort.prepareLowerCodes(target), _nextBeginningIndexes:null, score:null, indexes:null, obj:null} // hidden
	        },
	        prepareSlow: function(target) {
	          if(!target) return
	          return {target:target, _targetLowerCodes:fuzzysort.prepareLowerCodes(target), _nextBeginningIndexes:fuzzysort.prepareNextBeginningIndexes(target), score:null, indexes:null, obj:null} // hidden
	        },
	        prepareSearch: function(search) {
	          if(!search) return
	          return fuzzysort.prepareLowerCodes(search)
	        },



	        // Below this point is only internal code
	        // Below this point is only internal code
	        // Below this point is only internal code
	        // Below this point is only internal code



	        getPrepared: function(target) {
	          if(target.length &gt; 999) return fuzzysort.prepare(target) // don&#39;t cache huge targets
	          var targetPrepared = preparedCache.get(target);
	          if(targetPrepared !== undefined) return targetPrepared
	          targetPrepared = fuzzysort.prepare(target);
	          preparedCache.set(target, targetPrepared);
	          return targetPrepared
	        },
	        getPreparedSearch: function(search) {
	          if(search.length &gt; 999) return fuzzysort.prepareSearch(search) // don&#39;t cache huge searches
	          var searchPrepared = preparedSearchCache.get(search);
	          if(searchPrepared !== undefined) return searchPrepared
	          searchPrepared = fuzzysort.prepareSearch(search);
	          preparedSearchCache.set(search, searchPrepared);
	          return searchPrepared
	        },

	        algorithm: function(searchLowerCodes, prepared, searchLowerCode) {
	          var targetLowerCodes = prepared._targetLowerCodes;
	          var searchLen = searchLowerCodes.length;
	          var targetLen = targetLowerCodes.length;
	          var searchI = 0; // where we at
	          var targetI = 0; // where you at
	          var typoSimpleI = 0;
	          var matchesSimpleLen = 0;

	          // very basic fuzzy match; to remove non-matching targets ASAP!
	          // walk through target. find sequential matches.
	          // if all chars aren&#39;t found then exit
	          for(;;) {
	            var isMatch = searchLowerCode === targetLowerCodes[targetI];
	            if(isMatch) {
	              matchesSimple[matchesSimpleLen++] = targetI;
	              ++searchI; if(searchI === searchLen) break
	              searchLowerCode = searchLowerCodes[typoSimpleI===0?searchI : (typoSimpleI===searchI?searchI+1 : (typoSimpleI===searchI-1?searchI-1 : searchI))];
	            }

	            ++targetI; if(targetI &gt;= targetLen) { // Failed to find searchI
	              // Check for typo or exit
	              // we go as far as possible before trying to transpose
	              // then we transpose backwards until we reach the beginning
	              for(;;) {
	                if(searchI &lt;= 1) return null // not allowed to transpose first char
	                if(typoSimpleI === 0) { // we haven&#39;t tried to transpose yet
	                  --searchI;
	                  var searchLowerCodeNew = searchLowerCodes[searchI];
	                  if(searchLowerCode === searchLowerCodeNew) continue // doesn&#39;t make sense to transpose a repeat char
	                  typoSimpleI = searchI;
	                } else {
	                  if(typoSimpleI === 1) return null // reached the end of the line for transposing
	                  --typoSimpleI;
	                  searchI = typoSimpleI;
	                  searchLowerCode = searchLowerCodes[searchI + 1];
	                  var searchLowerCodeNew = searchLowerCodes[searchI];
	                  if(searchLowerCode === searchLowerCodeNew) continue // doesn&#39;t make sense to transpose a repeat char
	                }
	                matchesSimpleLen = searchI;
	                targetI = matchesSimple[matchesSimpleLen - 1] + 1;
	                break
	              }
	            }
	          }

	          var searchI = 0;
	          var typoStrictI = 0;
	          var successStrict = false;
	          var matchesStrictLen = 0;

	          var nextBeginningIndexes = prepared._nextBeginningIndexes;
	          if(nextBeginningIndexes === null) nextBeginningIndexes = prepared._nextBeginningIndexes = fuzzysort.prepareNextBeginningIndexes(prepared.target);
	          var firstPossibleI = targetI = matchesSimple[0]===0 ? 0 : nextBeginningIndexes[matchesSimple[0]-1];

	          // Our target string successfully matched all characters in sequence!
	          // Let&#39;s try a more advanced and strict test to improve the score
	          // only count it as a match if it&#39;s consecutive or a beginning character!
	          if(targetI !== targetLen) for(;;) {
	            if(targetI &gt;= targetLen) {
	              // We failed to find a good spot for this search char, go back to the previous search char and force it forward
	              if(searchI &lt;= 0) { // We failed to push chars forward for a better match
	                // transpose, starting from the beginning
	                ++typoStrictI; if(typoStrictI &gt; searchLen-2) break
	                if(searchLowerCodes[typoStrictI] === searchLowerCodes[typoStrictI+1]) continue // doesn&#39;t make sense to transpose a repeat char
	                targetI = firstPossibleI;
	                continue
	              }

	              --searchI;
	              var lastMatch = matchesStrict[--matchesStrictLen];
	              targetI = nextBeginningIndexes[lastMatch];

	            } else {
	              var isMatch = searchLowerCodes[typoStrictI===0?searchI : (typoStrictI===searchI?searchI+1 : (typoStrictI===searchI-1?searchI-1 : searchI))] === targetLowerCodes[targetI];
	              if(isMatch) {
	                matchesStrict[matchesStrictLen++] = targetI;
	                ++searchI; if(searchI === searchLen) { successStrict = true; break }
	                ++targetI;
	              } else {
	                targetI = nextBeginningIndexes[targetI];
	              }
	            }
	          }

	          { // tally up the score &amp; keep track of matches for highlighting later
	            if(successStrict) { var matchesBest = matchesStrict; var matchesBestLen = matchesStrictLen; }
	            else { var matchesBest = matchesSimple; var matchesBestLen = matchesSimpleLen; }
	            var score = 0;
	            var lastTargetI = -1;
	            for(var i = 0; i &lt; searchLen; ++i) { var targetI = matchesBest[i];
	              // score only goes down if they&#39;re not consecutive
	              if(lastTargetI !== targetI - 1) score -= targetI;
	              lastTargetI = targetI;
	            }
	            if(!successStrict) {
	              score *= 1000;
	              if(typoSimpleI !== 0) score += -20;/*typoPenalty*/
	            } else {
	              if(typoStrictI !== 0) score += -20;/*typoPenalty*/
	            }
	            score -= targetLen - searchLen;
	            prepared.score = score;
	            prepared.indexes = new Array(matchesBestLen); for(var i = matchesBestLen - 1; i &gt;= 0; --i) prepared.indexes[i] = matchesBest[i];

	            return prepared
	          }
	        },

	        algorithmNoTypo: function(searchLowerCodes, prepared, searchLowerCode) {
	          var targetLowerCodes = prepared._targetLowerCodes;
	          var searchLen = searchLowerCodes.length;
	          var targetLen = targetLowerCodes.length;
	          var searchI = 0; // where we at
	          var targetI = 0; // where you at
	          var matchesSimpleLen = 0;

	          // very basic fuzzy match; to remove non-matching targets ASAP!
	          // walk through target. find sequential matches.
	          // if all chars aren&#39;t found then exit
	          for(;;) {
	            var isMatch = searchLowerCode === targetLowerCodes[targetI];
	            if(isMatch) {
	              matchesSimple[matchesSimpleLen++] = targetI;
	              ++searchI; if(searchI === searchLen) break
	              searchLowerCode = searchLowerCodes[searchI];
	            }
	            ++targetI; if(targetI &gt;= targetLen) return null // Failed to find searchI
	          }

	          var searchI = 0;
	          var successStrict = false;
	          var matchesStrictLen = 0;

	          var nextBeginningIndexes = prepared._nextBeginningIndexes;
	          if(nextBeginningIndexes === null) nextBeginningIndexes = prepared._nextBeginningIndexes = fuzzysort.prepareNextBeginningIndexes(prepared.target);
	          var firstPossibleI = targetI = matchesSimple[0]===0 ? 0 : nextBeginningIndexes[matchesSimple[0]-1];

	          // Our target string successfully matched all characters in sequence!
	          // Let&#39;s try a more advanced and strict test to improve the score
	          // only count it as a match if it&#39;s consecutive or a beginning character!
	          if(targetI !== targetLen) for(;;) {
	            if(targetI &gt;= targetLen) {
	              // We failed to find a good spot for this search char, go back to the previous search char and force it forward
	              if(searchI &lt;= 0) break // We failed to push chars forward for a better match

	              --searchI;
	              var lastMatch = matchesStrict[--matchesStrictLen];
	              targetI = nextBeginningIndexes[lastMatch];

	            } else {
	              var isMatch = searchLowerCodes[searchI] === targetLowerCodes[targetI];
	              if(isMatch) {
	                matchesStrict[matchesStrictLen++] = targetI;
	                ++searchI; if(searchI === searchLen) { successStrict = true; break }
	                ++targetI;
	              } else {
	                targetI = nextBeginningIndexes[targetI];
	              }
	            }
	          }

	          { // tally up the score &amp; keep track of matches for highlighting later
	            if(successStrict) { var matchesBest = matchesStrict; var matchesBestLen = matchesStrictLen; }
	            else { var matchesBest = matchesSimple; var matchesBestLen = matchesSimpleLen; }
	            var score = 0;
	            var lastTargetI = -1;
	            for(var i = 0; i &lt; searchLen; ++i) { var targetI = matchesBest[i];
	              // score only goes down if they&#39;re not consecutive
	              if(lastTargetI !== targetI - 1) score -= targetI;
	              lastTargetI = targetI;
	            }
	            if(!successStrict) score *= 1000;
	            score -= targetLen - searchLen;
	            prepared.score = score;
	            prepared.indexes = new Array(matchesBestLen); for(var i = matchesBestLen - 1; i &gt;= 0; --i) prepared.indexes[i] = matchesBest[i];

	            return prepared
	          }
	        },

	        prepareLowerCodes: function(str) {
	          var strLen = str.length;
	          var lowerCodes = []; // new Array(strLen)    sparse array is too slow
	          var lower = str.toLowerCase();
	          for(var i = 0; i &lt; strLen; ++i) lowerCodes[i] = lower.charCodeAt(i);
	          return lowerCodes
	        },
	        prepareBeginningIndexes: function(target) {
	          var targetLen = target.length;
	          var beginningIndexes = []; var beginningIndexesLen = 0;
	          var wasUpper = false;
	          var wasAlphanum = false;
	          for(var i = 0; i &lt; targetLen; ++i) {
	            var targetCode = target.charCodeAt(i);
	            var isUpper = targetCode&gt;=65&amp;&amp;targetCode&lt;=90;
	            var isAlphanum = isUpper || targetCode&gt;=97&amp;&amp;targetCode&lt;=122 || targetCode&gt;=48&amp;&amp;targetCode&lt;=57;
	            var isBeginning = isUpper &amp;&amp; !wasUpper || !wasAlphanum || !isAlphanum;
	            wasUpper = isUpper;
	            wasAlphanum = isAlphanum;
	            if(isBeginning) beginningIndexes[beginningIndexesLen++] = i;
	          }
	          return beginningIndexes
	        },
	        prepareNextBeginningIndexes: function(target) {
	          var targetLen = target.length;
	          var beginningIndexes = fuzzysort.prepareBeginningIndexes(target);
	          var nextBeginningIndexes = []; // new Array(targetLen)     sparse array is too slow
	          var lastIsBeginning = beginningIndexes[0];
	          var lastIsBeginningI = 0;
	          for(var i = 0; i &lt; targetLen; ++i) {
	            if(lastIsBeginning &gt; i) {
	              nextBeginningIndexes[i] = lastIsBeginning;
	            } else {
	              lastIsBeginning = beginningIndexes[++lastIsBeginningI];
	              nextBeginningIndexes[i] = lastIsBeginning===undefined ? targetLen : lastIsBeginning;
	            }
	          }
	          return nextBeginningIndexes
	        },

	        cleanup: cleanup,
	        new: fuzzysortNew,
	      };
	      return fuzzysort
	    } // fuzzysortNew

	    // This stuff is outside fuzzysortNew, because it&#39;s shared with instances of fuzzysort.new()
	    var isNode = typeof commonjsRequire !== &#39;undefined&#39; &amp;&amp; typeof window === &#39;undefined&#39;;
	    // var MAX_INT = Number.MAX_SAFE_INTEGER
	    // var MIN_INT = Number.MIN_VALUE
	    var preparedCache = new Map();
	    var preparedSearchCache = new Map();
	    var noResults = []; noResults.total = 0;
	    var matchesSimple = []; var matchesStrict = [];
	    function cleanup() { preparedCache.clear(); preparedSearchCache.clear(); matchesSimple = []; matchesStrict = []; }
	    function defaultScoreFn(a) {
	      var max = -9007199254740991;
	      for (var i = a.length - 1; i &gt;= 0; --i) {
	        var result = a[i]; if(result === null) continue
	        var score = result.score;
	        if(score &gt; max) max = score;
	      }
	      if(max === -9007199254740991) return null
	      return max
	    }

	    // prop = &#39;key&#39;              2.5ms optimized for this case, seems to be about as fast as direct obj[prop]
	    // prop = &#39;key1.key2&#39;        10ms
	    // prop = [&#39;key1&#39;, &#39;key2&#39;]   27ms
	    function getValue(obj, prop) {
	      var tmp = obj[prop]; if(tmp !== undefined) return tmp
	      var segs = prop;
	      if(!Array.isArray(prop)) segs = prop.split(&#39;.&#39;);
	      var len = segs.length;
	      var i = -1;
	      while (obj &amp;&amp; (++i &lt; len)) obj = obj[segs[i]];
	      return obj
	    }

	    function isObj(x) { return typeof x === &#39;object&#39; } // faster as a function

	    // Hacked version of https://github.com/lemire/FastPriorityQueue.js
	    var fastpriorityqueue=function(){var r=[],o=0,e={};function n(){for(var e=0,n=r[e],c=1;c&lt;o;){var f=c+1;e=c,f&lt;o&amp;&amp;r[f].score&lt;r[c].score&amp;&amp;(e=f),r[e-1&gt;&gt;1]=r[e],c=1+(e&lt;&lt;1);}for(var a=e-1&gt;&gt;1;e&gt;0&amp;&amp;n.score&lt;r[a].score;a=(e=a)-1&gt;&gt;1)r[e]=r[a];r[e]=n;}return e.add=function(e){var n=o;r[o++]=e;for(var c=n-1&gt;&gt;1;n&gt;0&amp;&amp;e.score&lt;r[c].score;c=(n=c)-1&gt;&gt;1)r[n]=r[c];r[n]=e;},e.poll=function(){if(0!==o){var e=r[0];return r[0]=r[--o],n(),e}},e.peek=function(e){if(0!==o)return r[0]},e.replaceTop=function(o){r[0]=o,n();},e};
	    var q = fastpriorityqueue(); // reuse this, except for async, it needs to make its own

	    return fuzzysortNew()
	    }); // UMD

	    // TODO: (performance) wasm version!?

	    // TODO: (performance) layout memory in an optimal way to go fast by avoiding cache misses

	    // TODO: (performance) preparedCache is a memory leak

	    // TODO: (like sublime) backslash === forwardslash

	    // TODO: (performance) i have no idea how well optizmied the allowing typos algorithm is
	    });

	    var main$2 = createCommonjsModule(function (module, exports) {
	    const mod = {

	    	OLSKThrottleIsValid (inputData) {
	    		if (typeof inputData !== &#39;object&#39; || inputData === null) {
	    			return false;
	    		}

	    		if (typeof inputData.OLSKThrottleCallback !== &#39;function&#39;) {
	    			return false;
	    		}

	    		if (typeof inputData.OLSKThrottleDuration !== &#39;number&#39;) {
	    			return false;
	    		}

	    		return true;
	    	},

	    	OLSKThrottleTimeoutFor (inputData) {
	    		if (!mod.OLSKThrottleIsValid(inputData)) {
	    			throw new Error(&#39;OLSKErrorInputNotValid&#39;);
	    		}

	    		if (inputData._OLSKThrottleTimeoutID) {
	    			clearTimeout(inputData._OLSKThrottleTimeoutID);
	    		}

	    		inputData._OLSKThrottleTimeoutID = setTimeout(function () {
	    			mod._OLSKThrottleFire(inputData);
	    		}, inputData.OLSKThrottleDuration);

	    		return inputData._OLSKThrottleTimeoutID;
	    	},

	    	OLSKThrottleSkip (inputData) {
	    		if (!mod.OLSKThrottleIsValid(inputData)) {
	    			throw new Error(&#39;OLSKErrorInputNotValid&#39;);
	    		}

	    		clearTimeout(inputData._OLSKThrottleTimeoutID);
	    		
	    		return mod._OLSKThrottleFire(inputData);
	    	},

	    	_OLSKThrottleFire (inputData) {
	    		delete inputData._OLSKThrottleTimeoutID;
	    		
	    		return inputData.OLSKThrottleCallback();
	    	},

	    	OLSKThrottleMappedTimeout (param1, param2, param3) {
	    		if (typeof param1 !== &#39;object&#39; || param1 === null) {
	    			throw new Error(&#39;OLSKErrorInputNotValid&#39;);
	    		}

	    		if (typeof param2 !== &#39;string&#39;) {
	    			throw new Error(&#39;OLSKErrorInputNotValid&#39;);
	    		}

	    		if (!mod.OLSKThrottleIsValid(param3)) {
	    			throw new Error(&#39;OLSKErrorInputNotValid&#39;);
	    		}

	    		if (!param1[param2]) {
	    			param1[param2] = Object.assign(Object.assign({}, param3), {
	    				OLSKThrottleCallback () {
	    					mod._OLSKThrottleFire(param3);

	    					// delete param1[param2]
	    				},
	    			});
	    		}

	    		return param3._OLSKThrottleTimeoutID = mod.OLSKThrottleTimeoutFor(param1[param2]);
	    	},

	    };

	    Object.assign(exports, mod);
	    });

	    var clipboard = createCommonjsModule(function (module, exports) {
	    /*!
	     * clipboard.js v2.0.8
	     * https://clipboardjs.com/
	     *
	     * Licensed MIT © Zeno Rocha
	     */
	    (function webpackUniversalModuleDefinition(root, factory) {
	    	module.exports = factory();
	    })(commonjsGlobal$1, function() {
	    return /******/ (function() { // webpackBootstrap
	    /******/ 	var __webpack_modules__ = ({

	    /***/ 134:
	    /***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

	    // EXPORTS
	    __webpack_require__.d(__webpack_exports__, {
	      &#34;default&#34;: function() { return /* binding */ clipboard; }
	    });

	    // EXTERNAL MODULE: ./node_modules/tiny-emitter/index.js
	    var tiny_emitter = __webpack_require__(279);
	    var tiny_emitter_default = /*#__PURE__*/__webpack_require__.n(tiny_emitter);
	    // EXTERNAL MODULE: ./node_modules/good-listener/src/listen.js
	    var listen = __webpack_require__(370);
	    var listen_default = /*#__PURE__*/__webpack_require__.n(listen);
	    // EXTERNAL MODULE: ./node_modules/select/src/select.js
	    var src_select = __webpack_require__(817);
	    var select_default = /*#__PURE__*/__webpack_require__.n(src_select);
	    function _typeof(obj) { &#34;@babel/helpers - typeof&#34;; if (typeof Symbol === &#34;function&#34; &amp;&amp; typeof Symbol.iterator === &#34;symbol&#34;) { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj &amp;&amp; typeof Symbol === &#34;function&#34; &amp;&amp; obj.constructor === Symbol &amp;&amp; obj !== Symbol.prototype ? &#34;symbol&#34; : typeof obj; }; } return _typeof(obj); }

	    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(&#34;Cannot call a class as a function&#34;); } }

	    function _defineProperties(target, props) { for (var i = 0; i &lt; props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (&#34;value&#34; in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

	    function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }


	    /**
	     * Inner class which performs selection from either `text` or `target`
	     * properties and then executes copy or cut operations.
	     */

	    var ClipboardAction = /*#__PURE__*/function () {
	      /**
	       * @param {Object} options
	       */
	      function ClipboardAction(options) {
	        _classCallCheck(this, ClipboardAction);

	        this.resolveOptions(options);
	        this.initSelection();
	      }
	      /**
	       * Defines base properties passed from constructor.
	       * @param {Object} options
	       */


	      _createClass(ClipboardAction, [{
	        key: &#34;resolveOptions&#34;,
	        value: function resolveOptions() {
	          var options = arguments.length &gt; 0 &amp;&amp; arguments[0] !== undefined ? arguments[0] : {};
	          this.action = options.action;
	          this.container = options.container;
	          this.emitter = options.emitter;
	          this.target = options.target;
	          this.text = options.text;
	          this.trigger = options.trigger;
	          this.selectedText = &#39;&#39;;
	        }
	        /**
	         * Decides which selection strategy is going to be applied based
	         * on the existence of `text` and `target` properties.
	         */

	      }, {
	        key: &#34;initSelection&#34;,
	        value: function initSelection() {
	          if (this.text) {
	            this.selectFake();
	          } else if (this.target) {
	            this.selectTarget();
	          }
	        }
	        /**
	         * Creates a fake textarea element, sets its value from `text` property,
	         */

	      }, {
	        key: &#34;createFakeElement&#34;,
	        value: function createFakeElement() {
	          var isRTL = document.documentElement.getAttribute(&#39;dir&#39;) === &#39;rtl&#39;;
	          this.fakeElem = document.createElement(&#39;textarea&#39;); // Prevent zooming on iOS

	          this.fakeElem.style.fontSize = &#39;12pt&#39;; // Reset box model

	          this.fakeElem.style.border = &#39;0&#39;;
	          this.fakeElem.style.padding = &#39;0&#39;;
	          this.fakeElem.style.margin = &#39;0&#39;; // Move element out of screen horizontally

	          this.fakeElem.style.position = &#39;absolute&#39;;
	          this.fakeElem.style[isRTL ? &#39;right&#39; : &#39;left&#39;] = &#39;-9999px&#39;; // Move element to the same position vertically

	          var yPosition = window.pageYOffset || document.documentElement.scrollTop;
	          this.fakeElem.style.top = &#34;&#34;.concat(yPosition, &#34;px&#34;);
	          this.fakeElem.setAttribute(&#39;readonly&#39;, &#39;&#39;);
	          this.fakeElem.value = this.text;
	          return this.fakeElem;
	        }
	        /**
	         * Get&#39;s the value of fakeElem,
	         * and makes a selection on it.
	         */

	      }, {
	        key: &#34;selectFake&#34;,
	        value: function selectFake() {
	          var _this = this;

	          var fakeElem = this.createFakeElement();

	          this.fakeHandlerCallback = function () {
	            return _this.removeFake();
	          };

	          this.fakeHandler = this.container.addEventListener(&#39;click&#39;, this.fakeHandlerCallback) || true;
	          this.container.appendChild(fakeElem);
	          this.selectedText = select_default()(fakeElem);
	          this.copyText();
	          this.removeFake();
	        }
	        /**
	         * Only removes the fake element after another click event, that way
	         * a user can hit `Ctrl+C` to copy because selection still exists.
	         */

	      }, {
	        key: &#34;removeFake&#34;,
	        value: function removeFake() {
	          if (this.fakeHandler) {
	            this.container.removeEventListener(&#39;click&#39;, this.fakeHandlerCallback);
	            this.fakeHandler = null;
	            this.fakeHandlerCallback = null;
	          }

	          if (this.fakeElem) {
	            this.container.removeChild(this.fakeElem);
	            this.fakeElem = null;
	          }
	        }
	        /**
	         * Selects the content from element passed on `target` property.
	         */

	      }, {
	        key: &#34;selectTarget&#34;,
	        value: function selectTarget() {
	          this.selectedText = select_default()(this.target);
	          this.copyText();
	        }
	        /**
	         * Executes the copy operation based on the current selection.
	         */

	      }, {
	        key: &#34;copyText&#34;,
	        value: function copyText() {
	          var succeeded;

	          try {
	            succeeded = document.execCommand(this.action);
	          } catch (err) {
	            succeeded = false;
	          }

	          this.handleResult(succeeded);
	        }
	        /**
	         * Fires an event based on the copy operation result.
	         * @param {Boolean} succeeded
	         */

	      }, {
	        key: &#34;handleResult&#34;,
	        value: function handleResult(succeeded) {
	          this.emitter.emit(succeeded ? &#39;success&#39; : &#39;error&#39;, {
	            action: this.action,
	            text: this.selectedText,
	            trigger: this.trigger,
	            clearSelection: this.clearSelection.bind(this)
	          });
	        }
	        /**
	         * Moves focus away from `target` and back to the trigger, removes current selection.
	         */

	      }, {
	        key: &#34;clearSelection&#34;,
	        value: function clearSelection() {
	          if (this.trigger) {
	            this.trigger.focus();
	          }

	          document.activeElement.blur();
	          window.getSelection().removeAllRanges();
	        }
	        /**
	         * Sets the `action` to be performed which can be either &#39;copy&#39; or &#39;cut&#39;.
	         * @param {String} action
	         */

	      }, {
	        key: &#34;destroy&#34;,

	        /**
	         * Destroy lifecycle.
	         */
	        value: function destroy() {
	          this.removeFake();
	        }
	      }, {
	        key: &#34;action&#34;,
	        set: function set() {
	          var action = arguments.length &gt; 0 &amp;&amp; arguments[0] !== undefined ? arguments[0] : &#39;copy&#39;;
	          this._action = action;

	          if (this._action !== &#39;copy&#39; &amp;&amp; this._action !== &#39;cut&#39;) {
	            throw new Error(&#39;Invalid &#34;action&#34; value, use either &#34;copy&#34; or &#34;cut&#34;&#39;);
	          }
	        }
	        /**
	         * Gets the `action` property.
	         * @return {String}
	         */
	        ,
	        get: function get() {
	          return this._action;
	        }
	        /**
	         * Sets the `target` property using an element
	         * that will be have its content copied.
	         * @param {Element} target
	         */

	      }, {
	        key: &#34;target&#34;,
	        set: function set(target) {
	          if (target !== undefined) {
	            if (target &amp;&amp; _typeof(target) === &#39;object&#39; &amp;&amp; target.nodeType === 1) {
	              if (this.action === &#39;copy&#39; &amp;&amp; target.hasAttribute(&#39;disabled&#39;)) {
	                throw new Error(&#39;Invalid &#34;target&#34; attribute. Please use &#34;readonly&#34; instead of &#34;disabled&#34; attribute&#39;);
	              }

	              if (this.action === &#39;cut&#39; &amp;&amp; (target.hasAttribute(&#39;readonly&#39;) || target.hasAttribute(&#39;disabled&#39;))) {
	                throw new Error(&#39;Invalid &#34;target&#34; attribute. You can\&#39;t cut text from elements with &#34;readonly&#34; or &#34;disabled&#34; attributes&#39;);
	              }

	              this._target = target;
	            } else {
	              throw new Error(&#39;Invalid &#34;target&#34; value, use a valid Element&#39;);
	            }
	          }
	        }
	        /**
	         * Gets the `target` property.
	         * @return {String|HTMLElement}
	         */
	        ,
	        get: function get() {
	          return this._target;
	        }
	      }]);

	      return ClipboardAction;
	    }();

	    /* harmony default export */ var clipboard_action = (ClipboardAction);
	    function clipboard_typeof(obj) { &#34;@babel/helpers - typeof&#34;; if (typeof Symbol === &#34;function&#34; &amp;&amp; typeof Symbol.iterator === &#34;symbol&#34;) { clipboard_typeof = function _typeof(obj) { return typeof obj; }; } else { clipboard_typeof = function _typeof(obj) { return obj &amp;&amp; typeof Symbol === &#34;function&#34; &amp;&amp; obj.constructor === Symbol &amp;&amp; obj !== Symbol.prototype ? &#34;symbol&#34; : typeof obj; }; } return clipboard_typeof(obj); }

	    function clipboard_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(&#34;Cannot call a class as a function&#34;); } }

	    function clipboard_defineProperties(target, props) { for (var i = 0; i &lt; props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (&#34;value&#34; in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

	    function clipboard_createClass(Constructor, protoProps, staticProps) { if (protoProps) clipboard_defineProperties(Constructor.prototype, protoProps); if (staticProps) clipboard_defineProperties(Constructor, staticProps); return Constructor; }

	    function _inherits(subClass, superClass) { if (typeof superClass !== &#34;function&#34; &amp;&amp; superClass !== null) { throw new TypeError(&#34;Super expression must either be null or a function&#34;); } subClass.prototype = Object.create(superClass &amp;&amp; superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

	    function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

	    function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

	    function _possibleConstructorReturn(self, call) { if (call &amp;&amp; (clipboard_typeof(call) === &#34;object&#34; || typeof call === &#34;function&#34;)) { return call; } return _assertThisInitialized(self); }

	    function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(&#34;this hasn&#39;t been initialised - super() hasn&#39;t been called&#34;); } return self; }

	    function _isNativeReflectConstruct() { if (typeof Reflect === &#34;undefined&#34; || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === &#34;function&#34;) return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

	    function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }




	    /**
	     * Helper function to retrieve attribute value.
	     * @param {String} suffix
	     * @param {Element} element
	     */

	    function getAttributeValue(suffix, element) {
	      var attribute = &#34;data-clipboard-&#34;.concat(suffix);

	      if (!element.hasAttribute(attribute)) {
	        return;
	      }

	      return element.getAttribute(attribute);
	    }
	    /**
	     * Base class which takes one or more elements, adds event listeners to them,
	     * and instantiates a new `ClipboardAction` on each click.
	     */


	    var Clipboard = /*#__PURE__*/function (_Emitter) {
	      _inherits(Clipboard, _Emitter);

	      var _super = _createSuper(Clipboard);

	      /**
	       * @param {String|HTMLElement|HTMLCollection|NodeList} trigger
	       * @param {Object} options
	       */
	      function Clipboard(trigger, options) {
	        var _this;

	        clipboard_classCallCheck(this, Clipboard);

	        _this = _super.call(this);

	        _this.resolveOptions(options);

	        _this.listenClick(trigger);

	        return _this;
	      }
	      /**
	       * Defines if attributes would be resolved using internal setter functions
	       * or custom functions that were passed in the constructor.
	       * @param {Object} options
	       */


	      clipboard_createClass(Clipboard, [{
	        key: &#34;resolveOptions&#34;,
	        value: function resolveOptions() {
	          var options = arguments.length &gt; 0 &amp;&amp; arguments[0] !== undefined ? arguments[0] : {};
	          this.action = typeof options.action === &#39;function&#39; ? options.action : this.defaultAction;
	          this.target = typeof options.target === &#39;function&#39; ? options.target : this.defaultTarget;
	          this.text = typeof options.text === &#39;function&#39; ? options.text : this.defaultText;
	          this.container = clipboard_typeof(options.container) === &#39;object&#39; ? options.container : document.body;
	        }
	        /**
	         * Adds a click event listener to the passed trigger.
	         * @param {String|HTMLElement|HTMLCollection|NodeList} trigger
	         */

	      }, {
	        key: &#34;listenClick&#34;,
	        value: function listenClick(trigger) {
	          var _this2 = this;

	          this.listener = listen_default()(trigger, &#39;click&#39;, function (e) {
	            return _this2.onClick(e);
	          });
	        }
	        /**
	         * Defines a new `ClipboardAction` on each click event.
	         * @param {Event} e
	         */

	      }, {
	        key: &#34;onClick&#34;,
	        value: function onClick(e) {
	          var trigger = e.delegateTarget || e.currentTarget;

	          if (this.clipboardAction) {
	            this.clipboardAction = null;
	          }

	          this.clipboardAction = new clipboard_action({
	            action: this.action(trigger),
	            target: this.target(trigger),
	            text: this.text(trigger),
	            container: this.container,
	            trigger: trigger,
	            emitter: this
	          });
	        }
	        /**
	         * Default `action` lookup function.
	         * @param {Element} trigger
	         */

	      }, {
	        key: &#34;defaultAction&#34;,
	        value: function defaultAction(trigger) {
	          return getAttributeValue(&#39;action&#39;, trigger);
	        }
	        /**
	         * Default `target` lookup function.
	         * @param {Element} trigger
	         */

	      }, {
	        key: &#34;defaultTarget&#34;,
	        value: function defaultTarget(trigger) {
	          var selector = getAttributeValue(&#39;target&#39;, trigger);

	          if (selector) {
	            return document.querySelector(selector);
	          }
	        }
	        /**
	         * Returns the support of the given action, or all actions if no action is
	         * given.
	         * @param {String} [action]
	         */

	      }, {
	        key: &#34;defaultText&#34;,

	        /**
	         * Default `text` lookup function.
	         * @param {Element} trigger
	         */
	        value: function defaultText(trigger) {
	          return getAttributeValue(&#39;text&#39;, trigger);
	        }
	        /**
	         * Destroy lifecycle.
	         */

	      }, {
	        key: &#34;destroy&#34;,
	        value: function destroy() {
	          this.listener.destroy();

	          if (this.clipboardAction) {
	            this.clipboardAction.destroy();
	            this.clipboardAction = null;
	          }
	        }
	      }], [{
	        key: &#34;isSupported&#34;,
	        value: function isSupported() {
	          var action = arguments.length &gt; 0 &amp;&amp; arguments[0] !== undefined ? arguments[0] : [&#39;copy&#39;, &#39;cut&#39;];
	          var actions = typeof action === &#39;string&#39; ? [action] : action;
	          var support = !!document.queryCommandSupported;
	          actions.forEach(function (action) {
	            support = support &amp;&amp; !!document.queryCommandSupported(action);
	          });
	          return support;
	        }
	      }]);

	      return Clipboard;
	    }((tiny_emitter_default()));

	    /* harmony default export */ var clipboard = (Clipboard);

	    /***/ }),

	    /***/ 828:
	    /***/ (function(module) {

	    var DOCUMENT_NODE_TYPE = 9;

	    /**
	     * A polyfill for Element.matches()
	     */
	    if (typeof Element !== &#39;undefined&#39; &amp;&amp; !Element.prototype.matches) {
	        var proto = Element.prototype;

	        proto.matches = proto.matchesSelector ||
	                        proto.mozMatchesSelector ||
	                        proto.msMatchesSelector ||
	                        proto.oMatchesSelector ||
	                        proto.webkitMatchesSelector;
	    }

	    /**
	     * Finds the closest parent that matches a selector.
	     *
	     * @param {Element} element
	     * @param {String} selector
	     * @return {Function}
	     */
	    function closest (element, selector) {
	        while (element &amp;&amp; element.nodeType !== DOCUMENT_NODE_TYPE) {
	            if (typeof element.matches === &#39;function&#39; &amp;&amp;
	                element.matches(selector)) {
	              return element;
	            }
	            element = element.parentNode;
	        }
	    }

	    module.exports = closest;


	    /***/ }),

	    /***/ 438:
	    /***/ (function(module, __unused_webpack_exports, __webpack_require__) {

	    var closest = __webpack_require__(828);

	    /**
	     * Delegates event to a selector.
	     *
	     * @param {Element} element
	     * @param {String} selector
	     * @param {String} type
	     * @param {Function} callback
	     * @param {Boolean} useCapture
	     * @return {Object}
	     */
	    function _delegate(element, selector, type, callback, useCapture) {
	        var listenerFn = listener.apply(this, arguments);

	        element.addEventListener(type, listenerFn, useCapture);

	        return {
	            destroy: function() {
	                element.removeEventListener(type, listenerFn, useCapture);
	            }
	        }
	    }

	    /**
	     * Delegates event to a selector.
	     *
	     * @param {Element|String|Array} [elements]
	     * @param {String} selector
	     * @param {String} type
	     * @param {Function} callback
	     * @param {Boolean} useCapture
	     * @return {Object}
	     */
	    function delegate(elements, selector, type, callback, useCapture) {
	        // Handle the regular Element usage
	        if (typeof elements.addEventListener === &#39;function&#39;) {
	            return _delegate.apply(null, arguments);
	        }

	        // Handle Element-less usage, it defaults to global delegation
	        if (typeof type === &#39;function&#39;) {
	            // Use `document` as the first parameter, then apply arguments
	            // This is a short way to .unshift `arguments` without running into deoptimizations
	            return _delegate.bind(null, document).apply(null, arguments);
	        }

	        // Handle Selector-based usage
	        if (typeof elements === &#39;string&#39;) {
	            elements = document.querySelectorAll(elements);
	        }

	        // Handle Array-like based usage
	        return Array.prototype.map.call(elements, function (element) {
	            return _delegate(element, selector, type, callback, useCapture);
	        });
	    }

	    /**
	     * Finds closest match and invokes callback.
	     *
	     * @param {Element} element
	     * @param {String} selector
	     * @param {String} type
	     * @param {Function} callback
	     * @return {Function}
	     */
	    function listener(element, selector, type, callback) {
	        return function(e) {
	            e.delegateTarget = closest(e.target, selector);

	            if (e.delegateTarget) {
	                callback.call(element, e);
	            }
	        }
	    }

	    module.exports = delegate;


	    /***/ }),

	    /***/ 879:
	    /***/ (function(__unused_webpack_module, exports) {

	    /**
	     * Check if argument is a HTML element.
	     *
	     * @param {Object} value
	     * @return {Boolean}
	     */
	    exports.node = function(value) {
	        return value !== undefined
	            &amp;&amp; value instanceof HTMLElement
	            &amp;&amp; value.nodeType === 1;
	    };

	    /**
	     * Check if argument is a list of HTML elements.
	     *
	     * @param {Object} value
	     * @return {Boolean}
	     */
	    exports.nodeList = function(value) {
	        var type = Object.prototype.toString.call(value);

	        return value !== undefined
	            &amp;&amp; (type === &#39;[object NodeList]&#39; || type === &#39;[object HTMLCollection]&#39;)
	            &amp;&amp; (&#39;length&#39; in value)
	            &amp;&amp; (value.length === 0 || exports.node(value[0]));
	    };

	    /**
	     * Check if argument is a string.
	     *
	     * @param {Object} value
	     * @return {Boolean}
	     */
	    exports.string = function(value) {
	        return typeof value === &#39;string&#39;
	            || value instanceof String;
	    };

	    /**
	     * Check if argument is a function.
	     *
	     * @param {Object} value
	     * @return {Boolean}
	     */
	    exports.fn = function(value) {
	        var type = Object.prototype.toString.call(value);

	        return type === &#39;[object Function]&#39;;
	    };


	    /***/ }),

	    /***/ 370:
	    /***/ (function(module, __unused_webpack_exports, __webpack_require__) {

	    var is = __webpack_require__(879);
	    var delegate = __webpack_require__(438);

	    /**
	     * Validates all params and calls the right
	     * listener function based on its target type.
	     *
	     * @param {String|HTMLElement|HTMLCollection|NodeList} target
	     * @param {String} type
	     * @param {Function} callback
	     * @return {Object}
	     */
	    function listen(target, type, callback) {
	        if (!target &amp;&amp; !type &amp;&amp; !callback) {
	            throw new Error(&#39;Missing required arguments&#39;);
	        }

	        if (!is.string(type)) {
	            throw new TypeError(&#39;Second argument must be a String&#39;);
	        }

	        if (!is.fn(callback)) {
	            throw new TypeError(&#39;Third argument must be a Function&#39;);
	        }

	        if (is.node(target)) {
	            return listenNode(target, type, callback);
	        }
	        else if (is.nodeList(target)) {
	            return listenNodeList(target, type, callback);
	        }
	        else if (is.string(target)) {
	            return listenSelector(target, type, callback);
	        }
	        else {
	            throw new TypeError(&#39;First argument must be a String, HTMLElement, HTMLCollection, or NodeList&#39;);
	        }
	    }

	    /**
	     * Adds an event listener to a HTML element
	     * and returns a remove listener function.
	     *
	     * @param {HTMLElement} node
	     * @param {String} type
	     * @param {Function} callback
	     * @return {Object}
	     */
	    function listenNode(node, type, callback) {
	        node.addEventListener(type, callback);

	        return {
	            destroy: function() {
	                node.removeEventListener(type, callback);
	            }
	        }
	    }

	    /**
	     * Add an event listener to a list of HTML elements
	     * and returns a remove listener function.
	     *
	     * @param {NodeList|HTMLCollection} nodeList
	     * @param {String} type
	     * @param {Function} callback
	     * @return {Object}
	     */
	    function listenNodeList(nodeList, type, callback) {
	        Array.prototype.forEach.call(nodeList, function(node) {
	            node.addEventListener(type, callback);
	        });

	        return {
	            destroy: function() {
	                Array.prototype.forEach.call(nodeList, function(node) {
	                    node.removeEventListener(type, callback);
	                });
	            }
	        }
	    }

	    /**
	     * Add an event listener to a selector
	     * and returns a remove listener function.
	     *
	     * @param {String} selector
	     * @param {String} type
	     * @param {Function} callback
	     * @return {Object}
	     */
	    function listenSelector(selector, type, callback) {
	        return delegate(document.body, selector, type, callback);
	    }

	    module.exports = listen;


	    /***/ }),

	    /***/ 817:
	    /***/ (function(module) {

	    function select(element) {
	        var selectedText;

	        if (element.nodeName === &#39;SELECT&#39;) {
	            element.focus();

	            selectedText = element.value;
	        }
	        else if (element.nodeName === &#39;INPUT&#39; || element.nodeName === &#39;TEXTAREA&#39;) {
	            var isReadOnly = element.hasAttribute(&#39;readonly&#39;);

	            if (!isReadOnly) {
	                element.setAttribute(&#39;readonly&#39;, &#39;&#39;);
	            }

	            element.select();
	            element.setSelectionRange(0, element.value.length);

	            if (!isReadOnly) {
	                element.removeAttribute(&#39;readonly&#39;);
	            }

	            selectedText = element.value;
	        }
	        else {
	            if (element.hasAttribute(&#39;contenteditable&#39;)) {
	                element.focus();
	            }

	            var selection = window.getSelection();
	            var range = document.createRange();

	            range.selectNodeContents(element);
	            selection.removeAllRanges();
	            selection.addRange(range);

	            selectedText = selection.toString();
	        }

	        return selectedText;
	    }

	    module.exports = select;


	    /***/ }),

	    /***/ 279:
	    /***/ (function(module) {

	    function E () {
	      // Keep this empty so it&#39;s easier to inherit from
	      // (via https://github.com/lipsmack from https://github.com/scottcorgan/tiny-emitter/issues/3)
	    }

	    E.prototype = {
	      on: function (name, callback, ctx) {
	        var e = this.e || (this.e = {});

	        (e[name] || (e[name] = [])).push({
	          fn: callback,
	          ctx: ctx
	        });

	        return this;
	      },

	      once: function (name, callback, ctx) {
	        var self = this;
	        function listener () {
	          self.off(name, listener);
	          callback.apply(ctx, arguments);
	        }
	        listener._ = callback;
	        return this.on(name, listener, ctx);
	      },

	      emit: function (name) {
	        var data = [].slice.call(arguments, 1);
	        var evtArr = ((this.e || (this.e = {}))[name] || []).slice();
	        var i = 0;
	        var len = evtArr.length;

	        for (i; i &lt; len; i++) {
	          evtArr[i].fn.apply(evtArr[i].ctx, data);
	        }

	        return this;
	      },

	      off: function (name, callback) {
	        var e = this.e || (this.e = {});
	        var evts = e[name];
	        var liveEvents = [];

	        if (evts &amp;&amp; callback) {
	          for (var i = 0, len = evts.length; i &lt; len; i++) {
	            if (evts[i].fn !== callback &amp;&amp; evts[i].fn._ !== callback)
	              liveEvents.push(evts[i]);
	          }
	        }

	        // Remove event from queue to prevent memory leak
	        // Suggested by https://github.com/lazd
	        // Ref: https://github.com/scottcorgan/tiny-emitter/commit/c6ebfaa9bc973b33d110a84a307742b7cf94c953#commitcomment-5024910

	        (liveEvents.length)
	          ? e[name] = liveEvents
	          : delete e[name];

	        return this;
	      }
	    };

	    module.exports = E;
	    module.exports.TinyEmitter = E;


	    /***/ })

	    /******/ 	});
	    /************************************************************************/
	    /******/ 	// The module cache
	    /******/ 	var __webpack_module_cache__ = {};
	    /******/ 	
	    /******/ 	// The require function
	    /******/ 	function __webpack_require__(moduleId) {
	    /******/ 		// Check if module is in cache
	    /******/ 		if(__webpack_module_cache__[moduleId]) {
	    /******/ 			return __webpack_module_cache__[moduleId].exports;
	    /******/ 		}
	    /******/ 		// Create a new module (and put it into the cache)
	    /******/ 		var module = __webpack_module_cache__[moduleId] = {
	    /******/ 			// no module.id needed
	    /******/ 			// no module.loaded needed
	    /******/ 			exports: {}
	    /******/ 		};
	    /******/ 	
	    /******/ 		// Execute the module function
	    /******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
	    /******/ 	
	    /******/ 		// Return the exports of the module
	    /******/ 		return module.exports;
	    /******/ 	}
	    /******/ 	
	    /************************************************************************/
	    /******/ 	/* webpack/runtime/compat get default export */
	    /******/ 	!function() {
	    /******/ 		// getDefaultExport function for compatibility with non-harmony modules
	    /******/ 		__webpack_require__.n = function(module) {
	    /******/ 			var getter = module &amp;&amp; module.__esModule ?
	    /******/ 				function() { return module[&#39;default&#39;]; } :
	    /******/ 				function() { return module; };
	    /******/ 			__webpack_require__.d(getter, { a: getter });
	    /******/ 			return getter;
	    /******/ 		};
	    /******/ 	}();
	    /******/ 	
	    /******/ 	/* webpack/runtime/define property getters */
	    /******/ 	!function() {
	    /******/ 		// define getter functions for harmony exports
	    /******/ 		__webpack_require__.d = function(exports, definition) {
	    /******/ 			for(var key in definition) {
	    /******/ 				if(__webpack_require__.o(definition, key) &amp;&amp; !__webpack_require__.o(exports, key)) {
	    /******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
	    /******/ 				}
	    /******/ 			}
	    /******/ 		};
	    /******/ 	}();
	    /******/ 	
	    /******/ 	/* webpack/runtime/hasOwnProperty shorthand */
	    /******/ 	!function() {
	    /******/ 		__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); };
	    /******/ 	}();
	    /******/ 	
	    /************************************************************************/
	    /******/ 	// module exports must be returned from runtime so entry inlining is disabled
	    /******/ 	// startup
	    /******/ 	// Load entry module and return exports
	    /******/ 	return __webpack_require__(134);
	    /******/ })()
	    .default;
	    });
	    });

	    var Clipboard = unwrapExports(clipboard);

	    /* os-app/dev-launcher/recipes/actions/LCHCopyToClipboard/main.svelte generated by Svelte v3.38.2 */
	    const file = &#34;os-app/dev-launcher/recipes/actions/LCHCopyToClipboard/main.svelte&#34;;

	    function create_fragment(ctx) {
	    	let button;
	    	let t_value = /*OLSKLocalized*/ ctx[1](&#34;LCHCopyToClipboardButtonText&#34;) + &#34;&#34;;
	    	let t;

	    	const block = {
	    		c: function create() {
	    			button = element(&#34;button&#34;);
	    			t = text(t_value);
	    			attr_dev(button, &#34;class&#34;, &#34;LCHCopyToClipboardButton&#34;);
	    			attr_dev(button, &#34;data-clipboard-text&#34;, /*inputData*/ ctx[0]);
	    			add_location(button, file, 52, 0, 895);
	    		},
	    		l: function claim(nodes) {
	    			throw new Error(&#34;options.hydrate only works if the component was compiled with the `hydratable: true` option&#34;);
	    		},
	    		m: function mount(target, anchor) {
	    			insert_dev(target, button, anchor);
	    			append_dev(button, t);
	    			/*button_binding*/ ctx[4](button);
	    		},
	    		p: function update(ctx, [dirty]) {
	    			if (dirty &amp; /*OLSKLocalized*/ 2 &amp;&amp; t_value !== (t_value = /*OLSKLocalized*/ ctx[1](&#34;LCHCopyToClipboardButtonText&#34;) + &#34;&#34;)) set_data_dev(t, t_value);

	    			if (dirty &amp; /*inputData*/ 1) {
	    				attr_dev(button, &#34;data-clipboard-text&#34;, /*inputData*/ ctx[0]);
	    			}
	    		},
	    		i: noop,
	    		o: noop,
	    		d: function destroy(detaching) {
	    			if (detaching) detach_dev(button);
	    			/*button_binding*/ ctx[4](null);
	    		}
	    	};

	    	dispatch_dev(&#34;SvelteRegisterBlock&#34;, {
	    		block,
	    		id: create_fragment.name,
	    		type: &#34;component&#34;,
	    		source: &#34;&#34;,
	    		ctx
	    	});

	    	return block;
	    }

	    function instance($$self, $$props, $$invalidate) {
	    	let { $$slots: slots = {}, $$scope } = $$props;
	    	validate_slots(&#34;Main&#34;, slots, []);
	    	let { inputData } = $$props;
	    	let { LCHCopyToClipboardCompletionHandler } = $$props;
	    	let { OLSKLocalized } = $$props;
	    	let clipboardButton, clipboard;
	    	let _didComplete = false;

	    	function didComplete() {
	    		if (_didComplete) {
	    			return;
	    		}

	    		clipboard.destroy();
	    		LCHCopyToClipboardCompletionHandler();
	    		_didComplete = true;
	    	}

	    	onMount(function () {
	    		clipboard = new Clipboard(clipboardButton);

	    		clipboard.on(&#34;success&#34;, function (e) {
	    			// console.log(&#39;success&#39;, e);
	    			didComplete();
	    		});

	    		clipboard.on(&#34;error&#34;, function (e) {
	    			// console.log(&#39;error&#39;, e);
	    			didComplete();
	    		});

	    		clipboardButton.addEventListener(&#34;click&#34;, function (e) {
	    			// console.log(&#39;click&#39;, e);
	    			didComplete();
	    		});

	    		clipboardButton.focus();

	    		if (main_1()) {
	    			return;
	    		}

	    		clipboardButton.click();
	    	});

	    	const writable_props = [&#34;inputData&#34;, &#34;LCHCopyToClipboardCompletionHandler&#34;, &#34;OLSKLocalized&#34;];

	    	Object.keys($$props).forEach(key =&gt; {
	    		if (!~writable_props.indexOf(key) &amp;&amp; key.slice(0, 2) !== &#34;$$&#34;) console.warn(`&lt;Main&gt; was created with unknown prop &#39;${key}&#39;`);
	    	});

	    	function button_binding($$value) {
	    		binding_callbacks[$$value ? &#34;unshift&#34; : &#34;push&#34;](() =&gt; {
	    			clipboardButton = $$value;
	    			$$invalidate(2, clipboardButton);
	    		});
	    	}

	    	$$self.$$set = $$props =&gt; {
	    		if (&#34;inputData&#34; in $$props) $$invalidate(0, inputData = $$props.inputData);
	    		if (&#34;LCHCopyToClipboardCompletionHandler&#34; in $$props) $$invalidate(3, LCHCopyToClipboardCompletionHandler = $$props.LCHCopyToClipboardCompletionHandler);
	    		if (&#34;OLSKLocalized&#34; in $$props) $$invalidate(1, OLSKLocalized = $$props.OLSKLocalized);
	    	};

	    	$$self.$capture_state = () =&gt; ({
	    		inputData,
	    		LCHCopyToClipboardCompletionHandler,
	    		OLSKLocalized,
	    		OLSK_SPEC_UI: main_1,
	    		onMount,
	    		Clipboard,
	    		clipboardButton,
	    		clipboard,
	    		_didComplete,
	    		didComplete
	    	});

	    	$$self.$inject_state = $$props =&gt; {
	    		if (&#34;inputData&#34; in $$props) $$invalidate(0, inputData = $$props.inputData);
	    		if (&#34;LCHCopyToClipboardCompletionHandler&#34; in $$props) $$invalidate(3, LCHCopyToClipboardCompletionHandler = $$props.LCHCopyToClipboardCompletionHandler);
	    		if (&#34;OLSKLocalized&#34; in $$props) $$invalidate(1, OLSKLocalized = $$props.OLSKLocalized);
	    		if (&#34;clipboardButton&#34; in $$props) $$invalidate(2, clipboardButton = $$props.clipboardButton);
	    		if (&#34;clipboard&#34; in $$props) clipboard = $$props.clipboard;
	    		if (&#34;_didComplete&#34; in $$props) _didComplete = $$props._didComplete;
	    	};

	    	if ($$props &amp;&amp; &#34;$$inject&#34; in $$props) {
	    		$$self.$inject_state($$props.$$inject);
	    	}

	    	return [
	    		inputData,
	    		OLSKLocalized,
	    		clipboardButton,
	    		LCHCopyToClipboardCompletionHandler,
	    		button_binding
	    	];
	    }

	    class Main extends SvelteComponentDev {
	    	constructor(options) {
	    		super(options);

	    		init(this, options, instance, create_fragment, safe_not_equal, {
	    			inputData: 0,
	    			LCHCopyToClipboardCompletionHandler: 3,
	    			OLSKLocalized: 1
	    		});

	    		dispatch_dev(&#34;SvelteRegisterComponent&#34;, {
	    			component: this,
	    			tagName: &#34;Main&#34;,
	    			options,
	    			id: create_fragment.name
	    		});

	    		const { ctx } = this.$$;
	    		const props = options.props || {};

	    		if (/*inputData*/ ctx[0] === undefined &amp;&amp; !(&#34;inputData&#34; in props)) {
	    			console.warn(&#34;&lt;Main&gt; was created without expected prop &#39;inputData&#39;&#34;);
	    		}

	    		if (/*LCHCopyToClipboardCompletionHandler*/ ctx[3] === undefined &amp;&amp; !(&#34;LCHCopyToClipboardCompletionHandler&#34; in props)) {
	    			console.warn(&#34;&lt;Main&gt; was created without expected prop &#39;LCHCopyToClipboardCompletionHandler&#39;&#34;);
	    		}

	    		if (/*OLSKLocalized*/ ctx[1] === undefined &amp;&amp; !(&#34;OLSKLocalized&#34; in props)) {
	    			console.warn(&#34;&lt;Main&gt; was created without expected prop &#39;OLSKLocalized&#39;&#34;);
	    		}
	    	}

	    	get inputData() {
	    		throw new Error(&#34;&lt;Main&gt;: Props cannot be read directly from the component instance unless compiling with &#39;accessors: true&#39; or &#39;&lt;svelte:options accessors/&gt;&#39;&#34;);
	    	}

	    	set inputData(value) {
	    		throw new Error(&#34;&lt;Main&gt;: Props cannot be set directly on the component instance unless compiling with &#39;accessors: true&#39; or &#39;&lt;svelte:options accessors/&gt;&#39;&#34;);
	    	}

	    	get LCHCopyToClipboardCompletionHandler() {
	    		throw new Error(&#34;&lt;Main&gt;: Props cannot be read directly from the component instance unless compiling with &#39;accessors: true&#39; or &#39;&lt;svelte:options accessors/&gt;&#39;&#34;);
	    	}

	    	set LCHCopyToClipboardCompletionHandler(value) {
	    		throw new Error(&#34;&lt;Main&gt;: Props cannot be set directly on the component instance unless compiling with &#39;accessors: true&#39; or &#39;&lt;svelte:options accessors/&gt;&#39;&#34;);
	    	}

	    	get OLSKLocalized() {
	    		throw new Error(&#34;&lt;Main&gt;: Props cannot be read directly from the component instance unless compiling with &#39;accessors: true&#39; or &#39;&lt;svelte:options accessors/&gt;&#39;&#34;);
	    	}

	    	set OLSKLocalized(value) {
	    		throw new Error(&#34;&lt;Main&gt;: Props cannot be set directly on the component instance unless compiling with &#39;accessors: true&#39; or &#39;&lt;svelte:options accessors/&gt;&#39;&#34;);
	    	}
	    }

	    const LCHCopyToClipboard$1 = Main;

	    var apiComponents = /*#__PURE__*/Object.freeze({
	        LCHCopyToClipboard: LCHCopyToClipboard$1
	    });

	    var uiLogic = createCommonjsModule(function (module, exports) {
	    const mod = {

	    	OLSKResultsConstrainIndex (param1, param2) {
	    		if (!Array.isArray(param1)) {
	    			throw new Error(&#39;OLSKErrorInputNotValid&#39;);
	    		}

	    		if (typeof param2 !== &#39;number&#39;) {
	    			throw new Error(&#39;OLSKErrorInputNotValid&#39;);
	    		}

	    		if (param2 &lt; 0) {
	    			return param1.length - 1;
	    		}

	    		if (param2 &gt;= param1.length) {
	    			return 0;
	    		}

	    		return param2;
	    	},

	    };

	    Object.assign(exports, mod);
	    });

	    /* node_modules/OLSKResults/main.svelte generated by Svelte v3.38.2 */
	    const file$1 = &#34;node_modules/OLSKResults/main.svelte&#34;;

	    const get_OLSKResultsEmpty_slot_changes = dirty =&gt; ({
	    	OLSKResultsListItem: dirty &amp; /*OLSKResultsListItems*/ 1
	    });

	    const get_OLSKResultsEmpty_slot_context = ctx =&gt; ({ OLSKResultsListItem: /*e*/ ctx[10] });

	    function get_each_context(ctx, list, i) {
	    	const child_ctx = ctx.slice();
	    	child_ctx[10] = list[i];
	    	return child_ctx;
	    }

	    const get_default_slot_changes = dirty =&gt; ({
	    	OLSKResultsListItem: dirty &amp; /*OLSKResultsListItems*/ 1
	    });

	    const get_default_slot_context = ctx =&gt; ({ OLSKResultsListItem: /*e*/ ctx[10] });

	    // (72:0) {:else}
	    function create_else_block(ctx) {
	    	let div;
	    	let current;
	    	const OLSKResultsEmpty_slot_template = /*#slots*/ ctx[8].OLSKResultsEmpty;
	    	const OLSKResultsEmpty_slot = create_slot(OLSKResultsEmpty_slot_template, ctx, /*$$scope*/ ctx[7], get_OLSKResultsEmpty_slot_context);

	    	const block = {
	    		c: function create() {
	    			div = element(&#34;div&#34;);
	    			if (OLSKResultsEmpty_slot) OLSKResultsEmpty_slot.c();
	    			attr_dev(div, &#34;class&#34;, &#34;OLSKResultsEmpty&#34;);
	    			add_location(div, file$1, 72, 1, 1765);
	    		},
	    		m: function mount(target, anchor) {
	    			insert_dev(target, div, anchor);

	    			if (OLSKResultsEmpty_slot) {
	    				OLSKResultsEmpty_slot.m(div, null);
	    			}

	    			current = true;
	    		},
	    		p: function update(ctx, dirty) {
	    			if (OLSKResultsEmpty_slot) {
	    				if (OLSKResultsEmpty_slot.p &amp;&amp; (!current || dirty &amp; /*$$scope, OLSKResultsListItems*/ 129)) {
	    					update_slot(OLSKResultsEmpty_slot, OLSKResultsEmpty_slot_template, ctx, /*$$scope*/ ctx[7], dirty, get_OLSKResultsEmpty_slot_changes, get_OLSKResultsEmpty_slot_context);
	    				}
	    			}
	    		},
	    		i: function intro(local) {
	    			if (current) return;
	    			transition_in(OLSKResultsEmpty_slot, local);
	    			current = true;
	    		},
	    		o: function outro(local) {
	    			transition_out(OLSKResultsEmpty_slot, local);
	    			current = false;
	    		},
	    		d: function destroy(detaching) {
	    			if (detaching) detach_dev(div);
	    			if (OLSKResultsEmpty_slot) OLSKResultsEmpty_slot.d(detaching);
	    		}
	    	};

	    	dispatch_dev(&#34;SvelteRegisterBlock&#34;, {
	    		block,
	    		id: create_else_block.name,
	    		type: &#34;else&#34;,
	    		source: &#34;(72:0) {:else}&#34;,
	    		ctx
	    	});

	    	return block;
	    }

	    // (64:0) {#if OLSKResultsListItems.length}
	    function create_if_block(ctx) {
	    	let div;
	    	let current;
	    	let each_value = /*OLSKResultsListItems*/ ctx[0];
	    	validate_each_argument(each_value);
	    	let each_blocks = [];

	    	for (let i = 0; i &lt; each_value.length; i += 1) {
	    		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
	    	}

	    	const out = i =&gt; transition_out(each_blocks[i], 1, 1, () =&gt; {
	    		each_blocks[i] = null;
	    	});

	    	const block = {
	    		c: function create() {
	    			div = element(&#34;div&#34;);

	    			for (let i = 0; i &lt; each_blocks.length; i += 1) {
	    				each_blocks[i].c();
	    			}

	    			attr_dev(div, &#34;class&#34;, &#34;OLSKResultsList&#34;);
	    			add_location(div, file$1, 64, 1, 1462);
	    		},
	    		m: function mount(target, anchor) {
	    			insert_dev(target, div, anchor);

	    			for (let i = 0; i &lt; each_blocks.length; i += 1) {
	    				each_blocks[i].m(div, null);
	    			}

	    			current = true;
	    		},
	    		p: function update(ctx, dirty) {
	    			if (dirty &amp; /*OLSKResultsListItems, OLSKResultsListItemSelected, OLSKResultsDispatchClick, $$scope*/ 135) {
	    				each_value = /*OLSKResultsListItems*/ ctx[0];
	    				validate_each_argument(each_value);
	    				let i;

	    				for (i = 0; i &lt; each_value.length; i += 1) {
	    					const child_ctx = get_each_context(ctx, each_value, i);

	    					if (each_blocks[i]) {
	    						each_blocks[i].p(child_ctx, dirty);
	    						transition_in(each_blocks[i], 1);
	    					} else {
	    						each_blocks[i] = create_each_block(child_ctx);
	    						each_blocks[i].c();
	    						transition_in(each_blocks[i], 1);
	    						each_blocks[i].m(div, null);
	    					}
	    				}

	    				group_outros();

	    				for (i = each_value.length; i &lt; each_blocks.length; i += 1) {
	    					out(i);
	    				}

	    				check_outros();
	    			}
	    		},
	    		i: function intro(local) {
	    			if (current) return;

	    			for (let i = 0; i &lt; each_value.length; i += 1) {
	    				transition_in(each_blocks[i]);
	    			}

	    			current = true;
	    		},
	    		o: function outro(local) {
	    			each_blocks = each_blocks.filter(Boolean);

	    			for (let i = 0; i &lt; each_blocks.length; i += 1) {
	    				transition_out(each_blocks[i]);
	    			}

	    			current = false;
	    		},
	    		d: function destroy(detaching) {
	    			if (detaching) detach_dev(div);
	    			destroy_each(each_blocks, detaching);
	    		}
	    	};

	    	dispatch_dev(&#34;SvelteRegisterBlock&#34;, {
	    		block,
	    		id: create_if_block.name,
	    		type: &#34;if&#34;,
	    		source: &#34;(64:0) {#if OLSKResultsListItems.length}&#34;,
	    		ctx
	    	});

	    	return block;
	    }

	    // (66:2) {#each OLSKResultsListItems as e}
	    function create_each_block(ctx) {
	    	let div;
	    	let t;
	    	let current;
	    	let mounted;
	    	let dispose;
	    	const default_slot_template = /*#slots*/ ctx[8].default;
	    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[7], get_default_slot_context);

	    	function click_handler() {
	    		return /*click_handler*/ ctx[9](/*e*/ ctx[10]);
	    	}

	    	const block = {
	    		c: function create() {
	    			div = element(&#34;div&#34;);
	    			if (default_slot) default_slot.c();
	    			t = space();
	    			attr_dev(div, &#34;class&#34;, &#34;OLSKResultsListItem svelte-617v38&#34;);
	    			toggle_class(div, &#34;OLSKResultsListItemSelected&#34;, /*e*/ ctx[10] === /*OLSKResultsListItemSelected*/ ctx[1]);
	    			add_location(div, file$1, 66, 3, 1531);
	    		},
	    		m: function mount(target, anchor) {
	    			insert_dev(target, div, anchor);

	    			if (default_slot) {
	    				default_slot.m(div, null);
	    			}

	    			append_dev(div, t);
	    			current = true;

	    			if (!mounted) {
	    				dispose = listen_dev(div, &#34;click&#34;, click_handler, false, false, false);
	    				mounted = true;
	    			}
	    		},
	    		p: function update(new_ctx, dirty) {
	    			ctx = new_ctx;

	    			if (default_slot) {
	    				if (default_slot.p &amp;&amp; (!current || dirty &amp; /*$$scope, OLSKResultsListItems*/ 129)) {
	    					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[7], dirty, get_default_slot_changes, get_default_slot_context);
	    				}
	    			}

	    			if (dirty &amp; /*OLSKResultsListItems, OLSKResultsListItemSelected*/ 3) {
	    				toggle_class(div, &#34;OLSKResultsListItemSelected&#34;, /*e*/ ctx[10] === /*OLSKResultsListItemSelected*/ ctx[1]);
	    			}
	    		},
	    		i: function intro(local) {
	    			if (current) return;
	    			transition_in(default_slot, local);
	    			current = true;
	    		},
	    		o: function outro(local) {
	    			transition_out(default_slot, local);
	    			current = false;
	    		},
	    		d: function destroy(detaching) {
	    			if (detaching) detach_dev(div);
	    			if (default_slot) default_slot.d(detaching);
	    			mounted = false;
	    			dispose();
	    		}
	    	};

	    	dispatch_dev(&#34;SvelteRegisterBlock&#34;, {
	    		block,
	    		id: create_each_block.name,
	    		type: &#34;each&#34;,
	    		source: &#34;(66:2) {#each OLSKResultsListItems as e}&#34;,
	    		ctx
	    	});

	    	return block;
	    }

	    function create_fragment$1(ctx) {
	    	let div;
	    	let current_block_type_index;
	    	let if_block;
	    	let current;
	    	let mounted;
	    	let dispose;
	    	const if_block_creators = [create_if_block, create_else_block];
	    	const if_blocks = [];

	    	function select_block_type(ctx, dirty) {
	    		if (/*OLSKResultsListItems*/ ctx[0].length) return 0;
	    		return 1;
	    	}

	    	current_block_type_index = select_block_type(ctx);
	    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	    	const block = {
	    		c: function create() {
	    			div = element(&#34;div&#34;);
	    			if_block.c();
	    			attr_dev(div, &#34;class&#34;, &#34;OLSKResults&#34;);
	    			add_location(div, file$1, 61, 0, 1400);
	    		},
	    		l: function claim(nodes) {
	    			throw new Error(&#34;options.hydrate only works if the component was compiled with the `hydratable: true` option&#34;);
	    		},
	    		m: function mount(target, anchor) {
	    			insert_dev(target, div, anchor);
	    			if_blocks[current_block_type_index].m(div, null);
	    			current = true;

	    			if (!mounted) {
	    				dispose = listen_dev(window, &#34;keydown&#34;, /*mod*/ ctx[3].InterfaceWindowDidKeydown, false, false, false);
	    				mounted = true;
	    			}
	    		},
	    		p: function update(ctx, [dirty]) {
	    			let previous_block_index = current_block_type_index;
	    			current_block_type_index = select_block_type(ctx);

	    			if (current_block_type_index === previous_block_index) {
	    				if_blocks[current_block_type_index].p(ctx, dirty);
	    			} else {
	    				group_outros();

	    				transition_out(if_blocks[previous_block_index], 1, 1, () =&gt; {
	    					if_blocks[previous_block_index] = null;
	    				});

	    				check_outros();
	    				if_block = if_blocks[current_block_type_index];

	    				if (!if_block) {
	    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	    					if_block.c();
	    				} else {
	    					if_block.p(ctx, dirty);
	    				}

	    				transition_in(if_block, 1);
	    				if_block.m(div, null);
	    			}
	    		},
	    		i: function intro(local) {
	    			if (current) return;
	    			transition_in(if_block);
	    			current = true;
	    		},
	    		o: function outro(local) {
	    			transition_out(if_block);
	    			current = false;
	    		},
	    		d: function destroy(detaching) {
	    			if (detaching) detach_dev(div);
	    			if_blocks[current_block_type_index].d();
	    			mounted = false;
	    			dispose();
	    		}
	    	};

	    	dispatch_dev(&#34;SvelteRegisterBlock&#34;, {
	    		block,
	    		id: create_fragment$1.name,
	    		type: &#34;component&#34;,
	    		source: &#34;&#34;,
	    		ctx
	    	});

	    	return block;
	    }

	    function instance$1($$self, $$props, $$invalidate) {
	    	let { $$slots: slots = {}, $$scope } = $$props;
	    	validate_slots(&#34;Main&#34;, slots, [&#39;default&#39;,&#39;OLSKResultsEmpty&#39;]);
	    	let { OLSKResultsListItems } = $$props;
	    	let { OLSKResultsListItemSelected } = $$props;
	    	let { OLSKResultsDispatchArrow } = $$props;
	    	let { OLSKResultsDispatchClick } = $$props;
	    	let { OLSKResultsEnableLooping = false } = $$props;
	    	let { OLSKResultsIgnoreKeyboard = false } = $$props;

	    	const mod = {
	    		// INTERFACE
	    		InterfaceWindowDidKeydown(event) {
	    			if (OLSKResultsIgnoreKeyboard) {
	    				return;
	    			}

	    			if (!OLSKResultsListItems.length) {
	    				return;
	    			}

	    			const handlerFunctions = {
	    				ArrowUp() {
	    					(function () {
	    						if (!OLSKResultsEnableLooping &amp;&amp; OLSKResultsListItems[0] === OLSKResultsListItemSelected) {
	    							return;
	    						}

	    						mod.ControlArrowIncrement(-1);
	    					})();

	    					return event.preventDefault();
	    				},
	    				ArrowDown() {
	    					(function () {
	    						if (!OLSKResultsEnableLooping &amp;&amp; OLSKResultsListItems.slice(-1).pop() === OLSKResultsListItemSelected) {
	    							return;
	    						}

	    						mod.ControlArrowIncrement(1);
	    					})();

	    					return event.preventDefault();
	    				}
	    			};

	    			handlerFunctions[event.code] &amp;&amp; handlerFunctions[event.code]();
	    		},
	    		// CONTROL
	    		ControlArrowIncrement(inputData) {
	    			OLSKResultsDispatchArrow(OLSKResultsListItems[uiLogic.OLSKResultsConstrainIndex(OLSKResultsListItems, OLSKResultsListItems.indexOf(OLSKResultsListItemSelected) + inputData)]);
	    		}
	    	};

	    	const writable_props = [
	    		&#34;OLSKResultsListItems&#34;,
	    		&#34;OLSKResultsListItemSelected&#34;,
	    		&#34;OLSKResultsDispatchArrow&#34;,
	    		&#34;OLSKResultsDispatchClick&#34;,
	    		&#34;OLSKResultsEnableLooping&#34;,
	    		&#34;OLSKResultsIgnoreKeyboard&#34;
	    	];

	    	Object.keys($$props).forEach(key =&gt; {
	    		if (!~writable_props.indexOf(key) &amp;&amp; key.slice(0, 2) !== &#34;$$&#34;) console.warn(`&lt;Main&gt; was created with unknown prop &#39;${key}&#39;`);
	    	});

	    	const click_handler = e =&gt; OLSKResultsDispatchClick(e);

	    	$$self.$$set = $$props =&gt; {
	    		if (&#34;OLSKResultsListItems&#34; in $$props) $$invalidate(0, OLSKResultsListItems = $$props.OLSKResultsListItems);
	    		if (&#34;OLSKResultsListItemSelected&#34; in $$props) $$invalidate(1, OLSKResultsListItemSelected = $$props.OLSKResultsListItemSelected);
	    		if (&#34;OLSKResultsDispatchArrow&#34; in $$props) $$invalidate(4, OLSKResultsDispatchArrow = $$props.OLSKResultsDispatchArrow);
	    		if (&#34;OLSKResultsDispatchClick&#34; in $$props) $$invalidate(2, OLSKResultsDispatchClick = $$props.OLSKResultsDispatchClick);
	    		if (&#34;OLSKResultsEnableLooping&#34; in $$props) $$invalidate(5, OLSKResultsEnableLooping = $$props.OLSKResultsEnableLooping);
	    		if (&#34;OLSKResultsIgnoreKeyboard&#34; in $$props) $$invalidate(6, OLSKResultsIgnoreKeyboard = $$props.OLSKResultsIgnoreKeyboard);
	    		if (&#34;$$scope&#34; in $$props) $$invalidate(7, $$scope = $$props.$$scope);
	    	};

	    	$$self.$capture_state = () =&gt; ({
	    		OLSKResultsListItems,
	    		OLSKResultsListItemSelected,
	    		OLSKResultsDispatchArrow,
	    		OLSKResultsDispatchClick,
	    		OLSKResultsEnableLooping,
	    		OLSKResultsIgnoreKeyboard,
	    		OLSKResultsLogic: uiLogic,
	    		mod
	    	});

	    	$$self.$inject_state = $$props =&gt; {
	    		if (&#34;OLSKResultsListItems&#34; in $$props) $$invalidate(0, OLSKResultsListItems = $$props.OLSKResultsListItems);
	    		if (&#34;OLSKResultsListItemSelected&#34; in $$props) $$invalidate(1, OLSKResultsListItemSelected = $$props.OLSKResultsListItemSelected);
	    		if (&#34;OLSKResultsDispatchArrow&#34; in $$props) $$invalidate(4, OLSKResultsDispatchArrow = $$props.OLSKResultsDispatchArrow);
	    		if (&#34;OLSKResultsDispatchClick&#34; in $$props) $$invalidate(2, OLSKResultsDispatchClick = $$props.OLSKResultsDispatchClick);
	    		if (&#34;OLSKResultsEnableLooping&#34; in $$props) $$invalidate(5, OLSKResultsEnableLooping = $$props.OLSKResultsEnableLooping);
	    		if (&#34;OLSKResultsIgnoreKeyboard&#34; in $$props) $$invalidate(6, OLSKResultsIgnoreKeyboard = $$props.OLSKResultsIgnoreKeyboard);
	    	};

	    	if ($$props &amp;&amp; &#34;$$inject&#34; in $$props) {
	    		$$self.$inject_state($$props.$$inject);
	    	}

	    	return [
	    		OLSKResultsListItems,
	    		OLSKResultsListItemSelected,
	    		OLSKResultsDispatchClick,
	    		mod,
	    		OLSKResultsDispatchArrow,
	    		OLSKResultsEnableLooping,
	    		OLSKResultsIgnoreKeyboard,
	    		$$scope,
	    		slots,
	    		click_handler
	    	];
	    }

	    class Main$1 extends SvelteComponentDev {
	    	constructor(options) {
	    		super(options);

	    		init(this, options, instance$1, create_fragment$1, safe_not_equal, {
	    			OLSKResultsListItems: 0,
	    			OLSKResultsListItemSelected: 1,
	    			OLSKResultsDispatchArrow: 4,
	    			OLSKResultsDispatchClick: 2,
	    			OLSKResultsEnableLooping: 5,
	    			OLSKResultsIgnoreKeyboard: 6
	    		});

	    		dispatch_dev(&#34;SvelteRegisterComponent&#34;, {
	    			component: this,
	    			tagName: &#34;Main&#34;,
	    			options,
	    			id: create_fragment$1.name
	    		});

	    		const { ctx } = this.$$;
	    		const props = options.props || {};

	    		if (/*OLSKResultsListItems*/ ctx[0] === undefined &amp;&amp; !(&#34;OLSKResultsListItems&#34; in props)) {
	    			console.warn(&#34;&lt;Main&gt; was created without expected prop &#39;OLSKResultsListItems&#39;&#34;);
	    		}

	    		if (/*OLSKResultsListItemSelected*/ ctx[1] === undefined &amp;&amp; !(&#34;OLSKResultsListItemSelected&#34; in props)) {
	    			console.warn(&#34;&lt;Main&gt; was created without expected prop &#39;OLSKResultsListItemSelected&#39;&#34;);
	    		}

	    		if (/*OLSKResultsDispatchArrow*/ ctx[4] === undefined &amp;&amp; !(&#34;OLSKResultsDispatchArrow&#34; in props)) {
	    			console.warn(&#34;&lt;Main&gt; was created without expected prop &#39;OLSKResultsDispatchArrow&#39;&#34;);
	    		}

	    		if (/*OLSKResultsDispatchClick*/ ctx[2] === undefined &amp;&amp; !(&#34;OLSKResultsDispatchClick&#34; in props)) {
	    			console.warn(&#34;&lt;Main&gt; was created without expected prop &#39;OLSKResultsDispatchClick&#39;&#34;);
	    		}
	    	}

	    	get OLSKResultsListItems() {
	    		throw new Error(&#34;&lt;Main&gt;: Props cannot be read directly from the component instance unless compiling with &#39;accessors: true&#39; or &#39;&lt;svelte:options accessors/&gt;&#39;&#34;);
	    	}

	    	set OLSKResultsListItems(value) {
	    		throw new Error(&#34;&lt;Main&gt;: Props cannot be set directly on the component instance unless compiling with &#39;accessors: true&#39; or &#39;&lt;svelte:options accessors/&gt;&#39;&#34;);
	    	}

	    	get OLSKResultsListItemSelected() {
	    		throw new Error(&#34;&lt;Main&gt;: Props cannot be read directly from the component instance unless compiling with &#39;accessors: true&#39; or &#39;&lt;svelte:options accessors/&gt;&#39;&#34;);
	    	}

	    	set OLSKResultsListItemSelected(value) {
	    		throw new Error(&#34;&lt;Main&gt;: Props cannot be set directly on the component instance unless compiling with &#39;accessors: true&#39; or &#39;&lt;svelte:options accessors/&gt;&#39;&#34;);
	    	}

	    	get OLSKResultsDispatchArrow() {
	    		throw new Error(&#34;&lt;Main&gt;: Props cannot be read directly from the component instance unless compiling with &#39;accessors: true&#39; or &#39;&lt;svelte:options accessors/&gt;&#39;&#34;);
	    	}

	    	set OLSKResultsDispatchArrow(value) {
	    		throw new Error(&#34;&lt;Main&gt;: Props cannot be set directly on the component instance unless compiling with &#39;accessors: true&#39; or &#39;&lt;svelte:options accessors/&gt;&#39;&#34;);
	    	}

	    	get OLSKResultsDispatchClick() {
	    		throw new Error(&#34;&lt;Main&gt;: Props cannot be read directly from the component instance unless compiling with &#39;accessors: true&#39; or &#39;&lt;svelte:options accessors/&gt;&#39;&#34;);
	    	}

	    	set OLSKResultsDispatchClick(value) {
	    		throw new Error(&#34;&lt;Main&gt;: Props cannot be set directly on the component instance unless compiling with &#39;accessors: true&#39; or &#39;&lt;svelte:options accessors/&gt;&#39;&#34;);
	    	}

	    	get OLSKResultsEnableLooping() {
	    		throw new Error(&#34;&lt;Main&gt;: Props cannot be read directly from the component instance unless compiling with &#39;accessors: true&#39; or &#39;&lt;svelte:options accessors/&gt;&#39;&#34;);
	    	}

	    	set OLSKResultsEnableLooping(value) {
	    		throw new Error(&#34;&lt;Main&gt;: Props cannot be set directly on the component instance unless compiling with &#39;accessors: true&#39; or &#39;&lt;svelte:options accessors/&gt;&#39;&#34;);
	    	}

	    	get OLSKResultsIgnoreKeyboard() {
	    		throw new Error(&#34;&lt;Main&gt;: Props cannot be read directly from the component instance unless compiling with &#39;accessors: true&#39; or &#39;&lt;svelte:options accessors/&gt;&#39;&#34;);
	    	}

	    	set OLSKResultsIgnoreKeyboard(value) {
	    		throw new Error(&#34;&lt;Main&gt;: Props cannot be set directly on the component instance unless compiling with &#39;accessors: true&#39; or &#39;&lt;svelte:options accessors/&gt;&#39;&#34;);
	    	}
	    }

	    /* os-app/dev-launcher/submodules/LCHLauncherPipeItem/main.svelte generated by Svelte v3.38.2 */

	    const file$2 = &#34;os-app/dev-launcher/submodules/LCHLauncherPipeItem/main.svelte&#34;;

	    // (10:1) {#if PipeItemSubtitle}
	    function create_if_block_1(ctx) {
	    	let br;
	    	let t0;
	    	let span;
	    	let t1;

	    	const block = {
	    		c: function create() {
	    			br = element(&#34;br&#34;);
	    			t0 = space();
	    			span = element(&#34;span&#34;);
	    			t1 = text(/*PipeItemSubtitle*/ ctx[1]);
	    			add_location(br, file$2, 10, 2, 244);
	    			attr_dev(span, &#34;class&#34;, &#34;LCHLauncherPipeItemSubtitle svelte-1u2sunx&#34;);
	    			add_location(span, file$2, 11, 2, 251);
	    		},
	    		m: function mount(target, anchor) {
	    			insert_dev(target, br, anchor);
	    			insert_dev(target, t0, anchor);
	    			insert_dev(target, span, anchor);
	    			append_dev(span, t1);
	    		},
	    		p: function update(ctx, dirty) {
	    			if (dirty &amp; /*PipeItemSubtitle*/ 2) set_data_dev(t1, /*PipeItemSubtitle*/ ctx[1]);
	    		},
	    		d: function destroy(detaching) {
	    			if (detaching) detach_dev(br);
	    			if (detaching) detach_dev(t0);
	    			if (detaching) detach_dev(span);
	    		}
	    	};

	    	dispatch_dev(&#34;SvelteRegisterBlock&#34;, {
	    		block,
	    		id: create_if_block_1.name,
	    		type: &#34;if&#34;,
	    		source: &#34;(10:1) {#if PipeItemSubtitle}&#34;,
	    		ctx
	    	});

	    	return block;
	    }

	    // (15:1) {#if PipeItemSource}
	    function create_if_block$1(ctx) {
	    	let br;
	    	let t0;
	    	let span;
	    	let t1;

	    	const block = {
	    		c: function create() {
	    			br = element(&#34;br&#34;);
	    			t0 = space();
	    			span = element(&#34;span&#34;);
	    			t1 = text(/*PipeItemSource*/ ctx[2]);
	    			add_location(br, file$2, 15, 2, 354);
	    			attr_dev(span, &#34;class&#34;, &#34;LCHLauncherPipeItemSource svelte-1u2sunx&#34;);
	    			add_location(span, file$2, 16, 2, 361);
	    		},
	    		m: function mount(target, anchor) {
	    			insert_dev(target, br, anchor);
	    			insert_dev(target, t0, anchor);
	    			insert_dev(target, span, anchor);
	    			append_dev(span, t1);
	    		},
	    		p: function update(ctx, dirty) {
	    			if (dirty &amp; /*PipeItemSource*/ 4) set_data_dev(t1, /*PipeItemSource*/ ctx[2]);
	    		},
	    		d: function destroy(detaching) {
	    			if (detaching) detach_dev(br);
	    			if (detaching) detach_dev(t0);
	    			if (detaching) detach_dev(span);
	    		}
	    	};

	    	dispatch_dev(&#34;SvelteRegisterBlock&#34;, {
	    		block,
	    		id: create_if_block$1.name,
	    		type: &#34;if&#34;,
	    		source: &#34;(15:1) {#if PipeItemSource}&#34;,
	    		ctx
	    	});

	    	return block;
	    }

	    function create_fragment$2(ctx) {
	    	let div;
	    	let span;
	    	let t0;
	    	let t1;
	    	let t2;
	    	let if_block0 = /*PipeItemSubtitle*/ ctx[1] &amp;&amp; create_if_block_1(ctx);
	    	let if_block1 = /*PipeItemSource*/ ctx[2] &amp;&amp; create_if_block$1(ctx);

	    	const block = {
	    		c: function create() {
	    			div = element(&#34;div&#34;);
	    			span = element(&#34;span&#34;);
	    			t0 = text(/*PipeItemTitle*/ ctx[0]);
	    			t1 = space();
	    			if (if_block0) if_block0.c();
	    			t2 = space();
	    			if (if_block1) if_block1.c();
	    			attr_dev(span, &#34;class&#34;, &#34;LCHLauncherPipeItemTitle&#34;);
	    			add_location(span, file$2, 7, 1, 152);
	    			attr_dev(div, &#34;class&#34;, &#34;LCHLauncherPipeItem svelte-1u2sunx&#34;);
	    			add_location(div, file$2, 6, 0, 117);
	    		},
	    		l: function claim(nodes) {
	    			throw new Error(&#34;options.hydrate only works if the component was compiled with the `hydratable: true` option&#34;);
	    		},
	    		m: function mount(target, anchor) {
	    			insert_dev(target, div, anchor);
	    			append_dev(div, span);
	    			append_dev(span, t0);
	    			append_dev(div, t1);
	    			if (if_block0) if_block0.m(div, null);
	    			append_dev(div, t2);
	    			if (if_block1) if_block1.m(div, null);
	    		},
	    		p: function update(ctx, [dirty]) {
	    			if (dirty &amp; /*PipeItemTitle*/ 1) set_data_dev(t0, /*PipeItemTitle*/ ctx[0]);

	    			if (/*PipeItemSubtitle*/ ctx[1]) {
	    				if (if_block0) {
	    					if_block0.p(ctx, dirty);
	    				} else {
	    					if_block0 = create_if_block_1(ctx);
	    					if_block0.c();
	    					if_block0.m(div, t2);
	    				}
	    			} else if (if_block0) {
	    				if_block0.d(1);
	    				if_block0 = null;
	    			}

	    			if (/*PipeItemSource*/ ctx[2]) {
	    				if (if_block1) {
	    					if_block1.p(ctx, dirty);
	    				} else {
	    					if_block1 = create_if_block$1(ctx);
	    					if_block1.c();
	    					if_block1.m(div, null);
	    				}
	    			} else if (if_block1) {
	    				if_block1.d(1);
	    				if_block1 = null;
	    			}
	    		},
	    		i: noop,
	    		o: noop,
	    		d: function destroy(detaching) {
	    			if (detaching) detach_dev(div);
	    			if (if_block0) if_block0.d();
	    			if (if_block1) if_block1.d();
	    		}
	    	};

	    	dispatch_dev(&#34;SvelteRegisterBlock&#34;, {
	    		block,
	    		id: create_fragment$2.name,
	    		type: &#34;component&#34;,
	    		source: &#34;&#34;,
	    		ctx
	    	});

	    	return block;
	    }

	    function instance$2($$self, $$props, $$invalidate) {
	    	let { $$slots: slots = {}, $$scope } = $$props;
	    	validate_slots(&#34;Main&#34;, slots, []);
	    	let { PipeItemTitle = &#34;&#34; } = $$props;
	    	let { PipeItemSubtitle = &#34;&#34; } = $$props;
	    	let { PipeItemSource = &#34;&#34; } = $$props;
	    	const writable_props = [&#34;PipeItemTitle&#34;, &#34;PipeItemSubtitle&#34;, &#34;PipeItemSource&#34;];

	    	Object.keys($$props).forEach(key =&gt; {
	    		if (!~writable_props.indexOf(key) &amp;&amp; key.slice(0, 2) !== &#34;$$&#34;) console.warn(`&lt;Main&gt; was created with unknown prop &#39;${key}&#39;`);
	    	});

	    	$$self.$$set = $$props =&gt; {
	    		if (&#34;PipeItemTitle&#34; in $$props) $$invalidate(0, PipeItemTitle = $$props.PipeItemTitle);
	    		if (&#34;PipeItemSubtitle&#34; in $$props) $$invalidate(1, PipeItemSubtitle = $$props.PipeItemSubtitle);
	    		if (&#34;PipeItemSource&#34; in $$props) $$invalidate(2, PipeItemSource = $$props.PipeItemSource);
	    	};

	    	$$self.$capture_state = () =&gt; ({
	    		PipeItemTitle,
	    		PipeItemSubtitle,
	    		PipeItemSource
	    	});

	    	$$self.$inject_state = $$props =&gt; {
	    		if (&#34;PipeItemTitle&#34; in $$props) $$invalidate(0, PipeItemTitle = $$props.PipeItemTitle);
	    		if (&#34;PipeItemSubtitle&#34; in $$props) $$invalidate(1, PipeItemSubtitle = $$props.PipeItemSubtitle);
	    		if (&#34;PipeItemSource&#34; in $$props) $$invalidate(2, PipeItemSource = $$props.PipeItemSource);
	    	};

	    	if ($$props &amp;&amp; &#34;$$inject&#34; in $$props) {
	    		$$self.$inject_state($$props.$$inject);
	    	}

	    	return [PipeItemTitle, PipeItemSubtitle, PipeItemSource];
	    }

	    class Main$2 extends SvelteComponentDev {
	    	constructor(options) {
	    		super(options);

	    		init(this, options, instance$2, create_fragment$2, safe_not_equal, {
	    			PipeItemTitle: 0,
	    			PipeItemSubtitle: 1,
	    			PipeItemSource: 2
	    		});

	    		dispatch_dev(&#34;SvelteRegisterComponent&#34;, {
	    			component: this,
	    			tagName: &#34;Main&#34;,
	    			options,
	    			id: create_fragment$2.name
	    		});
	    	}

	    	get PipeItemTitle() {
	    		throw new Error(&#34;&lt;Main&gt;: Props cannot be read directly from the component instance unless compiling with &#39;accessors: true&#39; or &#39;&lt;svelte:options accessors/&gt;&#39;&#34;);
	    	}

	    	set PipeItemTitle(value) {
	    		throw new Error(&#34;&lt;Main&gt;: Props cannot be set directly on the component instance unless compiling with &#39;accessors: true&#39; or &#39;&lt;svelte:options accessors/&gt;&#39;&#34;);
	    	}

	    	get PipeItemSubtitle() {
	    		throw new Error(&#34;&lt;Main&gt;: Props cannot be read directly from the component instance unless compiling with &#39;accessors: true&#39; or &#39;&lt;svelte:options accessors/&gt;&#39;&#34;);
	    	}

	    	set PipeItemSubtitle(value) {
	    		throw new Error(&#34;&lt;Main&gt;: Props cannot be set directly on the component instance unless compiling with &#39;accessors: true&#39; or &#39;&lt;svelte:options accessors/&gt;&#39;&#34;);
	    	}

	    	get PipeItemSource() {
	    		throw new Error(&#34;&lt;Main&gt;: Props cannot be read directly from the component instance unless compiling with &#39;accessors: true&#39; or &#39;&lt;svelte:options accessors/&gt;&#39;&#34;);
	    	}

	    	set PipeItemSource(value) {
	    		throw new Error(&#34;&lt;Main&gt;: Props cannot be set directly on the component instance unless compiling with &#39;accessors: true&#39; or &#39;&lt;svelte:options accessors/&gt;&#39;&#34;);
	    	}
	    }

	    /* os-app/dev-launcher/submodules/LCHLauncherPrompt/main.svelte generated by Svelte v3.38.2 */
	    const file$3 = &#34;os-app/dev-launcher/submodules/LCHLauncherPrompt/main.svelte&#34;;

	    // (28:2) {:else}
	    function create_else_block$1(ctx) {
	    	let lchlauncherpipeitem;
	    	let current;

	    	lchlauncherpipeitem = new Main$2({
	    			props: {
	    				PipeItemTitle: /*ItemSelected*/ ctx[0].LCHRecipeName,
	    				PipeItemSubtitle: /*ItemSelected*/ ctx[0]._LCHRecipeOutputTypeName,
	    				PipeItemSource: /*ItemSelected*/ ctx[0]._LCHRecipeSource
	    			},
	    			$$inline: true
	    		});

	    	const block = {
	    		c: function create() {
	    			create_component(lchlauncherpipeitem.$$.fragment);
	    		},
	    		m: function mount(target, anchor) {
	    			mount_component(lchlauncherpipeitem, target, anchor);
	    			current = true;
	    		},
	    		p: function update(ctx, dirty) {
	    			const lchlauncherpipeitem_changes = {};
	    			if (dirty &amp; /*ItemSelected*/ 1) lchlauncherpipeitem_changes.PipeItemTitle = /*ItemSelected*/ ctx[0].LCHRecipeName;
	    			if (dirty &amp; /*ItemSelected*/ 1) lchlauncherpipeitem_changes.PipeItemSubtitle = /*ItemSelected*/ ctx[0]._LCHRecipeOutputTypeName;
	    			if (dirty &amp; /*ItemSelected*/ 1) lchlauncherpipeitem_changes.PipeItemSource = /*ItemSelected*/ ctx[0]._LCHRecipeSource;
	    			lchlauncherpipeitem.$set(lchlauncherpipeitem_changes);
	    		},
	    		i: function intro(local) {
	    			if (current) return;
	    			transition_in(lchlauncherpipeitem.$$.fragment, local);
	    			current = true;
	    		},
	    		o: function outro(local) {
	    			transition_out(lchlauncherpipeitem.$$.fragment, local);
	    			current = false;
	    		},
	    		d: function destroy(detaching) {
	    			destroy_component(lchlauncherpipeitem, detaching);
	    		}
	    	};

	    	dispatch_dev(&#34;SvelteRegisterBlock&#34;, {
	    		block,
	    		id: create_else_block$1.name,
	    		type: &#34;else&#34;,
	    		source: &#34;(28:2) {:else}&#34;,
	    		ctx
	    	});

	    	return block;
	    }

	    // (26:2) {#if !ItemSelected || ItemSelectedHidden}
	    function create_if_block_1$1(ctx) {
	    	let current;
	    	const default_slot_template = /*#slots*/ ctx[6].default;
	    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[7], null);

	    	const block = {
	    		c: function create() {
	    			if (default_slot) default_slot.c();
	    		},
	    		m: function mount(target, anchor) {
	    			if (default_slot) {
	    				default_slot.m(target, anchor);
	    			}

	    			current = true;
	    		},
	    		p: function update(ctx, dirty) {
	    			if (default_slot) {
	    				if (default_slot.p &amp;&amp; (!current || dirty &amp; /*$$scope*/ 128)) {
	    					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[7], dirty, null, null);
	    				}
	    			}
	    		},
	    		i: function intro(local) {
	    			if (current) return;
	    			transition_in(default_slot, local);
	    			current = true;
	    		},
	    		o: function outro(local) {
	    			transition_out(default_slot, local);
	    			current = false;
	    		},
	    		d: function destroy(detaching) {
	    			if (default_slot) default_slot.d(detaching);
	    		}
	    	};

	    	dispatch_dev(&#34;SvelteRegisterBlock&#34;, {
	    		block,
	    		id: create_if_block_1$1.name,
	    		type: &#34;if&#34;,
	    		source: &#34;(26:2) {#if !ItemSelected || ItemSelectedHidden}&#34;,
	    		ctx
	    	});

	    	return block;
	    }

	    // (34:0) {#if !ResultsHidden}
	    function create_if_block$2(ctx) {
	    	let olskresults;
	    	let current;

	    	olskresults = new Main$1({
	    			props: {
	    				OLSKResultsListItems: /*PromptItems*/ ctx[1],
	    				OLSKResultsListItemSelected: /*ItemSelected*/ ctx[0],
	    				OLSKResultsDispatchClick: /*ResultListDispatchClick*/ ctx[5],
	    				OLSKResultsDispatchArrow: /*ResultListDispatchArrow*/ ctx[4],
	    				OLSKResultsEnableLooping: true,
	    				$$slots: {
	    					default: [
	    						create_default_slot,
	    						({ OLSKResultsListItem: item }) =&gt; ({ 9: item }),
	    						({ OLSKResultsListItem: item }) =&gt; item ? 512 : 0
	    					]
	    				},
	    				$$scope: { ctx }
	    			},
	    			$$inline: true
	    		});

	    	const block = {
	    		c: function create() {
	    			create_component(olskresults.$$.fragment);
	    		},
	    		m: function mount(target, anchor) {
	    			mount_component(olskresults, target, anchor);
	    			current = true;
	    		},
	    		p: function update(ctx, dirty) {
	    			const olskresults_changes = {};
	    			if (dirty &amp; /*PromptItems*/ 2) olskresults_changes.OLSKResultsListItems = /*PromptItems*/ ctx[1];
	    			if (dirty &amp; /*ItemSelected*/ 1) olskresults_changes.OLSKResultsListItemSelected = /*ItemSelected*/ ctx[0];

	    			if (dirty &amp; /*$$scope, item*/ 640) {
	    				olskresults_changes.$$scope = { dirty, ctx };
	    			}

	    			olskresults.$set(olskresults_changes);
	    		},
	    		i: function intro(local) {
	    			if (current) return;
	    			transition_in(olskresults.$$.fragment, local);
	    			current = true;
	    		},
	    		o: function outro(local) {
	    			transition_out(olskresults.$$.fragment, local);
	    			current = false;
	    		},
	    		d: function destroy(detaching) {
	    			destroy_component(olskresults, detaching);
	    		}
	    	};

	    	dispatch_dev(&#34;SvelteRegisterBlock&#34;, {
	    		block,
	    		id: create_if_block$2.name,
	    		type: &#34;if&#34;,
	    		source: &#34;(34:0) {#if !ResultsHidden}&#34;,
	    		ctx
	    	});

	    	return block;
	    }

	    // (35:1) &lt;OLSKResults   OLSKResultsListItems={ PromptItems }   OLSKResultsListItemSelected={ ItemSelected }   OLSKResultsDispatchClick={ ResultListDispatchClick }   OLSKResultsDispatchArrow={ ResultListDispatchArrow }   let:OLSKResultsListItem={ item }   OLSKResultsEnableLooping={ true }   &gt;
	    function create_default_slot(ctx) {
	    	let lchlauncherpipeitem;
	    	let current;

	    	lchlauncherpipeitem = new Main$2({
	    			props: {
	    				PipeItemTitle: /*item*/ ctx[9].LCHRecipeName,
	    				PipeItemSubtitle: /*item*/ ctx[9]._LCHRecipeOutputTypeName,
	    				PipeItemSource: /*item*/ ctx[9]._LCHRecipeSource
	    			},
	    			$$inline: true
	    		});

	    	const block = {
	    		c: function create() {
	    			create_component(lchlauncherpipeitem.$$.fragment);
	    		},
	    		m: function mount(target, anchor) {
	    			mount_component(lchlauncherpipeitem, target, anchor);
	    			current = true;
	    		},
	    		p: function update(ctx, dirty) {
	    			const lchlauncherpipeitem_changes = {};
	    			if (dirty &amp; /*item*/ 512) lchlauncherpipeitem_changes.PipeItemTitle = /*item*/ ctx[9].LCHRecipeName;
	    			if (dirty &amp; /*item*/ 512) lchlauncherpipeitem_changes.PipeItemSubtitle = /*item*/ ctx[9]._LCHRecipeOutputTypeName;
	    			if (dirty &amp; /*item*/ 512) lchlauncherpipeitem_changes.PipeItemSource = /*item*/ ctx[9]._LCHRecipeSource;
	    			lchlauncherpipeitem.$set(lchlauncherpipeitem_changes);
	    		},
	    		i: function intro(local) {
	    			if (current) return;
	    			transition_in(lchlauncherpipeitem.$$.fragment, local);
	    			current = true;
	    		},
	    		o: function outro(local) {
	    			transition_out(lchlauncherpipeitem.$$.fragment, local);
	    			current = false;
	    		},
	    		d: function destroy(detaching) {
	    			destroy_component(lchlauncherpipeitem, detaching);
	    		}
	    	};

	    	dispatch_dev(&#34;SvelteRegisterBlock&#34;, {
	    		block,
	    		id: create_default_slot.name,
	    		type: &#34;slot&#34;,
	    		source: &#34;(35:1) &lt;OLSKResults   OLSKResultsListItems={ PromptItems }   OLSKResultsListItemSelected={ ItemSelected }   OLSKResultsDispatchClick={ ResultListDispatchClick }   OLSKResultsDispatchArrow={ ResultListDispatchArrow }   let:OLSKResultsListItem={ item }   OLSKResultsEnableLooping={ true }   &gt;&#34;,
	    		ctx
	    	});

	    	return block;
	    }

	    function create_fragment$3(ctx) {
	    	let div2;
	    	let div1;
	    	let div0;
	    	let current_block_type_index;
	    	let if_block0;
	    	let t;
	    	let current;
	    	const if_block_creators = [create_if_block_1$1, create_else_block$1];
	    	const if_blocks = [];

	    	function select_block_type(ctx, dirty) {
	    		if (!/*ItemSelected*/ ctx[0] || /*ItemSelectedHidden*/ ctx[3]) return 0;
	    		return 1;
	    	}

	    	current_block_type_index = select_block_type(ctx);
	    	if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	    	let if_block1 = !/*ResultsHidden*/ ctx[2] &amp;&amp; create_if_block$2(ctx);

	    	const block = {
	    		c: function create() {
	    			div2 = element(&#34;div&#34;);
	    			div1 = element(&#34;div&#34;);
	    			div0 = element(&#34;div&#34;);
	    			if_block0.c();
	    			t = space();
	    			if (if_block1) if_block1.c();
	    			attr_dev(div0, &#34;class&#34;, &#34;LCHLauncherZoneInputBezel svelte-m73tr1&#34;);
	    			add_location(div0, file$3, 24, 1, 650);
	    			attr_dev(div1, &#34;class&#34;, &#34;LCHLauncherZoneInput svelte-m73tr1&#34;);
	    			add_location(div1, file$3, 23, 0, 614);
	    			attr_dev(div2, &#34;class&#34;, &#34;LCHLauncherPrompt&#34;);
	    			add_location(div2, file$3, 21, 0, 581);
	    		},
	    		l: function claim(nodes) {
	    			throw new Error(&#34;options.hydrate only works if the component was compiled with the `hydratable: true` option&#34;);
	    		},
	    		m: function mount(target, anchor) {
	    			insert_dev(target, div2, anchor);
	    			append_dev(div2, div1);
	    			append_dev(div1, div0);
	    			if_blocks[current_block_type_index].m(div0, null);
	    			append_dev(div2, t);
	    			if (if_block1) if_block1.m(div2, null);
	    			current = true;
	    		},
	    		p: function update(ctx, [dirty]) {
	    			let previous_block_index = current_block_type_index;
	    			current_block_type_index = select_block_type(ctx);

	    			if (current_block_type_index === previous_block_index) {
	    				if_blocks[current_block_type_index].p(ctx, dirty);
	    			} else {
	    				group_outros();

	    				transition_out(if_blocks[previous_block_index], 1, 1, () =&gt; {
	    					if_blocks[previous_block_index] = null;
	    				});

	    				check_outros();
	    				if_block0 = if_blocks[current_block_type_index];

	    				if (!if_block0) {
	    					if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	    					if_block0.c();
	    				} else {
	    					if_block0.p(ctx, dirty);
	    				}

	    				transition_in(if_block0, 1);
	    				if_block0.m(div0, null);
	    			}

	    			if (!/*ResultsHidden*/ ctx[2]) {
	    				if (if_block1) {
	    					if_block1.p(ctx, dirty);

	    					if (dirty &amp; /*ResultsHidden*/ 4) {
	    						transition_in(if_block1, 1);
	    					}
	    				} else {
	    					if_block1 = create_if_block$2(ctx);
	    					if_block1.c();
	    					transition_in(if_block1, 1);
	    					if_block1.m(div2, null);
	    				}
	    			} else if (if_block1) {
	    				group_outros();

	    				transition_out(if_block1, 1, 1, () =&gt; {
	    					if_block1 = null;
	    				});

	    				check_outros();
	    			}
	    		},
	    		i: function intro(local) {
	    			if (current) return;
	    			transition_in(if_block0);
	    			transition_in(if_block1);
	    			current = true;
	    		},
	    		o: function outro(local) {
	    			transition_out(if_block0);
	    			transition_out(if_block1);
	    			current = false;
	    		},
	    		d: function destroy(detaching) {
	    			if (detaching) detach_dev(div2);
	    			if_blocks[current_block_type_index].d();
	    			if (if_block1) if_block1.d();
	    		}
	    	};

	    	dispatch_dev(&#34;SvelteRegisterBlock&#34;, {
	    		block,
	    		id: create_fragment$3.name,
	    		type: &#34;component&#34;,
	    		source: &#34;&#34;,
	    		ctx
	    	});

	    	return block;
	    }

	    function instance$3($$self, $$props, $$invalidate) {
	    	let { $$slots: slots = {}, $$scope } = $$props;
	    	validate_slots(&#34;Main&#34;, slots, [&#39;default&#39;]);
	    	let { PromptItems = [] } = $$props;
	    	let { ResultsHidden = false } = $$props;
	    	let { ItemSelected = null } = $$props;
	    	let { ItemSelectedHidden = false } = $$props;
	    	const dispatch = createEventDispatcher();

	    	function ResultListDispatchArrow(inputData) {
	    		dispatch(&#34;ResultListDispatchArrow&#34;, $$invalidate(0, ItemSelected = inputData));
	    	}

	    	function ResultListDispatchClick(inputData) {
	    		dispatch(&#34;ResultListDispatchClick&#34;, $$invalidate(0, ItemSelected = inputData));
	    	}

	    	const writable_props = [&#34;PromptItems&#34;, &#34;ResultsHidden&#34;, &#34;ItemSelected&#34;, &#34;ItemSelectedHidden&#34;];

	    	Object.keys($$props).forEach(key =&gt; {
	    		if (!~writable_props.indexOf(key) &amp;&amp; key.slice(0, 2) !== &#34;$$&#34;) console.warn(`&lt;Main&gt; was created with unknown prop &#39;${key}&#39;`);
	    	});

	    	$$self.$$set = $$props =&gt; {
	    		if (&#34;PromptItems&#34; in $$props) $$invalidate(1, PromptItems = $$props.PromptItems);
	    		if (&#34;ResultsHidden&#34; in $$props) $$invalidate(2, ResultsHidden = $$props.ResultsHidden);
	    		if (&#34;ItemSelected&#34; in $$props) $$invalidate(0, ItemSelected = $$props.ItemSelected);
	    		if (&#34;ItemSelectedHidden&#34; in $$props) $$invalidate(3, ItemSelectedHidden = $$props.ItemSelectedHidden);
	    		if (&#34;$$scope&#34; in $$props) $$invalidate(7, $$scope = $$props.$$scope);
	    	};

	    	$$self.$capture_state = () =&gt; ({
	    		PromptItems,
	    		ResultsHidden,
	    		ItemSelected,
	    		ItemSelectedHidden,
	    		OLSKResults: Main$1,
	    		LCHLauncherPipeItem: Main$2,
	    		createEventDispatcher,
	    		dispatch,
	    		ResultListDispatchArrow,
	    		ResultListDispatchClick
	    	});

	    	$$self.$inject_state = $$props =&gt; {
	    		if (&#34;PromptItems&#34; in $$props) $$invalidate(1, PromptItems = $$props.PromptItems);
	    		if (&#34;ResultsHidden&#34; in $$props) $$invalidate(2, ResultsHidden = $$props.ResultsHidden);
	    		if (&#34;ItemSelected&#34; in $$props) $$invalidate(0, ItemSelected = $$props.ItemSelected);
	    		if (&#34;ItemSelectedHidden&#34; in $$props) $$invalidate(3, ItemSelectedHidden = $$props.ItemSelectedHidden);
	    	};

	    	if ($$props &amp;&amp; &#34;$$inject&#34; in $$props) {
	    		$$self.$inject_state($$props.$$inject);
	    	}

	    	return [
	    		ItemSelected,
	    		PromptItems,
	    		ResultsHidden,
	    		ItemSelectedHidden,
	    		ResultListDispatchArrow,
	    		ResultListDispatchClick,
	    		slots,
	    		$$scope
	    	];
	    }

	    class Main$3 extends SvelteComponentDev {
	    	constructor(options) {
	    		super(options);

	    		init(this, options, instance$3, create_fragment$3, safe_not_equal, {
	    			PromptItems: 1,
	    			ResultsHidden: 2,
	    			ItemSelected: 0,
	    			ItemSelectedHidden: 3
	    		});

	    		dispatch_dev(&#34;SvelteRegisterComponent&#34;, {
	    			component: this,
	    			tagName: &#34;Main&#34;,
	    			options,
	    			id: create_fragment$3.name
	    		});
	    	}

	    	get PromptItems() {
	    		throw new Error(&#34;&lt;Main&gt;: Props cannot be read directly from the component instance unless compiling with &#39;accessors: true&#39; or &#39;&lt;svelte:options accessors/&gt;&#39;&#34;);
	    	}

	    	set PromptItems(value) {
	    		throw new Error(&#34;&lt;Main&gt;: Props cannot be set directly on the component instance unless compiling with &#39;accessors: true&#39; or &#39;&lt;svelte:options accessors/&gt;&#39;&#34;);
	    	}

	    	get ResultsHidden() {
	    		throw new Error(&#34;&lt;Main&gt;: Props cannot be read directly from the component instance unless compiling with &#39;accessors: true&#39; or &#39;&lt;svelte:options accessors/&gt;&#39;&#34;);
	    	}

	    	set ResultsHidden(value) {
	    		throw new Error(&#34;&lt;Main&gt;: Props cannot be set directly on the component instance unless compiling with &#39;accessors: true&#39; or &#39;&lt;svelte:options accessors/&gt;&#39;&#34;);
	    	}

	    	get ItemSelected() {
	    		throw new Error(&#34;&lt;Main&gt;: Props cannot be read directly from the component instance unless compiling with &#39;accessors: true&#39; or &#39;&lt;svelte:options accessors/&gt;&#39;&#34;);
	    	}

	    	set ItemSelected(value) {
	    		throw new Error(&#34;&lt;Main&gt;: Props cannot be set directly on the component instance unless compiling with &#39;accessors: true&#39; or &#39;&lt;svelte:options accessors/&gt;&#39;&#34;);
	    	}

	    	get ItemSelectedHidden() {
	    		throw new Error(&#34;&lt;Main&gt;: Props cannot be read directly from the component instance unless compiling with &#39;accessors: true&#39; or &#39;&lt;svelte:options accessors/&gt;&#39;&#34;);
	    	}

	    	set ItemSelectedHidden(value) {
	    		throw new Error(&#34;&lt;Main&gt;: Props cannot be set directly on the component instance unless compiling with &#39;accessors: true&#39; or &#39;&lt;svelte:options accessors/&gt;&#39;&#34;);
	    	}
	    }

	    /* os-app/dev-launcher/main.svelte generated by Svelte v3.38.2 */

	    const { Object: Object_1, console: console_1, window: window_1 } = globals;
	    const file$4 = &#34;os-app/dev-launcher/main.svelte&#34;;

	    function get_each_context$1(ctx, list, i) {
	    	const child_ctx = ctx.slice();
	    	child_ctx[16] = list[i];
	    	child_ctx[17] = list;
	    	child_ctx[18] = i;
	    	return child_ctx;
	    }

	    // (887:0) {#if e.LCHPromptIsVisible}
	    function create_if_block_2(ctx) {
	    	let div;
	    	let show_if = /*LRTOptions*/ ctx[0].LCHOptionMode === mod$3.LCHLauncherModePipe();
	    	let t;
	    	let lchlauncherprompt;
	    	let div_class_value;
	    	let current;
	    	let mounted;
	    	let dispose;
	    	let if_block = show_if &amp;&amp; create_if_block_6(ctx);

	    	lchlauncherprompt = new Main$3({
	    			props: {
	    				PromptItems: /*e*/ ctx[16].LCHPromptItemsVisible,
	    				ItemSelected: /*e*/ ctx[16].LCHPromptItemSelected,
	    				ItemSelectedHidden: /*LRTOptions*/ ctx[0].LCHOptionMode !== mod$3.LCHLauncherModePipe() || /*e*/ ctx[16].LCHPromptDotModeEnabled,
	    				ResultsHidden: /*e*/ ctx[16].LCHPromptResultsThrottle !== false,
	    				$$slots: { default: [create_default_slot$1] },
	    				$$scope: { ctx }
	    			},
	    			$$inline: true
	    		});

	    	lchlauncherprompt.$on(&#34;ResultListDispatchArrow&#34;, /*ResultListDispatchArrow_handler*/ ctx[10]);
	    	lchlauncherprompt.$on(&#34;ResultListDispatchClick&#34;, /*ResultListDispatchClick_handler*/ ctx[11]);

	    	function click_handler() {
	    		return /*click_handler*/ ctx[12](/*e*/ ctx[16]);
	    	}

	    	const block = {
	    		c: function create() {
	    			div = element(&#34;div&#34;);
	    			if (if_block) if_block.c();
	    			t = space();
	    			create_component(lchlauncherprompt.$$.fragment);
	    			attr_dev(div, &#34;class&#34;, div_class_value = &#34;&#34; + (null_to_empty(/*e*/ ctx[16].LCHPromptClass) + &#34; svelte-1rxh210&#34;));
	    			toggle_class(div, &#34;LCHLauncherPromptSelected&#34;, /*mod*/ ctx[1]._ValuePromptObjects[/*mod*/ ctx[1]._ValuePromptActiveIndex] === /*e*/ ctx[16]);
	    			add_location(div, file$4, 888, 0, 27546);
	    		},
	    		m: function mount(target, anchor) {
	    			insert_dev(target, div, anchor);
	    			if (if_block) if_block.m(div, null);
	    			append_dev(div, t);
	    			mount_component(lchlauncherprompt, div, null);
	    			current = true;

	    			if (!mounted) {
	    				dispose = listen_dev(div, &#34;click&#34;, click_handler, false, false, false);
	    				mounted = true;
	    			}
	    		},
	    		p: function update(new_ctx, dirty) {
	    			ctx = new_ctx;
	    			if (dirty &amp; /*LRTOptions*/ 1) show_if = /*LRTOptions*/ ctx[0].LCHOptionMode === mod$3.LCHLauncherModePipe();

	    			if (show_if) {
	    				if (if_block) {
	    					if_block.p(ctx, dirty);
	    				} else {
	    					if_block = create_if_block_6(ctx);
	    					if_block.c();
	    					if_block.m(div, t);
	    				}
	    			} else if (if_block) {
	    				if_block.d(1);
	    				if_block = null;
	    			}

	    			const lchlauncherprompt_changes = {};
	    			if (dirty &amp; /*mod*/ 2) lchlauncherprompt_changes.PromptItems = /*e*/ ctx[16].LCHPromptItemsVisible;
	    			if (dirty &amp; /*mod*/ 2) lchlauncherprompt_changes.ItemSelected = /*e*/ ctx[16].LCHPromptItemSelected;
	    			if (dirty &amp; /*LRTOptions, mod*/ 3) lchlauncherprompt_changes.ItemSelectedHidden = /*LRTOptions*/ ctx[0].LCHOptionMode !== mod$3.LCHLauncherModePipe() || /*e*/ ctx[16].LCHPromptDotModeEnabled;
	    			if (dirty &amp; /*mod*/ 2) lchlauncherprompt_changes.ResultsHidden = /*e*/ ctx[16].LCHPromptResultsThrottle !== false;

	    			if (dirty &amp; /*$$scope, mod, LRTOptions*/ 524291) {
	    				lchlauncherprompt_changes.$$scope = { dirty, ctx };
	    			}

	    			lchlauncherprompt.$set(lchlauncherprompt_changes);

	    			if (!current || dirty &amp; /*mod*/ 2 &amp;&amp; div_class_value !== (div_class_value = &#34;&#34; + (null_to_empty(/*e*/ ctx[16].LCHPromptClass) + &#34; svelte-1rxh210&#34;))) {
	    				attr_dev(div, &#34;class&#34;, div_class_value);
	    			}

	    			if (dirty &amp; /*mod, mod*/ 2) {
	    				toggle_class(div, &#34;LCHLauncherPromptSelected&#34;, /*mod*/ ctx[1]._ValuePromptObjects[/*mod*/ ctx[1]._ValuePromptActiveIndex] === /*e*/ ctx[16]);
	    			}
	    		},
	    		i: function intro(local) {
	    			if (current) return;
	    			transition_in(lchlauncherprompt.$$.fragment, local);
	    			current = true;
	    		},
	    		o: function outro(local) {
	    			transition_out(lchlauncherprompt.$$.fragment, local);
	    			current = false;
	    		},
	    		d: function destroy(detaching) {
	    			if (detaching) detach_dev(div);
	    			if (if_block) if_block.d();
	    			destroy_component(lchlauncherprompt);
	    			mounted = false;
	    			dispose();
	    		}
	    	};

	    	dispatch_dev(&#34;SvelteRegisterBlock&#34;, {
	    		block,
	    		id: create_if_block_2.name,
	    		type: &#34;if&#34;,
	    		source: &#34;(887:0) {#if e.LCHPromptIsVisible}&#34;,
	    		ctx
	    	});

	    	return block;
	    }

	    // (890:1) {#if LRTOptions.LCHOptionMode === LCHLauncherLogic.LCHLauncherModePipe()}
	    function create_if_block_6(ctx) {
	    	let strong;
	    	let t_value = (/*e*/ ctx[16].LCHPromptFilterText &amp;&amp; /*e*/ ctx[16].LCHPromptFilterText.toUpperCase() || /*e*/ ctx[16].LCHPromptHeading) + &#34;&#34;;
	    	let t;

	    	const block = {
	    		c: function create() {
	    			strong = element(&#34;strong&#34;);
	    			t = text(t_value);
	    			attr_dev(strong, &#34;class&#34;, &#34;LCHLauncherPromptHeading svelte-1rxh210&#34;);
	    			toggle_class(strong, &#34;LCHLauncherPromptHeadingMatchStop&#34;, /*e*/ ctx[16].LCHPromptMatchStop);
	    			add_location(strong, file$4, 890, 2, 27801);
	    		},
	    		m: function mount(target, anchor) {
	    			insert_dev(target, strong, anchor);
	    			append_dev(strong, t);
	    		},
	    		p: function update(ctx, dirty) {
	    			if (dirty &amp; /*mod*/ 2 &amp;&amp; t_value !== (t_value = (/*e*/ ctx[16].LCHPromptFilterText &amp;&amp; /*e*/ ctx[16].LCHPromptFilterText.toUpperCase() || /*e*/ ctx[16].LCHPromptHeading) + &#34;&#34;)) set_data_dev(t, t_value);

	    			if (dirty &amp; /*mod*/ 2) {
	    				toggle_class(strong, &#34;LCHLauncherPromptHeadingMatchStop&#34;, /*e*/ ctx[16].LCHPromptMatchStop);
	    			}
	    		},
	    		d: function destroy(detaching) {
	    			if (detaching) detach_dev(strong);
	    		}
	    	};

	    	dispatch_dev(&#34;SvelteRegisterBlock&#34;, {
	    		block,
	    		id: create_if_block_6.name,
	    		type: &#34;if&#34;,
	    		source: &#34;(890:1) {#if LRTOptions.LCHOptionMode === LCHLauncherLogic.LCHLauncherModePipe()}&#34;,
	    		ctx
	    	});

	    	return block;
	    }

	    // (902:2) {#if e.LCHPromptClass === &#39;LCHLauncherSubjectPrompt&#39; &amp;&amp; !e.LCHPromptDotModeEnabled }
	    function create_if_block_5(ctx) {
	    	let span;

	    	const block = {
	    		c: function create() {
	    			span = element(&#34;span&#34;);
	    			span.textContent = `${/*OLSKLocalized*/ ctx[2](&#34;LCHLauncherSubjectPromptPlaceholderText&#34;)}`;
	    			attr_dev(span, &#34;class&#34;, &#34;LCHLauncherSubjectPromptPlaceholder svelte-1rxh210&#34;);
	    			add_location(span, file$4, 902, 3, 28605);
	    		},
	    		m: function mount(target, anchor) {
	    			insert_dev(target, span, anchor);
	    		},
	    		p: noop,
	    		d: function destroy(detaching) {
	    			if (detaching) detach_dev(span);
	    		}
	    	};

	    	dispatch_dev(&#34;SvelteRegisterBlock&#34;, {
	    		block,
	    		id: create_if_block_5.name,
	    		type: &#34;if&#34;,
	    		source: &#34;(902:2) {#if e.LCHPromptClass === &#39;LCHLauncherSubjectPrompt&#39; &amp;&amp; !e.LCHPromptDotModeEnabled }&#34;,
	    		ctx
	    	});

	    	return block;
	    }

	    // (906:2) {#if e.LCHPromptClass === &#39;LCHLauncherFilterPrompt&#39; }
	    function create_if_block_4(ctx) {
	    	let input;
	    	let input_placeholder_value;
	    	let mounted;
	    	let dispose;

	    	const block = {
	    		c: function create() {
	    			input = element(&#34;input&#34;);
	    			attr_dev(input, &#34;class&#34;, &#34;LCHLauncherFilterInput svelte-1rxh210&#34;);

	    			attr_dev(input, &#34;placeholder&#34;, input_placeholder_value = /*LRTOptions*/ ctx[0].LCHOptionMode === mod$3.LCHLauncherModePreview()
	    			? /*OLSKLocalized*/ ctx[2](&#34;LCHLauncherInputPlaceholderPreview&#34;)
	    			: /*OLSKLocalized*/ ctx[2](&#34;LCHLauncherInputPlaceholderDefault&#34;));

	    			input.autofocus = true;
	    			add_location(input, file$4, 906, 3, 28791);
	    		},
	    		m: function mount(target, anchor) {
	    			insert_dev(target, input, anchor);
	    			set_input_value(input, /*mod*/ ctx[1]._ValuePromptObjects[0].LCHPromptFilterText);
	    			/*input_binding*/ ctx[7](input);
	    			input.focus();

	    			if (!mounted) {
	    				dispose = [
	    					listen_dev(input, &#34;input&#34;, /*input_input_handler*/ ctx[6]),
	    					listen_dev(input, &#34;input&#34;, /*input_handler*/ ctx[8], false, false, false)
	    				];

	    				mounted = true;
	    			}
	    		},
	    		p: function update(ctx, dirty) {
	    			if (dirty &amp; /*LRTOptions*/ 1 &amp;&amp; input_placeholder_value !== (input_placeholder_value = /*LRTOptions*/ ctx[0].LCHOptionMode === mod$3.LCHLauncherModePreview()
	    			? /*OLSKLocalized*/ ctx[2](&#34;LCHLauncherInputPlaceholderPreview&#34;)
	    			: /*OLSKLocalized*/ ctx[2](&#34;LCHLauncherInputPlaceholderDefault&#34;))) {
	    				attr_dev(input, &#34;placeholder&#34;, input_placeholder_value);
	    			}

	    			if (dirty &amp; /*mod*/ 2 &amp;&amp; input.value !== /*mod*/ ctx[1]._ValuePromptObjects[0].LCHPromptFilterText) {
	    				set_input_value(input, /*mod*/ ctx[1]._ValuePromptObjects[0].LCHPromptFilterText);
	    			}
	    		},
	    		d: function destroy(detaching) {
	    			if (detaching) detach_dev(input);
	    			/*input_binding*/ ctx[7](null);
	    			mounted = false;
	    			run_all(dispose);
	    		}
	    	};

	    	dispatch_dev(&#34;SvelteRegisterBlock&#34;, {
	    		block,
	    		id: create_if_block_4.name,
	    		type: &#34;if&#34;,
	    		source: &#34;(906:2) {#if e.LCHPromptClass === &#39;LCHLauncherFilterPrompt&#39; }&#34;,
	    		ctx
	    	});

	    	return block;
	    }

	    // (910:2) {#if ![&#39;LCHLauncherFilterPrompt&#39;, &#39;LCHLauncherActionPrompt&#39;].includes(e.LCHPromptClass) &amp;&amp; e.LCHPromptDotModeEnabled }
	    function create_if_block_3(ctx) {
	    	let input;
	    	let mounted;
	    	let dispose;

	    	function input_input_handler_1() {
	    		/*input_input_handler_1*/ ctx[9].call(input, /*each_value*/ ctx[17], /*e_index*/ ctx[18]);
	    	}

	    	const block = {
	    		c: function create() {
	    			input = element(&#34;input&#34;);
	    			attr_dev(input, &#34;class&#34;, &#34;LCHLauncherPromptDotModeInput svelte-1rxh210&#34;);
	    			input.autofocus = true;
	    			add_location(input, file$4, 910, 3, 29369);
	    		},
	    		m: function mount(target, anchor) {
	    			insert_dev(target, input, anchor);
	    			set_input_value(input, /*e*/ ctx[16].LCHPromptDotModeText);
	    			input.focus();

	    			if (!mounted) {
	    				dispose = [
	    					listen_dev(input, &#34;input&#34;, input_input_handler_1),
	    					listen_dev(
	    						input,
	    						&#34;input&#34;,
	    						function () {
	    							if (is_function(/*mod*/ ctx[1].InterfaceDotModeFieldDidInput)) /*mod*/ ctx[1].InterfaceDotModeFieldDidInput.apply(this, arguments);
	    						},
	    						false,
	    						false,
	    						false
	    					)
	    				];

	    				mounted = true;
	    			}
	    		},
	    		p: function update(new_ctx, dirty) {
	    			ctx = new_ctx;

	    			if (dirty &amp; /*mod*/ 2 &amp;&amp; input.value !== /*e*/ ctx[16].LCHPromptDotModeText) {
	    				set_input_value(input, /*e*/ ctx[16].LCHPromptDotModeText);
	    			}
	    		},
	    		d: function destroy(detaching) {
	    			if (detaching) detach_dev(input);
	    			mounted = false;
	    			run_all(dispose);
	    		}
	    	};

	    	dispatch_dev(&#34;SvelteRegisterBlock&#34;, {
	    		block,
	    		id: create_if_block_3.name,
	    		type: &#34;if&#34;,
	    		source: &#34;(910:2) {#if ![&#39;LCHLauncherFilterPrompt&#39;, &#39;LCHLauncherActionPrompt&#39;].includes(e.LCHPromptClass) &amp;&amp; e.LCHPromptDotModeEnabled }&#34;,
	    		ctx
	    	});

	    	return block;
	    }

	    // (894:1) &lt;LCHLauncherPrompt   PromptItems={ e.LCHPromptItemsVisible }   ItemSelected={ e.LCHPromptItemSelected }   ItemSelectedHidden={ LRTOptions.LCHOptionMode !== LCHLauncherLogic.LCHLauncherModePipe() || e.LCHPromptDotModeEnabled }   ResultsHidden={ e.LCHPromptResultsThrottle !== false }   on:ResultListDispatchArrow={ (event) =&gt; ActivePromptItemSelectedShouldUpdate(event.detail) }   on:ResultListDispatchClick={ (event) =&gt; ActivePromptItemSelectedShouldUpdate(event.detail) || mod.ControlTerminate() }   &gt;
	    function create_default_slot$1(ctx) {
	    	let t0;
	    	let t1;
	    	let show_if = ![&#34;LCHLauncherFilterPrompt&#34;, &#34;LCHLauncherActionPrompt&#34;].includes(/*e*/ ctx[16].LCHPromptClass) &amp;&amp; /*e*/ ctx[16].LCHPromptDotModeEnabled;
	    	let if_block2_anchor;
	    	let if_block0 = /*e*/ ctx[16].LCHPromptClass === &#34;LCHLauncherSubjectPrompt&#34; &amp;&amp; !/*e*/ ctx[16].LCHPromptDotModeEnabled &amp;&amp; create_if_block_5(ctx);
	    	let if_block1 = /*e*/ ctx[16].LCHPromptClass === &#34;LCHLauncherFilterPrompt&#34; &amp;&amp; create_if_block_4(ctx);
	    	let if_block2 = show_if &amp;&amp; create_if_block_3(ctx);

	    	const block = {
	    		c: function create() {
	    			if (if_block0) if_block0.c();
	    			t0 = space();
	    			if (if_block1) if_block1.c();
	    			t1 = space();
	    			if (if_block2) if_block2.c();
	    			if_block2_anchor = empty();
	    		},
	    		m: function mount(target, anchor) {
	    			if (if_block0) if_block0.m(target, anchor);
	    			insert_dev(target, t0, anchor);
	    			if (if_block1) if_block1.m(target, anchor);
	    			insert_dev(target, t1, anchor);
	    			if (if_block2) if_block2.m(target, anchor);
	    			insert_dev(target, if_block2_anchor, anchor);
	    		},
	    		p: function update(ctx, dirty) {
	    			if (/*e*/ ctx[16].LCHPromptClass === &#34;LCHLauncherSubjectPrompt&#34; &amp;&amp; !/*e*/ ctx[16].LCHPromptDotModeEnabled) {
	    				if (if_block0) {
	    					if_block0.p(ctx, dirty);
	    				} else {
	    					if_block0 = create_if_block_5(ctx);
	    					if_block0.c();
	    					if_block0.m(t0.parentNode, t0);
	    				}
	    			} else if (if_block0) {
	    				if_block0.d(1);
	    				if_block0 = null;
	    			}

	    			if (/*e*/ ctx[16].LCHPromptClass === &#34;LCHLauncherFilterPrompt&#34;) {
	    				if (if_block1) {
	    					if_block1.p(ctx, dirty);
	    				} else {
	    					if_block1 = create_if_block_4(ctx);
	    					if_block1.c();
	    					if_block1.m(t1.parentNode, t1);
	    				}
	    			} else if (if_block1) {
	    				if_block1.d(1);
	    				if_block1 = null;
	    			}

	    			if (dirty &amp; /*mod*/ 2) show_if = ![&#34;LCHLauncherFilterPrompt&#34;, &#34;LCHLauncherActionPrompt&#34;].includes(/*e*/ ctx[16].LCHPromptClass) &amp;&amp; /*e*/ ctx[16].LCHPromptDotModeEnabled;

	    			if (show_if) {
	    				if (if_block2) {
	    					if_block2.p(ctx, dirty);
	    				} else {
	    					if_block2 = create_if_block_3(ctx);
	    					if_block2.c();
	    					if_block2.m(if_block2_anchor.parentNode, if_block2_anchor);
	    				}
	    			} else if (if_block2) {
	    				if_block2.d(1);
	    				if_block2 = null;
	    			}
	    		},
	    		d: function destroy(detaching) {
	    			if (if_block0) if_block0.d(detaching);
	    			if (detaching) detach_dev(t0);
	    			if (if_block1) if_block1.d(detaching);
	    			if (detaching) detach_dev(t1);
	    			if (if_block2) if_block2.d(detaching);
	    			if (detaching) detach_dev(if_block2_anchor);
	    		}
	    	};

	    	dispatch_dev(&#34;SvelteRegisterBlock&#34;, {
	    		block,
	    		id: create_default_slot$1.name,
	    		type: &#34;slot&#34;,
	    		source: &#34;(894:1) &lt;LCHLauncherPrompt   PromptItems={ e.LCHPromptItemsVisible }   ItemSelected={ e.LCHPromptItemSelected }   ItemSelectedHidden={ LRTOptions.LCHOptionMode !== LCHLauncherLogic.LCHLauncherModePipe() || e.LCHPromptDotModeEnabled }   ResultsHidden={ e.LCHPromptResultsThrottle !== false }   on:ResultListDispatchArrow={ (event) =&gt; ActivePromptItemSelectedShouldUpdate(event.detail) }   on:ResultListDispatchClick={ (event) =&gt; ActivePromptItemSelectedShouldUpdate(event.detail) || mod.ControlTerminate() }   &gt;&#34;,
	    		ctx
	    	});

	    	return block;
	    }

	    // (885:0) {#each mod._ValuePromptObjects as e}
	    function create_each_block$1(ctx) {
	    	let if_block_anchor;
	    	let current;
	    	let if_block = /*e*/ ctx[16].LCHPromptIsVisible &amp;&amp; create_if_block_2(ctx);

	    	const block = {
	    		c: function create() {
	    			if (if_block) if_block.c();
	    			if_block_anchor = empty();
	    		},
	    		m: function mount(target, anchor) {
	    			if (if_block) if_block.m(target, anchor);
	    			insert_dev(target, if_block_anchor, anchor);
	    			current = true;
	    		},
	    		p: function update(ctx, dirty) {
	    			if (/*e*/ ctx[16].LCHPromptIsVisible) {
	    				if (if_block) {
	    					if_block.p(ctx, dirty);

	    					if (dirty &amp; /*mod*/ 2) {
	    						transition_in(if_block, 1);
	    					}
	    				} else {
	    					if_block = create_if_block_2(ctx);
	    					if_block.c();
	    					transition_in(if_block, 1);
	    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
	    				}
	    			} else if (if_block) {
	    				group_outros();

	    				transition_out(if_block, 1, 1, () =&gt; {
	    					if_block = null;
	    				});

	    				check_outros();
	    			}
	    		},
	    		i: function intro(local) {
	    			if (current) return;
	    			transition_in(if_block);
	    			current = true;
	    		},
	    		o: function outro(local) {
	    			transition_out(if_block);
	    			current = false;
	    		},
	    		d: function destroy(detaching) {
	    			if (if_block) if_block.d(detaching);
	    			if (detaching) detach_dev(if_block_anchor);
	    		}
	    	};

	    	dispatch_dev(&#34;SvelteRegisterBlock&#34;, {
	    		block,
	    		id: create_each_block$1.name,
	    		type: &#34;each&#34;,
	    		source: &#34;(885:0) {#each mod._ValuePromptObjects as e}&#34;,
	    		ctx
	    	});

	    	return block;
	    }

	    // (920:0) {#if OLSK_SPEC_UI() }
	    function create_if_block_1$2(ctx) {
	    	let button;
	    	let mounted;
	    	let dispose;

	    	const block = {
	    		c: function create() {
	    			button = element(&#34;button&#34;);
	    			attr_dev(button, &#34;id&#34;, &#34;TestLCHDebugCloseButton&#34;);
	    			attr_dev(button, &#34;class&#34;, &#34;svelte-1rxh210&#34;);
	    			add_location(button, file$4, 920, 1, 29589);
	    		},
	    		m: function mount(target, anchor) {
	    			insert_dev(target, button, anchor);

	    			if (!mounted) {
	    				dispose = listen_dev(
	    					button,
	    					&#34;click&#34;,
	    					function () {
	    						if (is_function(/*mod*/ ctx[1].ControlExit)) /*mod*/ ctx[1].ControlExit.apply(this, arguments);
	    					},
	    					false,
	    					false,
	    					false
	    				);

	    				mounted = true;
	    			}
	    		},
	    		p: function update(new_ctx, dirty) {
	    			ctx = new_ctx;
	    		},
	    		d: function destroy(detaching) {
	    			if (detaching) detach_dev(button);
	    			mounted = false;
	    			dispose();
	    		}
	    	};

	    	dispatch_dev(&#34;SvelteRegisterBlock&#34;, {
	    		block,
	    		id: create_if_block_1$2.name,
	    		type: &#34;if&#34;,
	    		source: &#34;(920:0) {#if OLSK_SPEC_UI() }&#34;,
	    		ctx
	    	});

	    	return block;
	    }

	    // (926:0) {#if mod._ValueSecondaryComponentDescriptor}
	    function create_if_block$3(ctx) {
	    	let switch_instance;
	    	let switch_instance_anchor;
	    	let current;
	    	const switch_instance_spread_levels = [/*mod*/ ctx[1]._ValueSecondaryComponentDescriptor.LCHInstanceProps];
	    	var switch_value = /*mod*/ ctx[1]._ValueSecondaryComponentDescriptor.LCHInstanceClass;

	    	function switch_props(ctx) {
	    		let switch_instance_props = {};

	    		for (let i = 0; i &lt; switch_instance_spread_levels.length; i += 1) {
	    			switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
	    		}

	    		return {
	    			props: switch_instance_props,
	    			$$inline: true
	    		};
	    	}

	    	if (switch_value) {
	    		switch_instance = new switch_value(switch_props());
	    	}

	    	const block = {
	    		c: function create() {
	    			if (switch_instance) create_component(switch_instance.$$.fragment);
	    			switch_instance_anchor = empty();
	    		},
	    		m: function mount(target, anchor) {
	    			if (switch_instance) {
	    				mount_component(switch_instance, target, anchor);
	    			}

	    			insert_dev(target, switch_instance_anchor, anchor);
	    			current = true;
	    		},
	    		p: function update(ctx, dirty) {
	    			const switch_instance_changes = (dirty &amp; /*mod*/ 2)
	    			? get_spread_update(switch_instance_spread_levels, [
	    					get_spread_object(/*mod*/ ctx[1]._ValueSecondaryComponentDescriptor.LCHInstanceProps)
	    				])
	    			: {};

	    			if (switch_value !== (switch_value = /*mod*/ ctx[1]._ValueSecondaryComponentDescriptor.LCHInstanceClass)) {
	    				if (switch_instance) {
	    					group_outros();
	    					const old_component = switch_instance;

	    					transition_out(old_component.$$.fragment, 1, 0, () =&gt; {
	    						destroy_component(old_component, 1);
	    					});

	    					check_outros();
	    				}

	    				if (switch_value) {
	    					switch_instance = new switch_value(switch_props());
	    					create_component(switch_instance.$$.fragment);
	    					transition_in(switch_instance.$$.fragment, 1);
	    					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
	    				} else {
	    					switch_instance = null;
	    				}
	    			} else if (switch_value) {
	    				switch_instance.$set(switch_instance_changes);
	    			}
	    		},
	    		i: function intro(local) {
	    			if (current) return;
	    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
	    			current = true;
	    		},
	    		o: function outro(local) {
	    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
	    			current = false;
	    		},
	    		d: function destroy(detaching) {
	    			if (detaching) detach_dev(switch_instance_anchor);
	    			if (switch_instance) destroy_component(switch_instance, detaching);
	    		}
	    	};

	    	dispatch_dev(&#34;SvelteRegisterBlock&#34;, {
	    		block,
	    		id: create_if_block$3.name,
	    		type: &#34;if&#34;,
	    		source: &#34;(926:0) {#if mod._ValueSecondaryComponentDescriptor}&#34;,
	    		ctx
	    	});

	    	return block;
	    }

	    function create_fragment$4(ctx) {
	    	let div;
	    	let t0;
	    	let show_if = main_1();
	    	let t1;
	    	let if_block1_anchor;
	    	let current;
	    	let mounted;
	    	let dispose;
	    	let each_value = /*mod*/ ctx[1]._ValuePromptObjects;
	    	validate_each_argument(each_value);
	    	let each_blocks = [];

	    	for (let i = 0; i &lt; each_value.length; i += 1) {
	    		each_blocks[i] = create_each_block$1(get_each_context$1(ctx, each_value, i));
	    	}

	    	const out = i =&gt; transition_out(each_blocks[i], 1, 1, () =&gt; {
	    		each_blocks[i] = null;
	    	});

	    	let if_block0 = show_if &amp;&amp; create_if_block_1$2(ctx);
	    	let if_block1 = /*mod*/ ctx[1]._ValueSecondaryComponentDescriptor &amp;&amp; create_if_block$3(ctx);

	    	const block = {
	    		c: function create() {
	    			div = element(&#34;div&#34;);

	    			for (let i = 0; i &lt; each_blocks.length; i += 1) {
	    				each_blocks[i].c();
	    			}

	    			t0 = space();
	    			if (if_block0) if_block0.c();
	    			t1 = space();
	    			if (if_block1) if_block1.c();
	    			if_block1_anchor = empty();
	    			attr_dev(div, &#34;class&#34;, &#34;Container LCHLauncher svelte-1rxh210&#34;);
	    			add_location(div, file$4, 882, 0, 27399);
	    		},
	    		l: function claim(nodes) {
	    			throw new Error(&#34;options.hydrate only works if the component was compiled with the `hydratable: true` option&#34;);
	    		},
	    		m: function mount(target, anchor) {
	    			insert_dev(target, div, anchor);

	    			for (let i = 0; i &lt; each_blocks.length; i += 1) {
	    				each_blocks[i].m(div, null);
	    			}

	    			append_dev(div, t0);
	    			if (if_block0) if_block0.m(div, null);
	    			/*div_binding*/ ctx[13](div);
	    			insert_dev(target, t1, anchor);
	    			if (if_block1) if_block1.m(target, anchor);
	    			insert_dev(target, if_block1_anchor, anchor);
	    			current = true;

	    			if (!mounted) {
	    				dispose = [
	    					listen_dev(
	    						window_1,
	    						&#34;keydown&#34;,
	    						function () {
	    							if (is_function(/*mod*/ ctx[1].interfaceDidKeydown)) /*mod*/ ctx[1].interfaceDidKeydown.apply(this, arguments);
	    						},
	    						false,
	    						false,
	    						false
	    					),
	    					listen_dev(
	    						window_1,
	    						&#34;click&#34;,
	    						function () {
	    							if (is_function(/*mod*/ ctx[1].InterfaceBodyDidClick)) /*mod*/ ctx[1].InterfaceBodyDidClick.apply(this, arguments);
	    						},
	    						false,
	    						false,
	    						false
	    					),
	    					listen_dev(
	    						window_1,
	    						&#34;touchstart&#34;,
	    						function () {
	    							if (is_function(/*mod*/ ctx[1].InterfaceBodyDidClick)) /*mod*/ ctx[1].InterfaceBodyDidClick.apply(this, arguments);
	    						},
	    						false,
	    						false,
	    						false
	    					)
	    				];

	    				mounted = true;
	    			}
	    		},
	    		p: function update(new_ctx, [dirty]) {
	    			ctx = new_ctx;

	    			if (dirty &amp; /*mod, LRTOptions, LCHLauncherLogic, ActivePromptItemSelectedShouldUpdate, OLSKLocalized, ActivePromptFilterTextShouldUpdate*/ 31) {
	    				each_value = /*mod*/ ctx[1]._ValuePromptObjects;
	    				validate_each_argument(each_value);
	    				let i;

	    				for (i = 0; i &lt; each_value.length; i += 1) {
	    					const child_ctx = get_each_context$1(ctx, each_value, i);

	    					if (each_blocks[i]) {
	    						each_blocks[i].p(child_ctx, dirty);
	    						transition_in(each_blocks[i], 1);
	    					} else {
	    						each_blocks[i] = create_each_block$1(child_ctx);
	    						each_blocks[i].c();
	    						transition_in(each_blocks[i], 1);
	    						each_blocks[i].m(div, t0);
	    					}
	    				}

	    				group_outros();

	    				for (i = each_value.length; i &lt; each_blocks.length; i += 1) {
	    					out(i);
	    				}

	    				check_outros();
	    			}

	    			if (show_if) if_block0.p(ctx, dirty);

	    			if (/*mod*/ ctx[1]._ValueSecondaryComponentDescriptor) {
	    				if (if_block1) {
	    					if_block1.p(ctx, dirty);

	    					if (dirty &amp; /*mod*/ 2) {
	    						transition_in(if_block1, 1);
	    					}
	    				} else {
	    					if_block1 = create_if_block$3(ctx);
	    					if_block1.c();
	    					transition_in(if_block1, 1);
	    					if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
	    				}
	    			} else if (if_block1) {
	    				group_outros();

	    				transition_out(if_block1, 1, 1, () =&gt; {
	    					if_block1 = null;
	    				});

	    				check_outros();
	    			}
	    		},
	    		i: function intro(local) {
	    			if (current) return;

	    			for (let i = 0; i &lt; each_value.length; i += 1) {
	    				transition_in(each_blocks[i]);
	    			}

	    			transition_in(if_block1);
	    			current = true;
	    		},
	    		o: function outro(local) {
	    			each_blocks = each_blocks.filter(Boolean);

	    			for (let i = 0; i &lt; each_blocks.length; i += 1) {
	    				transition_out(each_blocks[i]);
	    			}

	    			transition_out(if_block1);
	    			current = false;
	    		},
	    		d: function destroy(detaching) {
	    			if (detaching) detach_dev(div);
	    			destroy_each(each_blocks, detaching);
	    			if (if_block0) if_block0.d();
	    			/*div_binding*/ ctx[13](null);
	    			if (detaching) detach_dev(t1);
	    			if (if_block1) if_block1.d(detaching);
	    			if (detaching) detach_dev(if_block1_anchor);
	    			mounted = false;
	    			run_all(dispose);
	    		}
	    	};

	    	dispatch_dev(&#34;SvelteRegisterBlock&#34;, {
	    		block,
	    		id: create_fragment$4.name,
	    		type: &#34;component&#34;,
	    		source: &#34;&#34;,
	    		ctx
	    	});

	    	return block;
	    }

	    function instance$4($$self, $$props, $$invalidate) {
	    	let { $$slots: slots = {}, $$scope } = $$props;
	    	validate_slots(&#34;Main&#34;, slots, []);
	    	let { LRTOptions = {} } = $$props;
	    	let { LRTDidFinish = null } = $$props;
	    	LRTOptions = mod$3.LCHLauncherOptions(LRTOptions, main_1() ? undefined : console.warn);

	    	const OLSKLocalized = function (translationConstant) {
	    		return OLSKInternational.OLSKInternationalLocalizedString(translationConstant, JSON.parse(`{&#34;en&#34;:{&#34;LCHLauncherInputPlaceholderDefault&#34;:&#34;Type to search&#34;,&#34;LCHLauncherInputPlaceholderPreview&#34;:&#34;Type to filter&#34;,&#34;LCHLauncherSubjectPromptPlaceholderText&#34;:&#34;Type to search&#34;,&#34;LCHLauncherSubjectPromptHeadingText&#34;:&#34;Subject&#34;,&#34;LCHLauncherActionPromptHeadingText&#34;:&#34;Action&#34;,&#34;LCHLauncherObjectPromptHeadingText&#34;:&#34;Object&#34;,&#34;LCHCopyToClipboardButtonText&#34;:&#34;Copy to clipboard&#34;,&#34;LCHStandardRecipeNames&#34;:{&#34;LCHActiveDocumentFocusElements&#34;:&#34;Active Document Focus Elements&#34;,&#34;LCHCopyToClipboard&#34;:&#34;Copy to clipboard&#34;,&#34;LCHLargeText&#34;:&#34;Large text&#34;,&#34;LCHDOMElementFocus&#34;:&#34;Focus&#34;,&#34;LCHRunCommand&#34;:&#34;Run Command&#34;,&#34;LCHSearchWith&#34;:&#34;Search With&#34;,&#34;LCHSearchFor&#34;:&#34;Search For&#34;,&#34;LCHSubjectContainerShowContents&#34;:&#34;Show Contents&#34;,&#34;LCHURLOpen&#34;:&#34;Open URL&#34;,&#34;SubjectContainer&#34;:&#34;Subject Container&#34;,&#34;String&#34;:&#34;String&#34;,&#34;Date&#34;:&#34;Date&#34;,&#34;URL&#34;:&#34;URL&#34;,&#34;ServiceSearchURLTemplate&#34;:&#34;Search Service URL Template&#34;,&#34;DOMElement&#34;:&#34;DOM Element&#34;}},&#34;es&#34;:{&#34;LCHLauncherInputPlaceholderDefault&#34;:&#34;Escribir para buscar&#34;,&#34;LCHLauncherInputPlaceholderPreview&#34;:&#34;Escribir para filtrar&#34;,&#34;LCHLauncherSubjectPromptPlaceholderText&#34;:&#34;Escribir para buscar&#34;,&#34;LCHLauncherSubjectPromptHeadingText&#34;:&#34;Sujeto&#34;,&#34;LCHLauncherActionPromptHeadingText&#34;:&#34;Acto&#34;,&#34;LCHLauncherObjectPromptHeadingText&#34;:&#34;Objeto&#34;,&#34;LCHCopyToClipboardButtonText&#34;:&#34;Copiar al portapapeles&#34;,&#34;LCHStandardRecipeNames&#34;:{&#34;LCHActiveDocumentFocusElements&#34;:&#34;Elementos enfocados del documento activo&#34;,&#34;LCHCopyToClipboard&#34;:&#34;Copiar al portapapeles&#34;,&#34;LCHLargeText&#34;:&#34;Texto aumentado&#34;,&#34;LCHDOMElementFocus&#34;:&#34;Enfocar&#34;,&#34;LCHRunCommand&#34;:&#34;Ejecutar comando&#34;,&#34;LCHSearchWith&#34;:&#34;Buscar con&#34;,&#34;LCHSearchFor&#34;:&#34;Buscar para&#34;,&#34;LCHSubjectContainerShowContents&#34;:&#34;Mostrar contenidos&#34;,&#34;LCHURLOpen&#34;:&#34;Abrir URL&#34;,&#34;SubjectContainer&#34;:&#34;Contenido de sujetos&#34;,&#34;String&#34;:&#34;String&#34;,&#34;Date&#34;:&#34;Date&#34;,&#34;URL&#34;:&#34;URL&#34;,&#34;ServiceSearchURLTemplate&#34;:&#34;Plantilla URL de servicio de búsqueda&#34;,&#34;DOMElement&#34;:&#34;Elemento DOM&#34;}},&#34;fr&#34;:{&#34;LCHLauncherInputPlaceholderDefault&#34;:&#34;Taper pour chercher&#34;,&#34;LCHLauncherInputPlaceholderPreview&#34;:&#34;Taper pour filtrer&#34;,&#34;LCHLauncherSubjectPromptPlaceholderText&#34;:&#34;Taper pour chercher&#34;,&#34;LCHLauncherSubjectPromptHeadingText&#34;:&#34;Sujet&#34;,&#34;LCHLauncherActionPromptHeadingText&#34;:&#34;Action&#34;,&#34;LCHLauncherObjectPromptHeadingText&#34;:&#34;Objet&#34;,&#34;LCHCopyToClipboardButtonText&#34;:&#34;Copier dans le presse-papier&#34;,&#34;LCHStandardRecipeNames&#34;:{&#34;LCHActiveDocumentFocusElements&#34;:&#34;Éléments au points du document active&#34;,&#34;LCHCopyToClipboard&#34;:&#34;Copier dans le presse-papier&#34;,&#34;LCHLargeText&#34;:&#34;Texte élargi&#34;,&#34;LCHDOMElementFocus&#34;:&#34;Faire le point&#34;,&#34;LCHRunCommand&#34;:&#34;Exécuter la commande&#34;,&#34;LCHSearchWith&#34;:&#34;Chercher avec&#34;,&#34;LCHSearchFor&#34;:&#34;Chercher pour&#34;,&#34;LCHSubjectContainerShowContents&#34;:&#34;Montrer le contenu&#34;,&#34;LCHURLOpen&#34;:&#34;Ouvrir l&#39;URL&#34;,&#34;SubjectContainer&#34;:&#34;Contenant des sujets&#34;,&#34;String&#34;:&#34;String&#34;,&#34;Date&#34;:&#34;Date&#34;,&#34;URL&#34;:&#34;URL&#34;,&#34;ServiceSearchURLTemplate&#34;:&#34;Modèle URL de service de recherche&#34;,&#34;DOMElement&#34;:&#34;Élément DOM&#34;}},&#34;pt&#34;:{&#34;LCHLauncherInputPlaceholderDefault&#34;:&#34;Digitar para pesquisar&#34;,&#34;LCHLauncherInputPlaceholderPreview&#34;:&#34;Digitar para filtrar&#34;,&#34;LCHLauncherSubjectPromptPlaceholderText&#34;:&#34;Digitar para pesquisar&#34;,&#34;LCHLauncherSubjectPromptHeadingText&#34;:&#34;Sujeito&#34;,&#34;LCHLauncherActionPromptHeadingText&#34;:&#34;Ação&#34;,&#34;LCHLauncherObjectPromptHeadingText&#34;:&#34;Objeto&#34;,&#34;LCHCopyToClipboardButtonText&#34;:&#34;Cópia na área de transferência&#34;,&#34;LCHStandardRecipeNames&#34;:{&#34;LCHActiveDocumentFocusElements&#34;:&#34;Elementos de foco no documento ativo&#34;,&#34;LCHCopyToClipboard&#34;:&#34;Cópia na área de transferência&#34;,&#34;LCHLargeText&#34;:&#34;Texto grande&#34;,&#34;LCHDOMElementFocus&#34;:&#34;Foco&#34;,&#34;LCHRunCommand&#34;:&#34;Executar Comando&#34;,&#34;LCHSearchWith&#34;:&#34;Buscar com&#34;,&#34;LCHSearchFor&#34;:&#34;Buscar por&#34;,&#34;LCHSubjectContainerShowContents&#34;:&#34;Mostrar conteúdo&#34;,&#34;LCHURLOpen&#34;:&#34;Abrir URL&#34;,&#34;SubjectContainer&#34;:&#34;Contêiner do Sujeito&#34;,&#34;String&#34;:&#34;Sequência&#34;,&#34;Date&#34;:&#34;Data&#34;,&#34;URL&#34;:&#34;URL&#34;,&#34;ServiceSearchURLTemplate&#34;:&#34;Modelo de URL do serviço de pesquisa&#34;,&#34;DOMElement&#34;:&#34;Elemento do DOM&#34;}}}`)[LRTOptions.LCHOptionLanguage]);
	    	};

	    	function ActivePromptFilterTextShouldUpdate(inputData) {
	    		(function SetFilterText() {
	    			$$invalidate(1, mod._ValuePromptObjects[mod._ValuePromptActiveIndex].LCHPromptFilterText = inputData, mod);
	    		})();

	    		(function ClearFilterTextOnSubsequentPrompts() {
	    			for (var i = 0; i &lt; mod._ValuePromptObjects.length; i++) {
	    				if (!i) {
	    					continue;
	    				}

	    				if (i === mod._ValuePromptActiveIndex) {
	    					continue;
	    				}

	    				$$invalidate(1, mod._ValuePromptObjects[i].LCHPromptFilterText = &#34;&#34;, mod);
	    				$$invalidate(1, mod._ValuePromptObjects[i].LCHPromptMatchStop = false, mod);
	    			}
	    		})();

	    		(function SetMatchStop() {
	    			if (LRTOptions.LCHOptionMode !== mod$3.LCHLauncherModePipe()) {
	    				return;
	    			}

	    			if (mod._ValuePromptObjects[mod._ValuePromptActiveIndex].LCHPromptInputThrottle === false) {
	    				$$invalidate(1, mod._ValuePromptObjects[mod._ValuePromptActiveIndex].LCHPromptMatchStop = false, mod);
	    			}

	    			if (!mod._ValuePromptObjects[mod._ValuePromptActiveIndex].LCHPromptFilterText) {
	    				$$invalidate(1, mod._ValuePromptObjects[mod._ValuePromptActiveIndex].LCHPromptMatchStop = false, mod);
	    			}
	    		})();

	    		(function ThrottleInput() {
	    			if (LRTOptions.LCHOptionMode !== mod$3.LCHLauncherModePipe()) {
	    				return;
	    			}

	    			if (!mod._ValuePromptObjects[mod._ValuePromptActiveIndex].LCHPromptFilterText) {
	    				return;
	    			}

	    			const inputData = mod._ValuePromptActiveIndex;

	    			main$2.OLSKThrottleMappedTimeout(mod._ValuePromptObjects[inputData], &#34;LCHPromptInputThrottle&#34;, {
	    				OLSKThrottleDuration: mod$3.LCHLauncherThrottleDuration,
	    				OLSKThrottleCallback() {
	    					setTimeout(function () {
	    						$$invalidate(1, mod._ValuePromptObjects[inputData].LCHPromptInputThrottle = false, mod);
	    					});
	    				}
	    			});
	    		})();

	    		(function ThrottleResults() {
	    			if (LRTOptions.LCHOptionMode !== mod$3.LCHLauncherModePipe()) {
	    				return;
	    			}

	    			if (!mod._ValuePromptObjects[mod._ValuePromptActiveIndex].LCHPromptFilterText) {
	    				return;
	    			}

	    			const inputData = mod._ValuePromptActiveIndex;

	    			main$2.OLSKThrottleMappedTimeout(mod._ValuePromptObjects[inputData], &#34;LCHPromptResultsThrottle&#34;, {
	    				OLSKThrottleDuration: mod$3.LCHLauncherThrottleDuration,
	    				OLSKThrottleCallback() {
	    					setTimeout(function () {
	    						$$invalidate(1, mod._ValuePromptObjects[inputData].LCHPromptResultsThrottle = false, mod);
	    					});
	    				}
	    			});
	    		})();

	    		(function SetItems() {
	    			ActivePromptItemsShouldUpdate((function () {
	    				if (LRTOptions.LCHOptionMode === mod$3.LCHLauncherModePipe() &amp;&amp; !mod._ValuePromptObjects[mod._ValuePromptActiveIndex].LCHPromptFilterText &amp;&amp; mod._ValuePromptObjects[mod._ValuePromptActiveIndex].LCHPromptResultsThrottle === false) {
	    					return mod._ValuePromptObjects[mod._ValuePromptActiveIndex].LCHPromptItemsVisible;
	    				}

	    				if (!mod._ValuePromptObjects[mod._ValuePromptActiveIndex].LCHPromptFilterText) {
	    					return LRTOptions.LCHOptionMode === mod$3.LCHLauncherModePreview()
	    					? mod._ValuePromptObjects[mod._ValuePromptActiveIndex].LCHPromptItemsAll
	    					: [];
	    				}

	    				const visibleRecipes = mod._ValuePromptObjects[mod._ValuePromptActiveIndex].LCHPromptItemsAll.filter(function (e) {
	    					return e.LCHRecipeIsExcluded ? !e.LCHRecipeIsExcluded() : true;
	    				});

	    				let results = fuzzysort.go(mod._ValuePromptObjects[mod._ValuePromptActiveIndex].LCHPromptFilterText, visibleRecipes, { key: &#34;LCHRecipeName&#34; });

	    				if (!results.length &amp;&amp; main_1() &amp;&amp; !mod._ValuePromptObjects[mod._ValuePromptActiveIndex].LCHPromptFilterText.slice(0, 3).match(/[^A-Z]/)) {
	    					return visibleRecipes.filter(function (e) {
	    						return e.LCHRecipeSignature === mod._ValuePromptObjects[mod._ValuePromptActiveIndex].LCHPromptFilterText;
	    					});
	    				}

	    				

	    				if (LRTOptions.LCHOptionMode === mod$3.LCHLauncherModePipe() &amp;&amp; mod._ValuePromptObjects[mod._ValuePromptActiveIndex].LCHPromptItemsVisible.length &amp;&amp; !results.length) {
	    					if (mod._ValuePromptObjects[mod._ValuePromptActiveIndex].LCHPromptResultsThrottle) {
	    						main$2.OLSKThrottleSkip(mod._ValuePromptObjects[mod._ValuePromptActiveIndex].LCHPromptResultsThrottle);
	    					}

	    					$$invalidate(1, mod._ValuePromptObjects[mod._ValuePromptActiveIndex].LCHPromptMatchStop = true, mod);
	    					return mod._ValuePromptObjects[mod._ValuePromptActiveIndex].LCHPromptItemsVisible;
	    				}

	    				return results.sort(function (a, b) {
	    					return a.score &lt; b.score ? 1 : a.score &gt; b.score ? -1 : 0;
	    				}).map(function (e) {
	    					return e.obj;
	    				});
	    			})());
	    		})();
	    	}

	    	function ActivePromptItemsShouldUpdate(inputData) {
	    		(function SetItems() {
	    			$$invalidate(1, mod._ValuePromptObjects[mod._ValuePromptActiveIndex].LCHPromptItemsVisible = inputData, mod);
	    		})();

	    		(function SetItemSelected() {
	    			ActivePromptItemSelectedShouldUpdate(mod._ValuePromptObjects[mod._ValuePromptActiveIndex].LCHPromptItemsVisible[0]);
	    		})();
	    	}

	    	function ActivePromptItemSelectedShouldUpdate(inputData) {
	    		(function SetItemSelected() {
	    			$$invalidate(1, mod._ValuePromptObjects[mod._ValuePromptActiveIndex].LCHPromptItemSelected = inputData, mod);

	    			if (LRTOptions.LCHOptionMode !== mod$3.LCHLauncherModePreview()) {
	    				return;
	    			}

	    			mod.ControlRun(mod._ValuePromptObjects[0].LCHPromptItemSelected);
	    		})();

	    		if (LRTOptions.LCHOptionMode !== mod$3.LCHLauncherModePipe()) {
	    			return;
	    		}

	    		(function UpdateActionsForSubject() {
	    			if (mod._ValuePromptActiveIndex !== 0) {
	    				return;
	    			}

	    			if (!mod._ValuePromptObjects[mod._ValuePromptActiveIndex].LCHPromptItemSelected) {
	    				$$invalidate(1, mod._ValuePromptObjects[1].LCHPromptItemsVisible = $$invalidate(1, mod._ValuePromptObjects[1].LCHPromptItemsAll = [], mod), mod);
	    				delete mod._ValuePromptObjects[1].LCHPromptItemSelected;
	    				return;
	    			}

	    			$$invalidate(
	    				1,
	    				mod._ValuePromptObjects[1].LCHPromptItemsAll = mod._ValueAllActions.filter(function (e) {
	    					return mod._ValueTypeEquivalenceMap[inputData.LCHRecipeOutputType || &#34;Command&#34;].filter(function (type) {
	    						return mod$1.LCHRuntimeInputTypes(e.LCHRecipeInputTypes).shift() === type;
	    					}).length;
	    				}).sort(mod$3.LCHLauncherActionComparator(inputData.LCHRecipeOutputType || &#34;Command&#34;)),
	    				mod
	    			);

	    			$$invalidate(1, mod._ValuePromptObjects[1].LCHPromptItemsVisible = mod._ValuePromptObjects[1].LCHPromptItemsAll, mod);
	    			$$invalidate(1, mod._ValuePromptObjects[1].LCHPromptItemSelected = mod._ValuePromptObjects[1].LCHPromptItemsVisible[0], mod);
	    		})();

	    		(function UpdateObjectsForAction() {
	    			if (mod._ValuePromptActiveIndex &gt; 1) {
	    				return;
	    			}

	    			if (!mod._ValuePromptObjects[1].LCHPromptItemSelected) {
	    				return;
	    			}

	    			$$invalidate(1, mod._ValuePromptObjects[2].LCHPromptIsVisible = mod$2.LCHRecipesActionTakesObject(mod._ValuePromptObjects[1].LCHPromptItemSelected), mod);

	    			$$invalidate(
	    				1,
	    				mod._ValuePromptObjects[2].LCHPromptItemsAll = !mod._ValuePromptObjects[2].LCHPromptIsVisible || mod$1.LCHRuntimeInputTypes(mod._ValuePromptObjects[1].LCHPromptItemSelected.LCHRecipeInputTypes).pop() === &#34;String&#34;
	    				? []
	    				: mod._ValueAllSubjects.filter(function (e) {
	    						return mod._ValueTypeEquivalenceMap[mod$1.LCHRuntimeInputTypes(mod._ValuePromptObjects[1].LCHPromptItemSelected.LCHRecipeInputTypes).pop()].includes(e.LCHRecipeOutputType);
	    					}),
	    				mod
	    			);

	    			$$invalidate(1, mod._ValuePromptObjects[2].LCHPromptItemsVisible = mod._ValuePromptObjects[2].LCHPromptItemsAll, mod);
	    			$$invalidate(1, mod._ValuePromptObjects[2].LCHPromptItemSelected = mod._ValuePromptObjects[2].LCHPromptItemsVisible[0], mod);
	    		})();
	    	}

	    	const refactorDependancies = function () {
	    		
	    	};

	    	const mod = {
	    		// VALUE
	    		_ValuePromptActiveIndex: 0,
	    		_ValuePromptObjects: [],
	    		_ValueAllPromptRecipes: [],
	    		_ValueAllSubjects: [],
	    		_ValueAllActions: [],
	    		ValuePromptActiveIndex(inputData) {
	    			if (typeof inputData === &#34;undefined&#34;) {
	    				return mod._ValuePromptActiveIndex;
	    			}

	    			(function CancelThrottle() {
	    				if (LRTOptions.LCHOptionMode !== mod$3.LCHLauncherModePipe()) {
	    					return;
	    				}

	    				if (main$2.OLSKThrottleIsValid(mod._ValuePromptObjects[mod._ValuePromptActiveIndex].LCHPromptInputThrottle)) {
	    					clearTimeout(mod._ValuePromptObjects[mod._ValuePromptActiveIndex].LCHPromptInputThrottle._OLSKThrottleTimeoutID);
	    				}

	    				$$invalidate(1, mod._ValuePromptObjects[mod._ValuePromptActiveIndex].LCHPromptInputThrottle = undefined, mod);

	    				if (main$2.OLSKThrottleIsValid(mod._ValuePromptObjects[mod._ValuePromptActiveIndex].LCHPromptResultsThrottle)) {
	    					clearTimeout(mod._ValuePromptObjects[mod._ValuePromptActiveIndex].LCHPromptResultsThrottle._OLSKThrottleTimeoutID);
	    				}

	    				$$invalidate(1, mod._ValuePromptObjects[mod._ValuePromptActiveIndex].LCHPromptResultsThrottle = undefined, mod);
	    			})();

	    			if (!mod._ValuePromptObjects[1].LCHPromptItemsAll.length) {
	    				return;
	    			}

	    			(function SetIndexActive() {
	    				$$invalidate(1, mod._ValuePromptActiveIndex = inputData, mod);
	    			})();

	    			(function ActivateDotMode() {
	    				if (mod._ValuePromptActiveIndex !== 2) {
	    					return;
	    				}

	    				if (mod$1.LCHRuntimeInputTypes(mod._ValuePromptObjects[1].LCHPromptItemSelected.LCHRecipeInputTypes).pop() !== &#34;String&#34;) {
	    					return;
	    				}

	    				mod.ValuePromptDotModeEnabled(true);
	    				mod.ValuePromptDotModeText(mod.ValuePromptDotModeText());
	    			})();
	    		},
	    		ValuePromptDotModeEnabled(inputData) {
	    			if (typeof inputData === &#34;undefined&#34;) {
	    				return mod._ValuePromptObjects[mod._ValuePromptActiveIndex].LCHPromptDotModeEnabled;
	    			}

	    			$$invalidate(1, mod._ValuePromptObjects[mod._ValuePromptActiveIndex].LCHPromptDotModeEnabled = inputData, mod);
	    		},
	    		ValuePromptDotModeText(inputData) {
	    			if (typeof inputData === &#34;undefined&#34;) {
	    				return mod._ValuePromptObjects[mod._ValuePromptActiveIndex].LCHPromptDotModeText;
	    			}

	    			$$invalidate(1, mod._ValuePromptObjects[mod._ValuePromptActiveIndex].LCHPromptDotModeText = inputData, mod);

	    			ActivePromptItemsShouldUpdate(mod._ValuePromptObjects[mod._ValuePromptActiveIndex].LCHPromptDotModeText
	    			? [
	    					{
	    						LCHRecipeName: mod._ValuePromptObjects[mod._ValuePromptActiveIndex].LCHPromptDotModeText,
	    						LCHRecipeCallback() {
	    							return inputData;
	    						},
	    						LCHRecipeOutputType: LCHPrimitiveURLCallback(mod._ValuePromptObjects[mod._ValuePromptActiveIndex].LCHPromptDotModeText)
	    						? &#34;URL&#34;
	    						: &#34;String&#34;
	    					}
	    				]
	    			: []);
	    		},
	    		ValuePromptResultsIsVisible(inputData) {
	    			if (typeof inputData === &#34;undefined&#34;) {
	    				return mod._ValuePromptObjects[mod._ValuePromptActiveIndex].LCHPromptResultsThrottle === false;
	    			}

	    			$$invalidate(1, mod._ValuePromptObjects[mod._ValuePromptActiveIndex].LCHPromptResultsThrottle = inputData ? false : undefined, mod);
	    		},
	    		// DATA
	    		DataComposition() {
	    			if (LRTOptions.LCHOptionMode === mod$3.LCHLauncherModePipe()) {
	    				return {
	    					LCHCompositionAction: mod._ValuePromptObjects[1].LCHPromptItemSelected,
	    					LCHCompositionSubjectPrimary: mod._ValuePromptObjects[0].LCHPromptItemSelected,
	    					LCHCompositionSubjectSecondary: mod._ValuePromptObjects[2].LCHPromptItemSelected
	    				};
	    			}

	    			return {
	    				LCHCompositionAction: Object.assign(LCHRunCommandRecipe(), {
	    					LCHRecipeName: OLSKLocalized(&#34;LCHStandardRecipeNames&#34;)[LCHRunCommandRecipe().LCHRecipeSignature]
	    				}),
	    				LCHCompositionSubjectPrimary: mod._ValuePromptObjects[0].LCHPromptItemSelected
	    			};
	    		},
	    		// INTERFACE
	    		InterfaceBodyDidClick(event) {
	    			if (!mod._ValueComponentDidMount) {
	    				return;
	    			}

	    			

	    			if (mod._ValueRootElementInstance.contains(event.target)) {
	    				return;
	    			}

	    			mod.ControlExit();
	    		},
	    		interfaceDidClickPrompt(inputData) {
	    			if (LRTOptions.LCHOptionMode !== mod$3.LCHLauncherModePipe()) {
	    				return;
	    			}

	    			mod.ValuePromptActiveIndex(mod._ValuePromptObjects.indexOf(inputData));
	    		},
	    		interfaceDidKeydown(event) {
	    			mod.ControlHandleEventKeydown(event);
	    		},
	    		InterfaceDotModeFieldDidInput(event) {
	    			mod.ValuePromptDotModeText(this.value);
	    		},
	    		// CONTROL
	    		_ControlHandleEventKeydownModeDotMode(event) {
	    			const handlerFunctions = {
	    				Escape() {
	    					event.preventDefault();
	    					event.stopPropagation();
	    					return mod.ValuePromptDotModeEnabled(false) || true;
	    				},
	    				Tab() {
	    					event.preventDefault();
	    					event.stopPropagation();

	    					if (!mod.ValuePromptDotModeText()) {
	    						return true;
	    					}

	    					return mod.ValuePromptDotModeEnabled(false);
	    				},
	    				Enter() {
	    					return mod.ValuePromptDotModeEnabled(false);
	    				}
	    			};

	    			if (!handlerFunctions[event.key]) {
	    				return true;
	    			}

	    			return handlerFunctions[event.key]();
	    		},
	    		_ControlHandleEventKeydownEscape(event) {
	    			event.preventDefault();
	    			event.stopPropagation();

	    			if (LRTOptions.LCHOptionMode === mod$3.LCHLauncherModePipe() &amp;&amp; mod.ValuePromptResultsIsVisible()) {
	    				return mod.ValuePromptResultsIsVisible(false);
	    			}

	    			if (LRTOptions.LCHOptionMode !== mod$3.LCHLauncherModePipe() &amp;&amp; mod._ValuePromptObjects[mod._ValuePromptActiveIndex].LCHPromptFilterText) {
	    				return ActivePromptFilterTextShouldUpdate(&#34;&#34;);
	    			}

	    			mod.ControlExit();
	    		},
	    		_ControlHandleEventKeydownTab(event) {
	    			event.preventDefault();

	    			if (LRTOptions.LCHOptionMode !== mod$3.LCHLauncherModePipe()) {
	    				return;
	    			}

	    			mod.ValuePromptActiveIndex(mod$3.LCHLauncherConstrainIndex(
	    				mod._ValuePromptObjects.filter(function (e) {
	    					return e.LCHPromptIsVisible;
	    				}),
	    				mod._ValuePromptActiveIndex + (event.shiftKey ? -1 : 1) * (function () {
	    					if (!mod._ValuePromptActiveIndex &amp;&amp; mod._ValuePromptObjects[2].LCHPromptIsVisible &amp;&amp; mod._ValuePromptObjects[1].LCHPromptItemsAll.length === 1) {
	    						return 2;
	    					}

	    					return 1;
	    				})()
	    			));
	    		},
	    		_ControlHandleEventKeydownEnter(event) {
	    			event.preventDefault();
	    			event.stopPropagation();

	    			if (mod$2.LCHCompositionErrors(mod.DataComposition())) {
	    				return;
	    			}

	    			mod.ControlTerminate();
	    		},
	    		_ControlHandleEventKeydownArrow(event) {
	    			if (LRTOptions.LCHOptionMode !== mod$3.LCHLauncherModePipe()) {
	    				return;
	    			}

	    			event.preventDefault();

	    			if (!mod.ValuePromptResultsIsVisible()) {
	    				return mod.ValuePromptResultsIsVisible(true);
	    			}

	    			if (!mod._ValuePromptObjects[mod._ValuePromptActiveIndex].LCHPromptResultsThrottle) {
	    				return;
	    			}

	    			main$2.OLSKThrottleSkip(mod._ValuePromptObjects[mod._ValuePromptActiveIndex].LCHPromptResultsThrottle);
	    		},
	    		_ControlHandleEventKeydownArrowDown(event) {
	    			if (LRTOptions.LCHOptionMode !== mod$3.LCHLauncherModePipe()) {
	    				return;
	    			}

	    			event.preventDefault();

	    			if (mod._ValuePromptObjects[mod._ValuePromptActiveIndex].LCHPromptResultsThrottle === undefined) {
	    				$$invalidate(1, mod._ValuePromptObjects[mod._ValuePromptActiveIndex].LCHPromptResultsThrottle = false, mod);
	    				return;
	    			}

	    			if (!mod._ValuePromptObjects[mod._ValuePromptActiveIndex].LCHPromptResultsThrottle) {
	    				return;
	    			}

	    			main$2.OLSKThrottleSkip(mod._ValuePromptObjects[mod._ValuePromptActiveIndex].LCHPromptResultsThrottle);
	    		},
	    		_ControlHandleEventKeydownDot(event) {
	    			if (LRTOptions.LCHOptionMode !== mod$3.LCHLauncherModePipe()) {
	    				return;
	    			}

	    			event.preventDefault();

	    			if (mod._ValuePromptActiveIndex !== 0) {
	    				return;
	    			}

	    			if (main$2.OLSKThrottleIsValid(mod._ValuePromptObjects[mod._ValuePromptActiveIndex].LCHPromptResultsThrottle)) {
	    				clearTimeout(mod._ValuePromptObjects[mod._ValuePromptActiveIndex].LCHPromptResultsThrottle._OLSKThrottleTimeoutID);
	    			}

	    			mod.ValuePromptResultsIsVisible(false);
	    			mod.ValuePromptDotModeEnabled(true);
	    			ActivePromptFilterTextShouldUpdate(&#34;&#34;);
	    			mod.ValuePromptDotModeText(mod.ValuePromptDotModeText());

	    			if (mod.ValuePromptDotModeText()) {
	    				return;
	    			}

	    			$$invalidate(1, mod._ValuePromptObjects[1].LCHPromptItemsAll = [], mod);
	    			$$invalidate(1, mod._ValuePromptObjects[1].LCHPromptItemsVisible = [], mod);
	    			delete mod._ValuePromptObjects[1].LCHPromptItemSelected;
	    		},
	    		_ControlHandleEventKeydownBackspace(event) {
	    			if (LRTOptions.LCHOptionMode !== mod$3.LCHLauncherModePipe()) {
	    				return;
	    			}

	    			event.preventDefault();

	    			if (mod._ValuePromptObjects[mod._ValuePromptActiveIndex].LCHPromptResultsThrottle) {
	    				return ActivePromptFilterTextShouldUpdate(mod._ValuePromptObjects[mod._ValuePromptActiveIndex].LCHPromptFilterText.slice(0, -1));
	    			}

	    			if (mod._ValuePromptObjects[mod._ValuePromptActiveIndex].LCHPromptFilterText) {
	    				$$invalidate(1, mod._ValuePromptObjects[mod._ValuePromptActiveIndex].LCHPromptMatchStop = false, mod);
	    				return ActivePromptFilterTextShouldUpdate(&#34;&#34;);
	    			}

	    			ActivePromptItemsShouldUpdate([]);
	    			$$invalidate(1, mod._ValuePromptObjects[mod._ValuePromptActiveIndex].LCHPromptResultsThrottle = undefined, mod);
	    			$$invalidate(1, mod._ValuePromptObjects[mod._ValuePromptActiveIndex].LCHPromptDotModeText = &#34;&#34;, mod);
	    		},
	    		ControlHandleEventKeydown(event) {
	    			if (mod._ValuePromptObjects[mod._ValuePromptActiveIndex].LCHPromptDotModeEnabled &amp;&amp; mod._ControlHandleEventKeydownModeDotMode(event)) {
	    				return;
	    			}

	    			const handlerFunctions = {
	    				Escape: mod._ControlHandleEventKeydownEscape,
	    				Tab: mod._ControlHandleEventKeydownTab,
	    				&#34;.&#34;: mod._ControlHandleEventKeydownDot,
	    				Enter: mod._ControlHandleEventKeydownEnter,
	    				ArrowUp: mod._ControlHandleEventKeydownArrow,
	    				ArrowDown: mod._ControlHandleEventKeydownArrowDown,
	    				Backspace: mod._ControlHandleEventKeydownBackspace
	    			};

	    			if (handlerFunctions[event.key]) {
	    				return handlerFunctions[event.key](event);
	    			}

	    			if (mod._ValuePromptObjects[mod._ValuePromptActiveIndex].LCHPromptDotModeEnabled) {
	    				return;
	    			}

	    			if (LRTOptions.LCHOptionMode !== mod$3.LCHLauncherModePipe()) {
	    				return;
	    			}

	    			event.preventDefault();

	    			if (!mod$3.LCHLauncherKeyboardEventIsTextInput(event)) {
	    				return;
	    			}

	    			ActivePromptFilterTextShouldUpdate(!mod._ValuePromptObjects[mod._ValuePromptActiveIndex].LCHPromptInputThrottle
	    			? event.key
	    			: mod._ValuePromptObjects[mod._ValuePromptActiveIndex].LCHPromptFilterText + event.key);
	    		},
	    		ControlReloadSubjects(inputData) {
	    			let reloadSubjects = mod$3.LCHLauncherReloadableSubjects([inputData]);

	    			if (!reloadSubjects.length) {
	    				return false;
	    			}

	    			
	    			$$invalidate(1, mod._ValuePromptObjects[0].LCHPromptItemsVisible = [], mod);
	    			$$invalidate(1, mod._ValuePromptObjects[0].LCHPromptItemsAll = reloadSubjects, mod);
	    			mod.ValuePromptActiveIndex(0);
	    			ActivePromptItemSelectedShouldUpdate(reloadSubjects[0]);
	    			return true;
	    		},
	    		async ControlTerminate() {
	    			if (LRTOptions.LCHOptionMode === mod$3.LCHLauncherModePipe()) {
	    				if (mod.ControlReloadSubjects(await mod.ControlRun(mod.DataComposition()))) {
	    					return;
	    				}

	    				
	    			}

	    			if (LRTOptions.LCHOptionMode === mod$3.LCHLauncherModeCommit()) {
	    				await mod.ControlRun(mod._ValuePromptObjects[0].LCHPromptItemSelected);
	    			}

	    			mod.ControlExit();
	    		},
	    		async ControlRun(inputData) {
	    			return mod._ControlRun(inputData.LCHCompositionAction
	    			? await mod$2.LCHAPIExecuteComposition(inputData, mod._ValueSharedAPI)
	    			: await mod$2.LCHAPIExecuteRecipe(inputData, [], mod._ValueSharedAPI));
	    		},
	    		async _ControlRun(inputData) {
	    			if (!inputData) {
	    				return Promise.resolve(inputData);
	    			}

	    			if (typeof inputData !== &#34;object&#34;) {
	    				return Promise.resolve(inputData);
	    			}

	    			if (mod$2.LCHComponentDescriptorsErrors(inputData)) {
	    				return Promise.resolve(inputData);
	    			}

	    			return new Promise(function (resolve, reject) {
	    					let LCHInstanceProps = inputData.LCHComponentDescriptorProps;

	    					if (inputData.LCHComponentDescriptorOLSKLocalized) {
	    						Object.assign(LCHInstanceProps, { OLSKLocalized });
	    					}

	    					

	    					LCHInstanceProps[inputData.LCHComponentDescriptorCompletionHandlerSignature] = function () {
	    						delete mod._ValueSecondaryComponentDescriptor;
	    						mod.ControlExit();
	    					};

	    					$$invalidate(
	    						1,
	    						mod._ValueSecondaryComponentDescriptor = {
	    							LCHInstanceClass: apiComponents[inputData.LCHComponentDescriptorName],
	    							LCHInstanceProps
	    						},
	    						mod
	    					);
	    				});
	    		},
	    		ControlExit() {
	    			if (mod._ValueFilterInputInstance === document.activeElement) {
	    				mod._ValueFilterInputInstance.blur();
	    			}

	    			

	    			if (typeof LRTDidFinish !== &#34;function&#34;) {
	    				return;
	    			}

	    			return LRTDidFinish();
	    		},
	    		// REACT
	    		ReactFocusFilterInput() {
	    			if (LRTOptions.LCHOptionMode === mod$3.LCHLauncherModePipe()) {
	    				return;
	    			}

	    			setTimeout(
	    				function () {
	    					mod._ValueFilterInputInstance.focus();
	    				},
	    				20
	    			);
	    		},
	    		ReactScrollSelectedItemIntoView() {
	    			if (main_1()) {
	    				return;
	    			}

	    			/* OLSKResultsListCapAndScroll */
	    			let element = document.querySelector(&#34;.OLSKResultsListItemSelected&#34;);

	    			if (!element) {
	    				return;
	    			}

	    			element.scrollIntoView({ block: &#34;nearest&#34;, inline: &#34;nearest&#34; });
	    		},
	    		// SETUP
	    		async SetupEverything() {
	    			mod.SetupSharedRecipes();
	    			await mod.SetupPageRecipes();
	    			mod.SetupSharedAPI();
	    			mod.SetupTasks();
	    			mod.SetupPromptObjects();
	    		},
	    		SetupSharedRecipes() {
	    			$$invalidate(
	    				1,
	    				mod._ValueSharedRecipes = LCHLauncherStandardRecipes().map(function (e) {
	    					return Object.assign(e, {
	    						LCHRecipeName: e.LCHRecipeName || OLSKLocalized(&#34;LCHStandardRecipeNames&#34;)[e.LCHRecipeSignature], // #purge
	    						
	    					});
	    				}).concat(mod$2.LCHRuntimeFilteredRecipes(LRTOptions.LCHOptionRecipes, window.location.href)),
	    				mod
	    			);
	    		},
	    		async SetupPageRecipes() {
	    			if (!LRTOptions.LCHOptionIncludePageRecipes) {
	    				return;
	    			}

	    			
	    			let inputData = window.LCHPageRecipes;

	    			if (!inputData) {
	    				inputData = (window.wrappedJSObject || {}).LCHPageRecipes;
	    			}

	    			

	    			if (!inputData &amp;&amp; window.location.origin &amp;&amp; window.location.origin !== &#34;null&#34;) {
	    				// about:blank has no origin
	    				await new Promise(function (resolve, reject) {
	    						function receiveMessage(event) {
	    							if (event.source !== window &amp;&amp; !main_1()) {
	    								return console.log(&#34;not window&#34;);
	    							}

	    							if (event.data === &#34;LCHPageRecipes&#34;) {
	    								return;
	    							}

	    							if (!Array.isArray(event.data)) {
	    								return;
	    							}

	    							window.removeEventListener(&#34;message&#34;, receiveMessage);

	    							inputData = event.data.filter(function (e) {
	    								return !mod$2.LCHRecipeProxyErrors(e);
	    							}).map(function (e) {
	    								return {
	    									LCHRecipeName: e.LCHRecipeProxyName,
	    									LCHRecipeSignature: e.LCHRecipeProxySignature,
	    									LCHRecipeCallback() {
	    										window.postMessage(e.LCHRecipeProxySignature, window.location.origin);
	    									}
	    								};
	    							});

	    							resolve();
	    						}

	    						
	    						window.addEventListener(&#34;message&#34;, receiveMessage, false);
	    						window.postMessage(&#34;LCHPageRecipes&#34;, window.location.origin);
	    						setTimeout(resolve, 20);
	    					});
	    			}

	    			

	    			if (!Array.isArray(inputData)) {
	    				return;
	    			}

	    			mod._ValueSharedRecipes.push(...Array.from(inputData).map(function (e) {
	    				delete e.LCHRecipeURLFilter;
	    				delete e.LCHRecipeIsAutomatic;
	    				e._LCHRecipeSource = window.location.host;
	    				return e;
	    			}).filter(function (e) {
	    				return !mod$2.LCHRecipesErrors(e);
	    			}));
	    		},
	    		SetupSharedAPI() {
	    			$$invalidate(1, mod._ValueSharedAPI = mod$1.LCHRuntimeAPI(mod._ValueSharedRecipes), mod);
	    		},
	    		SetupTasks() {
	    			if (!LRTOptions.LCHOptionRunAutomaticRecipes) {
	    				return;
	    			}

	    			
	    			mod$2.LCHAPIRunTasks(mod._ValueSharedRecipes, window.location.href);
	    		},
	    		SetupPromptObjects() {
	    			$$invalidate(1, mod._ValueAllPromptRecipes = mod$3.LCHLauncherUIRecipesForMode(mod._ValueSharedRecipes, LRTOptions.LCHOptionMode), mod);

	    			if (LRTOptions.LCHOptionMode === mod$3.LCHLauncherModePipe()) {
	    				$$invalidate(1, mod._ValueTypeEquivalenceMap = mod$2.LCHAPITypeEquivalenceMapForRecipes(mod._ValueSharedRecipes), mod);
	    				const typeNameMap = mod$2.LCHAPITypeNameMap(mod._ValueSharedRecipes);

	    				$$invalidate(
	    					1,
	    					mod._ValueAllSubjects = mod._ValueAllPromptRecipes.filter(function (e) {
	    						if (mod$2.LCHRecipesIsSubject(e)) {
	    							return true;
	    						}

	    						

	    						if (mod$2.LCHRecipesIsCommand(e)) {
	    							return true;
	    						}

	    						
	    						return false;
	    					}).filter(function (e) {
	    						return !e.LCHRecipeOutputType || Object.keys(mod._ValueTypeEquivalenceMap).includes(e.LCHRecipeOutputType);
	    					}).map(function (e) {
	    						return Object.assign(e, {
	    							_LCHRecipeOutputTypeName: typeNameMap[e.LCHRecipeOutputType]
	    						});
	    					}),
	    					mod
	    				);

	    				$$invalidate(1, mod._ValueAllActions = mod._ValueAllPromptRecipes.filter(mod$2.LCHRecipesIsAction), mod);

	    				const _ActionableTypesForPrimarySubject = Object.keys(mod._ValueTypeEquivalenceMap).filter(function (type) {
	    					return mod._ValueAllActions.filter(function (e) {
	    						return mod$1.LCHRuntimeInputTypes(e.LCHRecipeInputTypes).shift() === type;
	    					}).length;
	    				});

	    				return mod._ValuePromptObjects.push(...[
	    					{
	    						LCHPromptClass: &#34;LCHLauncherSubjectPrompt&#34;,
	    						LCHPromptHeading: OLSKLocalized(&#34;LCHLauncherSubjectPromptHeadingText&#34;),
	    						LCHPromptItemsVisible: [],
	    						LCHPromptItemsAll: mod._ValueAllSubjects.filter(function (e) {
	    							return !e.LCHRecipeOutputType || _ActionableTypesForPrimarySubject.includes(e.LCHRecipeOutputType);
	    						}),
	    						// LCHPromptItemSelected: null,
	    						LCHPromptInputThrottle: undefined,
	    						LCHPromptFilterText: &#34;&#34;,
	    						LCHPromptMatchStop: false,
	    						LCHPromptResultsThrottle: undefined,
	    						LCHPromptDotModeText: &#34;&#34;,
	    						LCHPromptIsVisible: true
	    					},
	    					{
	    						LCHPromptClass: &#34;LCHLauncherActionPrompt&#34;,
	    						LCHPromptHeading: OLSKLocalized(&#34;LCHLauncherActionPromptHeadingText&#34;),
	    						LCHPromptItemsVisible: [],
	    						LCHPromptItemsAll: [],
	    						// LCHPromptItemSelected: null,
	    						LCHPromptInputThrottle: undefined,
	    						LCHPromptFilterText: &#34;&#34;,
	    						LCHPromptMatchStop: false,
	    						LCHPromptResultsThrottle: undefined,
	    						LCHPromptIsVisible: true
	    					},
	    					{
	    						LCHPromptClass: &#34;LCHLauncherObjectPrompt&#34;,
	    						LCHPromptHeading: OLSKLocalized(&#34;LCHLauncherObjectPromptHeadingText&#34;),
	    						LCHPromptItemsVisible: [],
	    						LCHPromptItemsAll: [],
	    						// LCHPromptItemSelected: null,
	    						LCHPromptInputThrottle: undefined,
	    						LCHPromptFilterText: &#34;&#34;,
	    						LCHPromptMatchStop: false,
	    						LCHPromptResultsThrottle: undefined,
	    						LCHPromptDotModeText: &#34;&#34;,
	    						LCHPromptIsVisible: false
	    					}
	    				]);
	    			}

	    			mod._ValuePromptObjects.push({
	    				LCHPromptClass: &#34;LCHLauncherFilterPrompt&#34;,
	    				LCHPromptItemsVisible: [],
	    				LCHPromptItemsAll: mod._ValueAllPromptRecipes,
	    				LCHPromptFilterText: &#34;&#34;,
	    				LCHPromptResultsThrottle: false,
	    				LCHPromptIsVisible: true
	    			});

	    			if (LRTOptions.LCHOptionMode !== mod$3.LCHLauncherModePreview()) {
	    				return;
	    			}

	    			$$invalidate(1, mod._ValuePromptObjects[0].LCHPromptItemsVisible = mod._ValuePromptObjects[0].LCHPromptItemsAll, mod);

	    			$$invalidate(
	    				1,
	    				mod._ValuePromptObjects[0].LCHPromptItemSelected = mod._ValuePromptObjects[0].LCHPromptItemsAll.filter(function (e) {
	    					return e._LCHRecipeIsSelected;
	    				}).shift(),
	    				mod
	    			);
	    		},
	    		// LIFECYCLE
	    		LifecycleModuleWillMount() {
	    			mod.SetupEverything();
	    		},
	    		LifecycleModuleDidMount() {
	    			setTimeout(
	    				function () {
	    					$$invalidate(1, mod._ValueComponentDidMount = true, mod);
	    				},
	    				100
	    			);
	    		}, // mod.ReactFocusFilterInput();
	    		LifecycleModuleDidUpdate() {
	    			mod.ReactScrollSelectedItemIntoView();
	    		}
	    	};

	    	mod.LifecycleModuleWillMount();
	    	onMount(mod.LifecycleModuleDidMount);
	    	afterUpdate(mod.LifecycleModuleDidUpdate);
	    	const writable_props = [&#34;LRTOptions&#34;, &#34;LRTDidFinish&#34;];

	    	Object_1.keys($$props).forEach(key =&gt; {
	    		if (!~writable_props.indexOf(key) &amp;&amp; key.slice(0, 2) !== &#34;$$&#34;) console_1.warn(`&lt;Main&gt; was created with unknown prop &#39;${key}&#39;`);
	    	});

	    	function input_input_handler() {
	    		mod._ValuePromptObjects[0].LCHPromptFilterText = this.value;
	    		$$invalidate(1, mod);
	    	}

	    	function input_binding($$value) {
	    		binding_callbacks[$$value ? &#34;unshift&#34; : &#34;push&#34;](() =&gt; {
	    			mod._ValueFilterInputInstance = $$value;
	    			$$invalidate(1, mod);
	    		});
	    	}

	    	const input_handler = () =&gt; ActivePromptFilterTextShouldUpdate(mod._ValueFilterInputInstance.value);

	    	function input_input_handler_1(each_value, e_index) {
	    		each_value[e_index].LCHPromptDotModeText = this.value;
	    		$$invalidate(1, mod);
	    	}

	    	const ResultListDispatchArrow_handler = event =&gt; ActivePromptItemSelectedShouldUpdate(event.detail);
	    	const ResultListDispatchClick_handler = event =&gt; ActivePromptItemSelectedShouldUpdate(event.detail) || mod.ControlTerminate();
	    	const click_handler = e =&gt; mod.interfaceDidClickPrompt(e);

	    	function div_binding($$value) {
	    		binding_callbacks[$$value ? &#34;unshift&#34; : &#34;push&#34;](() =&gt; {
	    			mod._ValueRootElementInstance = $$value;
	    			$$invalidate(1, mod);
	    		});
	    	}

	    	$$self.$$set = $$props =&gt; {
	    		if (&#34;LRTOptions&#34; in $$props) $$invalidate(0, LRTOptions = $$props.LRTOptions);
	    		if (&#34;LRTDidFinish&#34; in $$props) $$invalidate(5, LRTDidFinish = $$props.LRTDidFinish);
	    	};

	    	$$self.$capture_state = () =&gt; ({
	    		LRTOptions,
	    		LRTDidFinish,
	    		OLSK_SPEC_UI: main_1,
	    		LCHLauncherLogic: mod$3,
	    		LCHLauncherAPI: mod$2,
	    		OLSKInternational,
	    		OLSKLocalized,
	    		fuzzysort,
	    		ActivePromptFilterTextShouldUpdate,
	    		ActivePromptItemsShouldUpdate,
	    		ActivePromptItemSelectedShouldUpdate,
	    		refactorDependancies,
	    		OLSKThrottle: main$2,
	    		LCHRuntime: mod$1,
	    		LCHLauncherStandardRecipes,
	    		LCHRunCommandRecipe,
	    		LCHPrimitiveURLCallback,
	    		apiComponents,
	    		mod,
	    		onMount,
	    		afterUpdate,
	    		LCHLauncherPrompt: Main$3,
	    		LCHLauncherPipeItem: Main$2
	    	});

	    	$$self.$inject_state = $$props =&gt; {
	    		if (&#34;LRTOptions&#34; in $$props) $$invalidate(0, LRTOptions = $$props.LRTOptions);
	    		if (&#34;LRTDidFinish&#34; in $$props) $$invalidate(5, LRTDidFinish = $$props.LRTDidFinish);
	    	};

	    	if ($$props &amp;&amp; &#34;$$inject&#34; in $$props) {
	    		$$self.$inject_state($$props.$$inject);
	    	}

	    	return [
	    		LRTOptions,
	    		mod,
	    		OLSKLocalized,
	    		ActivePromptFilterTextShouldUpdate,
	    		ActivePromptItemSelectedShouldUpdate,
	    		LRTDidFinish,
	    		input_input_handler,
	    		input_binding,
	    		input_handler,
	    		input_input_handler_1,
	    		ResultListDispatchArrow_handler,
	    		ResultListDispatchClick_handler,
	    		click_handler,
	    		div_binding
	    	];
	    }

	    class Main$4 extends SvelteComponentDev {
	    	constructor(options) {
	    		super(options);
	    		init(this, options, instance$4, create_fragment$4, safe_not_equal, { LRTOptions: 0, LRTDidFinish: 5 });

	    		dispatch_dev(&#34;SvelteRegisterComponent&#34;, {
	    			component: this,
	    			tagName: &#34;Main&#34;,
	    			options,
	    			id: create_fragment$4.name
	    		});
	    	}

	    	get LRTOptions() {
	    		throw new Error(&#34;&lt;Main&gt;: Props cannot be read directly from the component instance unless compiling with &#39;accessors: true&#39; or &#39;&lt;svelte:options accessors/&gt;&#39;&#34;);
	    	}

	    	set LRTOptions(value) {
	    		throw new Error(&#34;&lt;Main&gt;: Props cannot be set directly on the component instance unless compiling with &#39;accessors: true&#39; or &#39;&lt;svelte:options accessors/&gt;&#39;&#34;);
	    	}

	    	get LRTDidFinish() {
	    		throw new Error(&#34;&lt;Main&gt;: Props cannot be read directly from the component instance unless compiling with &#39;accessors: true&#39; or &#39;&lt;svelte:options accessors/&gt;&#39;&#34;);
	    	}

	    	set LRTDidFinish(value) {
	    		throw new Error(&#34;&lt;Main&gt;: Props cannot be set directly on the component instance unless compiling with &#39;accessors: true&#39; or &#39;&lt;svelte:options accessors/&gt;&#39;&#34;);
	    	}
	    }

	    return Main$4;

	}));

	});

	var Main = unwrapExports(uiBehaviour);

	mod$4._ValueClass = Main;

	var rollupStart = LCHPackage();

	return rollupStart;

}());
//# sourceMappingURL=launchlet.js.map
</textarea>

<script src="/open-compose/__compiled/ui-behaviour.js"></script>


</body>
</html>
